{"version":3,"sources":["webpack:///ml-gsd/webpack/universalModuleDefinition","webpack:///ml-gsd/ml-gsd.min.js","webpack:///ml-gsd/webpack/bootstrap 37f777454acc770acd3c","webpack:///ml-gsd/./src/index.js","webpack:///ml-gsd/./src/optimize.js","webpack:///ml-gsd/./~/ml-optimize-lorentzian/src/index.js","webpack:///ml-gsd/./~/ml-curve-fitting/src/index.js","webpack:///ml-gsd/./~/ml-curve-fitting/src/LM.js","webpack:///ml-gsd/./~/ml-matrix/src/index.js","webpack:///ml-gsd/./~/ml-matrix/src/matrix.js","webpack:///ml-gsd/./~/ml-matrix/src/decompositions.js","webpack:///ml-gsd/./~/ml-matrix/src/dc/svd.js","webpack:///ml-gsd/./~/ml-matrix/src/dc/util.js","webpack:///ml-gsd/./~/ml-matrix/src/dc/evd.js","webpack:///ml-gsd/./~/ml-matrix/src/dc/lu.js","webpack:///ml-gsd/./~/ml-matrix/src/dc/qr.js","webpack:///ml-gsd/./~/ml-matrix/src/dc/cholesky.js","webpack:///ml-gsd/./~/ml-curve-fitting/src/algebra.js","webpack:///ml-gsd/./src/gsd.js","webpack:///ml-gsd/./~/ml-stat/index.js","webpack:///ml-gsd/./~/ml-stat/array.js","webpack:///ml-gsd/./~/ml-stat/matrix.js","webpack:///ml-gsd/./~/extend/index.js","webpack:///ml-gsd/./~/ml-savitzky-golay-generalized/src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","post","gsd","sampleFunction","from","to","x","y","lastIndex","nbPoints","length","sampleX","sampleY","direction","Math","sign","delta","abs","mid","stop","index","push","optimizePeaks","peakList","n","fnType","i","j","groups","groupPeaks","result","factor","peaks","group","sampling","limits","error","width","opts","optPeaks","Opt","optimizeGaussianSum","optimizeLorentzianSum","optPeak","optimizeSingleGaussian","optimizeSingleLorentzian","nL","upperLimit","lowerLimit","splice","joinBroadPeaks","options","broadLines","max","maxI","count","soft","Number","MAX_VALUE","candidates","indexes","fitted","map","sort","a","b","sumOfLorentzians","t","p2","cols","rows","Matrix","zeros","pow","singleLorentzian","columns","singleGaussian","factor2","exp","xy","peak","xy2","parseData","percentage","y_data","maxY","weight","sqrt","dot","Object","create","LMOptions","consts","dt","dx","p_init","p_min","p_max","p_fit","LM","optimize","optimizeLorentzianTrain","nextX","tI","yI","current","currentIndex","opt","optimizeGaussianTrain","math","Array","k","threshold","nbSeries","transpose","algebra","func","y_dat","dp","tensor_parameter","iteration","eps","Npar","Npnt","p_old","y_old","X2","X2_old","J","console","log","length_t","length_y_dat","multiply","prnt","MaxIter","epsilon_1","epsilon_4","lambda_0","lambda_UP_fac","lambda_DN_fac","Update_Type","dp_array","idx","Nfit","weight_sq","tmp","ones","dotMultiply","lm_matx","JtWJ","JtWdy","Chi_sq","y_hat","lambda","diag","nu","h","solve","add","eye","hidx","p_try","min","delta_y","subtract","X2_try","JtWdy_th","alpha","inv","mat","rho","dX2","apply","lm_FD_J","ps","clone","del","y1","column","dotDivide","lm_Broyden_J","h_t","div","Jt","Decompositions","DC","slice","arr","ii","nRows","nColumns","matrix","newInstance","isArray","TypeError","RangeError","defineProperty","writable","value","__proto__","prototype","Asplice","Aconcat","concat","from1DArray","newRows","newColumns","newData","data","rowVector","columnVector","l","vector","empty","fill","rand","jj","random","indices","stack","arg1","isMatrix","arguments","r","setRow","expand","base","expansion","checkMatrix","klass","get","checkRowIndex","checkColumnIndex","checkDimensions","otherMatrix","callback","to2DArray","to1DArray","copy","isRowVector","isColumnVector","isVector","isSquare","isSymmetric","set","rowIndex","columnIndex","neg","mulS","addS","addM","sub","subS","subM","mul","mulM","divS","divM","getRow","getRowVector","array","removeRow","addRow","swapRows","row1","row2","temp","getColumn","getColumnVector","setColumn","removeColumn","addColumn","swapColumns","column1","column2","row","checkRowVector","checkColumnVector","addRowVector","subRowVector","mulRowVector","divRowVector","addColumnVector","subColumnVector","mulColumnVector","divColumnVector","mulRow","mulColumn","v","Infinity","maxIndex","minIndex","maxRow","maxRowIndex","minRow","minRowIndex","maxColumn","maxColumnIndex","minColumn","minColumnIndex","sum","mean","size","prod","cumulativeSum","other","vector1","vector2","mmul","warn","Bcolj","Arowi","s","sortRows","compareFunction","sortColumns","subMatrix","startRow","endRow","startColumn","endColumn","newMatrix","subMatrixRow","X","subMatrixColumn","trace","inverse","leftHandSide","rightHandSide","LuDecomposition","QrDecomposition","SingularValueDecomposition","EigenvalueDecomposition","CholeskyDecomposition","SVD","EVD","LU","QR","CHO","wantu","wantv","computeLeftSingularVectors","computeRightSingularVectors","autoTranspose","swapped","aux","ks","f","cs","sn","kase","scale","sp","spm1","epm1","sk","ek","shift","g","U","V","e","work","nct","nrt","hypotenuse","pp","iter","condition","norm2","rank","tol","diagonal","leftSingularVectors","rightSingularVectors","diagonalMatrix","Y","scols","Ls","VL","vrows","urows","VLU","solveForDiagonal","vcols","ucols","Error","d","tred2","tql2","H","ort","orthes","hqr2","hh","dl1","c2","c3","el1","s2","tst1","low","high","nn","w","ra","sa","vr","vi","notlast","cdivres","exshift","norm","q","z","cdiv","xr","xi","yr","yi","realEigenvalues","imaginaryEigenvalues","eigenvectorMatrix","LUrowi","LUcolj","kmax","lu","pivotVector","pivotSign","isSingular","col","determinant","lowerTriangularFactor","upperTriangularFactor","pivotPermutationVector","qr","rdiag","nrm","Rdiag","isFullRank","orthogonalFactor","dimension","positiveDefinite","Lrowj","Lrowk","L","leftTriangularFactor","B","A","dotPow","undefined","minMaxRatio","broadRatio","noiseLevel","noiseFactor","maxCriteria","smoothY","realTopDetection","sgOptions","extend","sgDefOptions","maxDx","minDx","getNoiseLevel","yCorrection","SG","windowSize","polynomial","derivative","dY","ddY","maxDdy","minddY","intervalL","intervalR","lastMax","lastMin","broadMask","possible","frequency","distanceJ","minDistance","gettingCloser","signals","lastK","stddev","averageDeviations","beta","gamma","currentPoint","log10","compareNumbers","values","minMax","arithmeticMean","geometricMean","logMean","lnsum","grandMean","means","samples","truncatedMean","percent","alreadySorted","floor","harmonicMean","contraHarmonicMean","r1","r2","median","half","variance","unbiased","theMean","theVariance","standardDeviation","standardError","quartiles","quart","q1","ceil","q2","q3","pooledStandardDeviation","pooledVariance","vari","mode","itemCount","itemArray","indexOf","maxValue","covariance","mean1","mean2","cov","skewness","s3","dev","m2","m3","kurtosis","s4","m4","entropy","weightedMean","weights","weightedStandardDeviation","weightedVariance","center","inPlace","standardize","standardDev","l1","l2","N","sum1","sum2","medians","modes","skew","kurt","standardDeviations","standardErrors","sqrtN","scatter","divisor","correlation","scores","zScores","cor","resultRow","sourceRow","isNaN","weightSum","arrayStat","weightedCovariance","s1","weightedScatter","hasOwn","hasOwnProperty","toStr","toString","isPlainObject","obj","hasOwnConstructor","hasIsPrototypeOf","constructor","key","name","src","copyIsArray","target","deep","SavitzkyGolay","defaultOptions","isInteger","np","ans","fullWeights","hs","constantH","wg1","wg2","d1","d2","getHs","wg","GramPoly","Grampoly","GenFact","gf","Weight"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,UAAAH,GACA,gBAAAC,SACAA,QAAA,IAAAD,IAEAD,EAAA,IAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAASL,EAAQD,EAASM,GErDhCL,EAAAD,QAAAe,KAAAT,EAAA,GACAL,EAAAD,QAAAgB,IAAAV,EAAA,KF6DM,SAASL,EAAQD,EAASM,GG1DhC,QAAAW,GAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAAH,EAAAI,OACAC,KACAC,KACAC,EAAAC,KAAAC,KAAAT,EAAA,GAAAA,EAAA,GACA,KAAAO,IACAL,EAAA,GAAAF,EAAAI,OAAA,EAOA,KAJA,GAAAM,GAAAF,KAAAG,IAAAZ,EAAAD,GAAA,EACAc,GAAAd,EAAAC,GAAA,EACAc,GAAA,EACAC,EAAAZ,EAAA,IACAW,GAAAV,EAAAW,MAAA,GACAN,KAAAG,IAAAX,EAAAc,GAAAF,IAAAF,GACAL,EAAAU,KAAAf,EAAAc,IACAR,EAAAS,KAAAd,EAAAa,IACAA,GAAAP,GAKA,GAAAC,KAAAC,KAAAG,EAAAZ,EAAAc,IAEAA,GAAAP,EAIAM,GAAA,CAMA,OADAX,GAAA,GAAAY,GACAT,EAAAC,GAGA,QAAAU,GAAAC,EAAAjB,EAAAC,EAAAiB,EAAAC,GACA,GAAAC,GAAAC,EAAAnB,GAAA,GACAoB,EAAAC,EAAAN,EAAAC,GACAM,KACAC,EAAA,CAGA,KAFA,YAAAN,IACAM,EAAA,SACAL,EAAA,EAAYA,EAAAE,EAAAlB,OAAgBgB,IAAA,CAC5B,GAAAM,GAAAJ,EAAAF,GAAAO,KACA,IAAAD,EAAAtB,OAAA,GAKA,GAAAwB,GAAA/B,EAAAyB,EAAAF,GAAAS,OAAA,GAAAP,EAAAF,GAAAS,OAAA,GAAAP,EAAAF,GAAAS,OAAA,GAAAP,EAAAF,GAAAS,OAAA,GAAA7B,EAAAC,EAAAC,EAEA,IAAA0B,EAAA,GAAAxB,OAAA,GACA,GAAA0B,GAAAJ,EAAA,GAAAK,MAAA,IACAC,GAAA,MAAAF,MAAA,GAAAA,EAAA,GAAAA,EAAA,QAEAG,IASA,KARA,YAAAd,EACAc,EAAAC,EAAAC,oBAAAP,EAAAF,EAAAM,GAEA,cAAAb,IACAc,EAAAC,EAAAE,sBAAAR,EAAAF,EAAAM,IAIAX,EAAA,EAAwBA,EAAAY,EAAA7B,OAAkBiB,IAC1CG,EAAAT,MAAiCf,EAAAiC,EAAAZ,GAAA,MAAApB,EAAAgC,EAAAZ,GAAA,MAAAU,MAAAE,EAAAZ,GAAA,MAAAI,SAIjC,CAEAC,IAAA,EACA,IAAAE,GAAA/B,EAAA6B,EAAA1B,EAAAkB,EAAAQ,EAAAK,MACAL,EAAA1B,EAAAkB,EAAAQ,EAAAK,MAAA/B,EAAAC,EAAAC,EAGA,IAAA0B,EAAA,GAAAxB,OAAA,GACA,GAAA0B,GAAAJ,EAAAK,MAAA,IACAC,GAAA,MAAAF,MAAA,GAAAA,EAAA,GAAAA,EAAA,QAGAO,IACA,gBAAAlB,EACA,GAAAkB,GAAAH,EAAAI,wBAAAV,EAAA,GAAAA,EAAA,IAAAF,EAAAM,OAEA,kBAAAb,EACA,GAAAkB,GAAAH,EAAAK,0BAAAX,EAAA,GAAAA,EAAA,IAAAF,EAAAM,EAIAR,GAAAT,MAA6Bf,EAAAqC,EAAA,MAAApC,EAAAoC,EAAA,MAAAN,MAAAM,EAAA,MAAAZ,MAK7B,MAAAD,GAGA,QAAAD,GAAAN,EAAAuB,GACA,GAEApB,GAAAC,EAEAoB,EAAAC,EAJAf,KACAL,KAEAO,GAAAZ,EAAA,GAAAjB,EAAAwC,EAAAvB,EAAA,GAAAc,MAGA,KAAAX,EAAA,EAAYA,EAAAH,EAAAb,OAAkBgB,IAE9BZ,KAAAG,IAAAM,EAAAG,GAAApB,EAAA6B,EAAA,IAAAW,EAAAvB,EAAAG,GAAAW,MAAAF,EAAA,IAEAF,EAAAZ,KAAAE,EAAAG,IAEAqB,EAAAZ,EAAA,GAAAA,EAAA,GACAZ,EAAAG,GAAApB,EAAAwC,EAAAvB,EAAAG,GAAAW,MAAAU,IACAA,EAAAxB,EAAAG,GAAApB,EAAAwC,EAAAvB,EAAAG,GAAAW,OAEAW,EAAAb,EAAA,GAAAA,EAAA,GACAZ,EAAAG,GAAApB,EAAAwC,EAAAvB,EAAAG,GAAAW,MAAAW,IACAA,EAAAzB,EAAAG,GAAApB,EAAAwC,EAAAvB,EAAAG,GAAAW,OAEAF,IAAAY,EAAAC,GAAA,EAAAlC,KAAAG,IAAA8B,EAAAC,GAAA,KAIApB,EAAAP,MAAyBc,SAAAF,UAEzBA,GAAAV,EAAAG,IACAS,GAAAZ,EAAAG,GAAApB,EAAAwC,EAAAvB,EAAAG,GAAAW,OAKA,KAFAT,EAAAP,MAAiBc,SAAAF,UAEjBP,EAAAE,EAAAlB,OAAA,EAA2BgB,GAAA,EAAKA,IAEhC,GAAAZ,KAAAG,IAAAW,EAAAF,GAAAS,OAAA,GAAAP,EAAAF,EAAA,GAAAS,OAAA,KACAP,EAAAF,GAAAS,OAAA,GAAAP,EAAAF,EAAA,GAAAS,OAAA,OACA,IAAAR,EAAA,EAAoBA,EAAAC,EAAAF,EAAA,GAAAO,MAAAvB,OAA2BiB,IAC/CC,EAAAF,GAAAO,MAAAZ,KAAAO,EAAAF,EAAA,GAAAO,MAAAN,GAEAoB,GAAAnB,EAAAF,GAAAS,OAAA,GAAAP,EAAAF,GAAAS,OAAA,GACAP,EAAAF,EAAA,GAAAS,OAAA,GAAAP,EAAAF,EAAA,GAAAS,OAAA,GAAAY,IACAA,EAAAnB,EAAAF,EAAA,GAAAS,OAAA,GAAAP,EAAAF,EAAA,GAAAS,OAAA,IAEAa,EAAApB,EAAAF,GAAAS,OAAA,GAAAP,EAAAF,GAAAS,OAAA,GACAP,EAAAF,EAAA,GAAAS,OAAA,GAAAP,EAAAF,EAAA,GAAAS,OAAA,GAAAa,IACAA,EAAApB,EAAAF,EAAA,GAAAS,OAAA,GAAAP,EAAAF,EAAA,GAAAS,OAAA,IAGAP,EAAAF,GAAAS,SAAAY,EAAAC,GAAA,EAAAlC,KAAAG,IAAA8B,EAAAC,GAAA,GAEApB,EAAAqB,OAAAvB,EAAA,KAGA,MAAAE,GAOA,QAAAsB,GAAA3B,EAAA4B,GAMA,OALAd,GAAAc,EAAAd,MACAe,KAEAC,EAAA,EAAAC,EAAA,EAAAC,EAAA,EAEA7B,EAAAH,EAAAb,OAAA,EAAgCgB,GAAA,EAAKA,IACrCH,EAAAG,GAAA8B,MACAJ,EAAA/B,KAAAE,EAAA0B,OAAAvB,EAAA,MAIA0B,GAAA/B,MAAqBf,EAAAmD,OAAAC,WAMrB,QAJAC,KAAAP,EAAA,GAAA9C,EACA8C,EAAA,GAAA7C,IACAqD,GAAA,GAEAlC,EAAA,EAAgBA,EAAA0B,EAAA1C,OAAoBgB,IAEpC,GAAAZ,KAAAG,IAAAmC,EAAA1B,EAAA,GAAApB,EAAA8C,EAAA1B,GAAApB,GAAA+B,EACAsB,EAAAtC,MAAA+B,EAAA1B,GAAApB,EAAA8C,EAAA1B,GAAAnB,IACA6C,EAAA1B,GAAAnB,EAAA8C,IACAA,EAAAD,EAAA1B,GAAAnB,EACA+C,EAAA5B,GAEAkC,EAAAvC,KAAAK,GACA6B,QAEA,CACA,GAAAA,EAAA,GACA,GAAAM,GAAArB,EAAAK,yBAAAc,GACqBrD,EAAA8C,EAAAE,GAAAhD,EAAAC,EAAA8C,EAAAhB,MAAAvB,KAAAG,IAAA0C,EAAA,MAAAA,IAAAjD,OAAA,QACrBa,GAAAF,MAA+Bf,EAAAuD,EAAA,MAAAtD,EAAAsD,EAAA,MAAAxB,MAAAwB,EAAA,MAAAL,MAAA,QAK/BI,GAAAE,IAAA,SAAA1C,GAA4CG,EAAAF,KAAA+B,EAAAhC,KAE5CuC,KAAAP,EAAA1B,GAAApB,EAAA8C,EAAA1B,GAAAnB,IACAqD,GAAAlC,GACA2B,EAAAD,EAAA1B,GAAAnB,EACA+C,EAAA5B,EACA6B,EAAA,EAQA,MAJAhC,GAAAwC,KAAA,SAAAC,EAAAC,GACA,MAAAD,GAAA1D,EAAA2D,EAAA3D,IAGAiB,EAvNA,GAAAiB,GAAAhD,EAAA,EA2QAL,GAAAD,SAAgBoC,gBAAA4B,mBHuEV,SAAS/D,EAAQD,EAASM,GIrVhC,YAcA,SAAA0E,GAAAC,EAAAnE,EAAAD,GACA,GAAAgC,GAAAL,EAAAC,EAAAyC,EAAAtB,EAAA9C,EAAAU,OAAA,EAAA2D,EAAAF,EAAAG,KACAxC,EAAAyC,EAAAC,MAAAL,EAAAzD,OAAA,EAEA,KAAAgB,EAAA,EAAYoB,EAAApB,EAAKA,IAGjB,IAFA0C,EAAAtD,KAAA2D,IAAAzE,EAAA0B,EAAA,EAAAoB,GAAA,QACAf,EAAA/B,EAAA0B,EAAAoB,GAAA,GAAAsB,EACAzC,EAAA,EAAgB0C,EAAA1C,EAAOA,IACvBG,EAAAH,GAAA,IAAAI,GAAAjB,KAAA2D,IAAAN,EAAAxC,GAAA,GAAA3B,EAAA0B,GAAA,MAAA0C,EAGA,OAAAtC,GA8BA,QAAA4C,GAAAP,EAAAnE,EAAAD,GAIA,OAHAgC,GAAA/B,EAAA,MAAAc,KAAA2D,IAAAzE,EAAA,WACAsE,EAAAH,EAAAG,KACAxC,EAAA,GAAAyC,GAAAJ,EAAAG,KAAAH,EAAAQ,SACAjD,EAAA,EAAgB4C,EAAA5C,EAAOA,IACvBI,EAAAJ,GAAA,GAAAK,GAAAjB,KAAA2D,IAAAN,EAAAzC,GAAA,GAAA1B,EAAA,SAAAc,KAAA2D,IAAAzE,EAAA,WAEA,OAAA8B,GAUA,QAAA8C,GAAAT,EAAAnE,EAAAD,GAIA,OAHA8E,GAAA7E,EAAA,MAAAA,EAAA,QACAsE,EAAAH,EAAAG,KACAxC,EAAA,GAAAyC,GAAAJ,EAAAG,KAAAH,EAAAQ,SACAjD,EAAA,EAAgB4C,EAAA5C,EAAOA,IACvBI,EAAAJ,GAAA,GAAA1B,EAAA,MAAAc,KAAAgE,MAAAX,EAAAzC,GAAA,GAAA1B,EAAA,QAAAmE,EAAAzC,GAAA,GAAA1B,EAAA,OAAA6E,EAEA,OAAA/C,GAQA,QAAAe,GAAAkC,EAAAC,EAAA1C,GACAA,OACA,IAAA2C,GAAAC,EAAAH,EAAAzC,EAAA6C,YAAA,EAEA,WAAAF,KAAA,GAAAX,KAAA,EACA,WAGA,IAAAH,GAAAc,EAAA,GACAG,EAAAH,EAAA,GACAI,EAAAJ,EAAA,GACAxE,EAAA0D,EAAAG,KAEAgB,GAAA7E,EAAAK,KAAAyE,KAAAH,EAAAI,IAAAJ,KAEA9C,EAAAmD,OAAAC,OAAApD,EAAAqD,YAAA,sCAEAC,KACAC,EAAA/E,KAAAG,IAAAkD,EAAA,MAAAA,EAAA,OACA2B,EAAA,GAAAvB,MAAAsB,EAAA,eAAAA,EAAA,OACAE,EAAA,GAAAxB,KAAAS,EAAA1E,IAAA,IAAA0E,EAAA3C,SACA2D,EAAA,GAAAzB,KAAAS,EAAA1E,EAAAuF,IAAA,MAAAb,EAAA3C,MAAA,KACA4D,EAAA,GAAA1B,KAAAS,EAAA1E,EAAAuF,IAAA,SAAAb,EAAA3C,SAEA6D,EAAAC,EAAAC,SAAA1B,EAAAqB,EAAA5B,EAAAiB,EAAAE,EAAAQ,EAAAE,EAAAC,EAAAL,EAAAtD,EAIA,OADA4D,KAAAlG,GACAkG,EAAA,IAAAA,EAAA,MAAAb,GAAAa,EAAA,IASA,QAAAtD,GAAAmC,EAAAC,EAAA1C,GACAA,OACA,IAAA2C,GAAAC,EAAAH,EAAAzC,EAAA6C,YAAA,EAEA,WAAAF,KAAA,GAAAX,KAAA,EACA,WAGA,IAAAH,GAAAc,EAAA,GACAG,EAAAH,EAAA,GACAI,EAAAJ,EAAA,GAEAxE,EAAA0D,EAAAG,KAIAgB,GAAA7E,EAAAK,KAAAyE,KAAAH,EAAAI,IAAAJ,KAEA9C,EAAAmD,OAAAC,OAAApD,EAAAqD,YAAA,sCAEAC,KACAC,EAAA/E,KAAAG,IAAAkD,EAAA,MAAAA,EAAA,OACA2B,EAAA,GAAAvB,MAAAsB,EAAA,eAAAA,EAAA,OAEAC,EAAA,GAAAvB,MAAAzD,KAAAG,IAAAkD,EAAA,MAAAA,EAAA,sBAAAa,EAAA3C,MAAA,OACA0D,EAAA,GAAAxB,KAAAS,EAAA1E,IAAA,IAAA0E,EAAA3C,SACA2D,EAAA,GAAAzB,KAAAS,EAAA1E,EAAAuF,IAAA,MAAAb,EAAA3C,MAAA,KACA4D,EAAA,GAAA1B,KAAAS,EAAA1E,EAAAuF,IAAA,SAAAb,EAAA3C,SAIA6D,EAAAC,EAAAC,SAAAxB,EAAAmB,EAAA5B,EAAAiB,EAAAE,EAAAQ,EAAAE,EAAAC,EAAAL,EAAAtD,EAEA,OADA4D,KAAAlG,GACAkG,EAAA,IAAAA,EAAA,MAAAb,GAAAa,EAAA,IAMA,QAAAG,GAAAtB,EAAA9C,EAAAK,GACA,GAAA2C,GAAAC,EAAAH,EAEA,WAAAE,KAAA,GAAAX,KAAA,EACA,WAWA,QAHAgC,GACAC,EAAAC,EAAAnB,EACAoB,EAPAtC,EAAAc,EAAA,GACAG,EAAAH,EAAA,GACAI,EAAAJ,EAAA,GACAyB,EAAA,EACAjG,EAAA0D,EAAAzD,OAGAoB,KACAJ,EAAA,EAAgBA,EAAAO,EAAAvB,OAAgBgB,IAAA,CAGhC,IAFA4E,EAAArE,EAAAP,GAAApB,EAAA,EAAA2B,EAAAP,GAAAW,MAEA8B,EAAAuC,KAAAJ,GAAA7F,EAAAiG,IAIA,IAHAJ,EAAArE,EAAAP,GAAApB,EAAA,EAAA2B,EAAAP,GAAAW,MACAkE,KACAC,KACArC,EAAAuC,IAAAJ,GAAA7F,EAAAiG,GACAH,EAAAlF,KAAA8C,EAAAuC,GAAA,IACAF,EAAAnF,KAAA+D,EAAAsB,GAAA,GAAArB,GACAqB,GAGAD,GAAA5D,GAAA0D,EAAAC,GAAAvE,EAAAP,GAAAY,GACAmE,EACA3E,EAAAT,MAAyBf,EAAAmG,EAAA,MAAAlG,EAAAkG,EAAA,MAAApE,MAAAoE,EAAA,MAAAE,KAAA,IAGzB7E,EAAAT,MAAyBf,EAAA2B,EAAAP,GAAApB,EAAAC,EAAA0B,EAAAP,GAAAnB,EAAA8B,MAAAJ,EAAAP,GAAAW,MAAAsE,KAAA,IAIzB,MAAA7E,GAIA,QAAA8E,GAAA7B,EAAA9C,EAAAK,GACA,GAAA2C,GAAAC,EAAAH,EAEA,WAAAE,KAAA,GAAAX,KAAA,EACA,WAWA,QAHAgC,GACAC,EAAAC,EAAAnB,EACAoB,EAPAtC,EAAAc,EAAA,GACAG,EAAAH,EAAA,GACAI,EAAAJ,EAAA,GACAyB,EAAA,EACAjG,EAAA0D,EAAAzD,OAGAoB,KACAJ,EAAA,EAAgBA,EAAAO,EAAAvB,OAAgBgB,IAAA,CAGhC,IAFA4E,EAAArE,EAAAP,GAAApB,EAAA,EAAA2B,EAAAP,GAAAW,MAEA8B,EAAAuC,KAAAJ,GAAA7F,EAAAiG,IAIA,IAHAJ,EAAArE,EAAAP,GAAApB,EAAA,EAAA2B,EAAAP,GAAAW,MACAkE,KACAC,KACArC,EAAAuC,IAAAJ,GAAA7F,EAAAiG,GACAH,EAAAlF,KAAA8C,EAAAuC,GAAA,IACAF,EAAAnF,KAAA+D,EAAAsB,GAAA,GAAArB,GACAqB,GAGAD,GAAA7D,GAAA2D,EAAAC,GAAAvE,EAAAP,GAAAY,GACAmE,EACA3E,EAAAT,MAAyBf,EAAAmG,EAAA,MAAAlG,EAAAkG,EAAA,MAAApE,MAAAoE,EAAA,MAAAE,KAAA,IAGzB7E,EAAAT,MAAyBf,EAAA2B,EAAAP,GAAApB,EAAAC,EAAA0B,EAAAP,GAAAnB,EAAA8B,MAAAJ,EAAAP,GAAAW,MAAAsE,KAAA,IAIzB,MAAA7E,GAWA,QAAAY,GAAAqC,EAAA9C,EAAAK,GACA,GAAA2C,GAAAC,EAAAH,EAEA,WAAAE,KAAA,GAAAX,KAAA,EACA,WAGA,IAGA5C,GAHAyC,EAAAc,EAAA,GACAG,EAAAH,EAAA,GACAI,EAAAJ,EAAA,GACAxE,EAAA0D,EAAAG,KAEAgB,GAAA7E,EAAAoG,EAAAtB,KAAAH,EAAAI,IAAAJ,KACA9C,EAAAmD,OAAAC,OAAApD,IAAA,sCACAsD,KAEA9C,EAAAb,EAAAvB,OACAqF,EAAA,GAAAxB,GAAA,EAAAzB,EAAA,GACAkD,EAAA,GAAAzB,GAAA,EAAAzB,EAAA,GACAmD,EAAA,GAAA1B,GAAA,EAAAzB,EAAA,GACAgD,EAAA,GAAAvB,GAAA,EAAAzB,EAAA,GACA+C,EAAA/E,KAAAG,IAAAkD,EAAA,MAAAA,EAAA,MACA,KAAAzC,EAAA,EAAaoB,EAAApB,EAAKA,IAClBqE,EAAArE,GAAA,GAAAO,EAAAP,GAAApB,EACAyF,EAAArE,EAAAoB,GAAA,KACAiD,EAAArE,EAAA,EAAAoB,GAAA,GAAAb,EAAAP,GAAAW,MAEA2D,EAAAtE,GAAA,GAAAO,EAAAP,GAAApB,EAAAuF,EACAG,EAAAtE,EAAAoB,GAAA,KACAkD,EAAAtE,EAAA,EAAAoB,GAAA,GAAAb,EAAAP,GAAAW,MAAA,EAEA4D,EAAAvE,GAAA,GAAAO,EAAAP,GAAApB,EAAAuF,EACAI,EAAAvE,EAAAoB,GAAA,OACAmD,EAAAvE,EAAA,EAAAoB,GAAA,KAAAb,EAAAP,GAAAW,MAEAyD,EAAApE,GAAA,IAAAmE,EAAA,IACAC,EAAApE,EAAAoB,GAAA,SACAgD,EAAApE,EAAA,EAAAoB,GAAA,IAAA+C,EAAA,GAGA,IAAAC,IAAAhF,KAAAG,IAAAkD,EAAA,MAAAA,EAAA,WACA+B,EAAAC,EAAAC,SAAAlC,EAAA6B,EAAA5B,EAAAiB,EAAAE,EAAAQ,EAAAE,EAAAC,EAAAL,EAAAtD,EACA4D,KAAAlG,CAEA,IAAA8B,GAAA,GAAAgF,OAAAhE,EACA,KAAApB,EAAA,EAAaoB,EAAApB,EAAKA,IAClBI,EAAAJ,IAAAwE,EAAAxE,IAAAwE,EAAAxE,EAAAoB,GAAA,GAAAuC,GAAAa,EAAAxE,EAAA,EAAAoB,GAGA,OAAAhB,GAUA,QAAAW,GAAAsC,EAAA9C,EAAAK,GACA,GAAA2C,GAAAC,EAAAH,EAEA,WAAAE,KAAA,GAAAX,KAAA,EACA,WAGA,IAGA5C,GAHAyC,EAAAc,EAAA,GACAG,EAAAH,EAAA,GACAI,EAAAJ,EAAA,GACAxE,EAAA0D,EAAAG,KAEAgB,EAAA,GAAAf,GAAA9D,EAAA,GACAsG,EAAAtG,EAAAoG,EAAAtB,KAAAH,EAAAI,IAAAJ,GACA,KAAA1D,EAAA,EAAYjB,EAAAiB,EAAWA,IACvB4D,EAAA5D,GAAA,GAAAqF,CAIA,IAAAzE,GAAAmD,OAAAC,OAAApD,IAAA,sCAEAsD,KAEA9C,EAAAb,EAAAvB,OACAqF,EAAA,GAAAxB,GAAA,EAAAzB,EAAA,GACAkD,EAAA,GAAAzB,GAAA,EAAAzB,EAAA,GACAmD,EAAA,GAAA1B,GAAA,EAAAzB,EAAA,GACAgD,EAAA,GAAAvB,GAAA,EAAAzB,EAAA,GACA+C,EAAA/E,KAAAG,IAAAkD,EAAA,MAAAA,EAAA,MACA,KAAAzC,EAAA,EAAaoB,EAAApB,EAAKA,IAClBqE,EAAArE,GAAA,GAAAO,EAAAP,GAAApB,EACAyF,EAAArE,EAAAoB,GAAA,GAAAb,EAAAP,GAAAnB,EAAA8E,EACAU,EAAArE,EAAA,EAAAoB,GAAA,GAAAb,EAAAP,GAAAW,MAEA2D,EAAAtE,GAAA,GAAAO,EAAAP,GAAApB,EAAAuF,EACAG,EAAAtE,EAAAoB,GAAA,MAAAb,EAAAP,GAAAnB,EAAA8E,EACAW,EAAAtE,EAAA,EAAAoB,GAAA,GAAAb,EAAAP,GAAAW,MAAA,EAEA4D,EAAAvE,GAAA,GAAAO,EAAAP,GAAApB,EAAAuF,EACAI,EAAAvE,EAAAoB,GAAA,OAAAb,EAAAP,GAAAnB,EAAA8E,EACAY,EAAAvE,EAAA,EAAAoB,GAAA,KAAAb,EAAAP,GAAAW,MAEAyD,EAAApE,GAAA,IAAAmE,EAAA,IACAC,EAAApE,EAAAoB,GAAA,SACAgD,EAAApE,EAAA,EAAAoB,GAAA,IAAA+C,EAAA,GAGA,IAAAK,GAAAC,EAAAC,SAAAlC,EAAA6B,EAAA5B,EAAAiB,EAAAE,EAAAQ,EAAAE,EAAAC,EAAAL,EAAAtD,EACA4D,KAAAlG,CAEA,IAAA8B,GAAA,GAAAgF,OAAAhE,EACA,KAAApB,EAAA,EAAaoB,EAAApB,EAAKA,IAClBI,EAAAJ,IAAAwE,EAAAxE,IAAAwE,EAAAxE,EAAAoB,GAAA,GAAAuC,GAAAa,EAAAxE,EAAA,EAAAoB,GAGA,OAAAhB,GASA,QAAAoD,GAAAH,EAAAiC,GACA,GAEA1G,GAAAC,EACAmB,EAHAuF,EAAAlC,EAAArE,OACAyD,EAAA,KACAiB,EAAA,KACAC,EAAA,CAEA,OAAA4B,EAAA,CAEA,GAAAxG,GAAAsE,EAAA,GAAArE,MAQA,IAJAyD,EAAA,GAAA2C,OAAArG,GACA2E,EAAA,GAAA0B,OAAArG,GACAH,EAAAyE,EAAA,GACAxE,EAAAwE,EAAA,GACA,gBAAAzE,GAAA,GACA,IAAAoB,EAAA,EAAoBjB,EAAAiB,EAAWA,IAC/ByC,EAAAzC,GAAApB,EAAAoB,GACA0D,EAAA1D,GAAAnB,EAAAmB,GACAnB,EAAAmB,GAAA2D,IACAA,EAAA9E,EAAAmB,QAKA,oBAAApB,GAAA,GACA,IAAAoB,EAAA,EAAwBjB,EAAAiB,EAAWA,IACnCyC,EAAAzC,GAAApB,EAAAoB,GAAA,GACA0D,EAAA1D,GAAAnB,EAAAmB,GAAA,GACAnB,EAAAmB,GAAA,GAAA2D,IACAA,EAAA9E,EAAAmB,GAAA,QAQA,CAEA,GAAAjB,GAAAwG,CAMA,KAFA9C,EAAA,GAAA2C,OAAArG,GACA2E,EAAA,GAAA0B,OAAArG,GACAiB,EAAA,EAAmBjB,EAAAiB,EAAcA,IACjCyC,EAAAzC,GAAAqD,EAAArD,GAAA,GACA0D,EAAA1D,GAAAqD,EAAArD,GAAA,GACA0D,EAAA1D,GAAA2D,IACAA,EAAAD,EAAA1D,IAIA,IAAAA,EAAA,EAAejB,EAAAiB,EAAcA,IAC7B0D,EAAA1D,IAAA2D,CAEA,IAAA2B,EACA,IAAAtF,EAAAjB,EAAA,EAA4BiB,GAAA,EAAOA,IACnC0D,EAAA1D,GAAAsF,IACA5B,EAAAnC,OAAAvB,EAAA,GACAyC,EAAAlB,OAAAvB,EAAA,GAIA,OAAAyC,GAAAzD,OAAA,GACA,GAAA6D,IAAAJ,IAAA+C,YAAA,GAAA3C,IAAAa,IAAA8B,YAAA7B,GACA,KAzbA,GAAAc,GAAA3G,EAAA,GACAqH,EAAAV,EAAA5B,OAAA4C,QACA5C,EAAA/E,EAAA,EA8bAL,GAAAD,QAAA2D,2BACA1D,EAAAD,QAAAwD,wBACAvD,EAAAD,QAAA0D,yBACAzD,EAAAD,QAAAuD,sBACAtD,EAAAD,QAAA0F,iBACAzF,EAAAD,QAAAwF,mBACAvF,EAAAD,QAAA0H,wBACAzH,EAAAD,QAAAmH,2BJ2VM,SAASlH,EAAQD,EAASM,GKpyBhC,YAEAL,GAAAD,QAAAM,EAAA,GACAL,EAAAD,QAAAqF,OAAA/E,EAAA,GACAL,EAAAD,QAAAqF,OAAA4C,QAAA3H,EAAA,KL2yBM,SAASL,EAAQD,EAASM,GM5yBhC,GAAA+E,GAAA/E,EAAA,GACAqH,EAAArH,EAAA,IAwDA2G,GAEAC,SAAA,SAAAgB,EAAApH,EAAAmE,EAAAkD,EAAA/B,EAAAgC,EAAAtB,EAAAC,EAAAlG,EAAAuC,GAEA,GAAAiF,GAAA,EAEAC,EAAA,CAGA,oBAAAxH,GAAA,GACA,OAAA0B,GAAA,EAAwBA,EAAA1B,EAAAU,OAAYgB,IACpC1B,EAAA0B,IAAA1B,EAAA0B,GAKA,IAAAA,GAAAqF,EACAU,EAAA,IACAC,EAAA1H,EAAAU,OACAiH,EAAAN,EAAA3G,OACAkH,EAAArD,EAAAC,MAAAkD,EAAA,GACAG,EAAAtD,EAAAC,MAAAmD,EAAA,GACAG,EAAA,IAAAL,EACAM,EAAA,IAAAN,EACAO,EAAAzD,EAAAC,MAAAmD,EAAAD,EAGA,IAAAvD,EAAAzD,QAAA2G,EAAA3G,OAAA,CACAuH,QAAAC,IAAA,8DAEAC,SAAAhE,EAAAzD,OACA0H,aAAAf,EAAA3G,MACA,IAAAoH,GAAA,CACA,KAAAP,EACA,OAIAjC,KAAAxE,KAAAyE,MAAAoC,EAAAD,EAAA,GAAAb,EAAAwB,SAAAxB,EAAAK,UAAAG,OACAC,KAAA,KACAtB,KAAAa,EAAAwB,SAAAvH,KAAAG,IAAAjB,GAAA,MACAiG,KAAAY,EAAAwB,SAAAvH,KAAAG,IAAAjB,GAAA,KACAD,KAAA,EAGAuC,MAAA,KAAAoF,EAAA,8BAEA,IAAAY,GAAAhG,EAAA,GACAiG,EAAAjG,EAAA,GACAkG,EAAAlG,EAAA,GAGAmG,GAFAnG,EAAA,GACAA,EAAA,GACAA,EAAA,IACAoG,EAAApG,EAAA,GACAqG,EAAArG,EAAA,GACAsG,EAAAtG,EAAA,GACAuG,EAAAvG,EAAA,EAOA,IAHAiF,GAAA,GAAAe,MAAA,IAGAhB,EAAA5G,QAAA,GAAA4G,EAAA5G,OAAA,CAEA,OADAoI,GAAA,GAAAhC,OAAAY,GACAhG,EAAA,EAAwBgG,EAAAhG,EAAOA,IAC/BoH,EAAApH,IAAA4F,EACAA,GAAAwB,EAIA,GAAAC,KACA,KAAArH,EAAA,EAAgBA,EAAA4F,EAAA5G,OAAYgB,IAC5B,GAAA4F,EAAA5F,GAAA,IACAqH,EAAA1H,KAAAK,EAIA,IAAAsH,GAAAD,EAAArI,OACAS,GAAA,EAEA8H,EAAA,IAEA,KAAA3D,EAAA5E,QAAA4E,EAAA5E,OAAAiH,EAAA,CAIA,GAAAuB,GAAArC,EAAAwB,SAAA9D,EAAA4E,KAAAxB,EAAA,GAAArC,EAAA,GACA2D,GAAApC,EAAAuC,YAAAF,SAIAD,GAAApC,EAAAuC,YAAA9D,IAMA,IAAAxD,GAAAxC,KAAA+J,QAAAjC,EAAAjD,EAAAyD,EAAAC,EAAA,EAAAG,EAAAhI,EAAAqH,EAAA4B,EAAA3B,EAAAvH,GACAuJ,EAAAxH,EAAAwH,KAAAC,EAAAzH,EAAAyH,MAAAzB,EAAAhG,EAAA0H,OAAAC,EAAA3H,EAAA2H,MAAAzB,EAAAlG,EAAAkG,CAWA,QAPAlH,KAAAuC,IAAAvC,KAAAG,IAAAsI,IAAAf,IACAP,QAAAC,IAAA,6DACAD,QAAAC,IAAA,oBAAAM,GACArH,GAAA,GAIA0H,GACA,OACAa,OAAAhB,CACA,MACA,SACAgB,OAAAhB,EAAA5H,KAAAuC,IAAAwD,EAAA8C,KAAAL,IACAM,GAAA,EAGA7B,EAAAD,CAIA,KADA,GAAA+B,GAAA,MACA1I,GAAAoH,GAAAf,GAAA,CAGA,OAFAA,GAAA,EAEAqB,GACA,OAGAgB,EAAAhD,EAAAiD,MAAAjD,EAAAkD,IAAAT,EAAAzC,EAAAwB,SAAAxB,EAAA8C,KAAA9C,EAAA8C,KAAAL,IAAAI,SAAAH,EACA,MACA,SAGAM,EAAAhD,EAAAiD,MAAAjD,EAAAkD,IAAAT,EAAAzC,EAAAwB,SAAA9D,EAAAyF,IAAAtC,GAAAgC,SAAAH,GAWA,GAAAU,GAAA,GAAAnD,OAAAiC,EAAArI,OACA,KAAAqG,EAAA,EAAoBA,EAAAgC,EAAArI,OAAaqG,IACjCkD,EAAAlD,GAAA8C,EAAAd,EAAAhC,GAEA,IAAAmD,GAAArD,EAAAkD,IAAA/J,EAAAiK,EAEA,KAAAlD,EAAA,EAAoBA,EAAAmD,EAAAxJ,OAAeqG,IACnCmD,EAAAnD,GAAA,GAAAjG,KAAAqJ,IAAArJ,KAAAuC,IAAA2C,EAAAe,GAAA,GAAAmD,EAAAnD,GAAA,IAAAd,EAAAc,GAAA,GAIA,IAAAqD,GAAAvD,EAAAwD,SAAAhD,EAAAD,EAAAjD,EAAA+F,EAAAnK,IAIAuK,EAAAzD,EAAAwB,SAAAxB,EAAAK,UAAAkD,GAAAvD,EAAAuC,YAAAgB,EAAAnB,GAEA,OAAAJ,EAAA,CAGA,GAAA0B,GAAA1D,EAAAwB,SAAAxB,EAAAK,UAAAqC,GAAAM,GACAW,EAAA3D,EAAAwB,SAAAkC,EAAA1D,EAAA4D,IAAA5D,EAAAkD,IAAAlD,EAAAwB,SAAAxB,EAAAwD,SAAAC,EAAAxC,GAAA,KAAAjB,EAAAwB,SAAAkC,EAAA,IAEAV,GAAAhD,EAAAwB,SAAAmC,EAAAX,EACA,QAAA9C,GAAA,EAA4BA,EAAAgC,EAAArI,OAAaqG,IACzCkD,EAAAlD,GAAA8C,EAAAd,EAAAhC,GAGAmD,GAAArD,EAAAkD,IAAA/J,EAAAiK,GACAC,EAAArD,EAAAsD,IAAAtD,EAAAxD,IAAA2C,EAAAkE,GAAAjE,GAEAmE,EAAAvD,EAAAwD,SAAAhD,EAAAD,EAAAjD,EAAA+F,EAAAnK,IAGAuK,EAAAzD,EAAAwB,SAAAxB,EAAAK,UAAAkD,GAAAM,IAAAtB,YAAAgB,EAAAnB,IAIA,GAAA0B,IAAA7C,EAAAwC,GAAAzD,EAAAwB,SAAAxB,EAAAwB,SAAAxB,EAAAK,UAAA2C,GAAA,GAAAhD,EAAAkD,IAAAlD,EAAAwB,SAAAqB,OAAAG,GAAAN,GAEA,IAAAoB,EAAAlC,EAYA,OAVAmC,IAAA9C,EAAAC,EACAA,EAAAD,EACAF,EAAA5H,EACA6H,EAAA4B,EACAzJ,EAAAkK,EAEApI,EAAAxC,KAAA+J,QAAAjC,EAAAjD,EAAAyD,EAAAC,EAAA+C,IAAA5C,EAAAhI,EAAAqH,EAAA4B,EAAA3B,EAAAvH,GACAuJ,EAAAxH,EAAAwH,KAAAC,EAAAzH,EAAAyH,MAAAzB,EAAAhG,EAAA0H,OAAAC,EAAA3H,EAAA2H,MAAAzB,EAAAlG,EAAAkG,EAGAa,GACA,OACAa,OAAA5I,KAAAuC,IAAAqG,OAAAd,EAAA,KACA,MACA,QACAc,OAAA5I,KAAAuC,IAAAqG,QAAA,EAAAc,GAAA,KACA,MACA,QACAd,OAAA7C,EAAAwB,SAAAvH,KAAAuC,IAAA,SAAAsH,EAAA,MAAAjB,QACAE,GAAA,MAYA,QAPA9B,EAAAC,EACAP,GAAA,EAAAE,IAAA,IACA5F,EAAAxC,KAAA+J,QAAAjC,EAAAjD,EAAAyD,EAAAC,EAAA,GAAAG,EAAAhI,EAAAqH,EAAA4B,EAAA3B,EAAAvH,GACAuJ,EAAAxH,EAAAwH,KAAAC,EAAAzH,EAAAyH,MAAAqB,IAAA9I,EAAA0H,OAAAC,EAAA3H,EAAA2H,MAAAzB,EAAAlG,EAAAkG,GAIAa,GACA,OACAa,OAAA5I,KAAAqJ,IAAAT,OAAAf,EAAA,IACA,MACA,QACAe,QAAA5I,KAAAG,KAAAqJ,EAAAxC,GAAA,EAAA0C,EACA,MACA,QACAd,QAAAE,GACAA,GAAA,EAAAA,IA+CA,MAtCAX,GAAApC,EAAAwB,SAAAxB,EAAAwB,SAAAxB,EAAAK,UAAAkD,MAAA7F,EAAA4E,KAAAxB,EAAA,IAEAsB,EAAA4B,MAAA,SAAAnJ,EAAAC,GACAsH,EAAAvH,GAAAC,IAAAgG,EAAAqB,EAAA,GAAAC,EAAAvH,GAAAC,KAGAG,EAAAxC,KAAA+J,QAAAjC,EAAAjD,EAAAyD,EAAAC,EAAA,GAAAG,EAAAhI,EAAAqH,EAAA4B,EAAA3B,EAAAvH,GACAuJ,EAAAxH,EAAAwH,KAAAC,EAAAzH,EAAAyH,MAAAzB,EAAAhG,EAAA0H,OAAAC,EAAA3H,EAAA2H,MAAAzB,EAAAlG,EAAAkG,GA+BgBhI,IAAA8H,OAGhBgD,QAAA,SAAA1D,EAAAjD,EAAAnE,EAAAO,EAAA+G,EAAAvH,GAyBA,GAAAD,GAAAS,EAAAG,OACAc,EAAAxB,EAAAU,MAEA4G,MAAAT,EAAAwB,SAAA9D,EAAA4E,KAAA3H,EAAA,QAMA,QAJAuJ,GAAA/K,EAAAgL,QAEAhD,EAAA,GAAAzD,GAAAzE,EAAA0B,GAAAyJ,EAAA,GAAAnE,OAAAtF,GAEAG,EAAA,EAAuBH,EAAAG,EAAMA,IAAA,CAM7B,GAJAsJ,EAAAtJ,GAAA2F,EAAA3F,IAAA,EAAAb,KAAAG,IAAAjB,EAAA2B,GAAA,KACA3B,EAAA2B,IAAAoJ,EAAApJ,GAAA,GAAAsJ,EAAAtJ,IAGA,GAAAsJ,EAAAtJ,GAGA,GAFAuJ,GAAA9D,EAAAjD,EAAAnE,EAAAD,GAEAuH,EAAA3F,GAAA,KAKA,OADAwJ,GAAAtE,EAAAuE,UAAAvE,EAAAwD,SAAAa,GAAA3K,GAAA0K,EAAAtJ,IACAoF,EAAA,EAAgCjH,EAAAiH,EAAKA,IACrCiB,EAAAjB,GAAApF,GAAAwJ,EAAApE,GAAA,OAIA,CACA/G,EAAA2B,GAAA,GAAAoJ,EAAApJ,GAAA,GAAAsJ,EAAAtJ,EAGA,QADAwJ,GAAAtE,EAAAuE,UAAAvE,EAAAwD,SAAAa,GAAA9D,EAAAjD,EAAAnE,EAAAD,IAAA,EAAAkL,EAAAtJ,IACAoF,EAAA,EAAgCjH,EAAAiH,EAAKA,IACrCiB,EAAAjB,GAAApF,GAAAwJ,EAAApE,GAAA,GAMA/G,EAAA2B,GAAAoJ,EAAApJ,GAIA,MAAAqG,IAKAqD,aAAA,SAAAzD,EAAAC,EAAAG,EAAAhI,EAAAO,GAYA,GAAAsJ,GAAAhD,EAAAwD,SAAArK,EAAA4H,GAGA0D,EAAAzE,EAAAK,UAAA2C,EAMA,OALAyB,GAAAC,IAAA1E,EAAAwB,SAAAiD,EAAAzB,IAIA7B,EAAAnB,EAAAkD,IAAA/B,EAAAnB,EAAAwB,SAAAxB,EAAAwD,SAAA9J,EAAAsG,EAAAkD,IAAAlC,EAAAhB,EAAAwB,SAAAL,EAAA6B,KAAAyB,KAKAjC,QAAA,SAAAjC,EAAAjD,EAAAyD,EAAAC,EAAA+C,EAAA5C,EAAAhI,EAAAqH,EAAA4B,EAAA3B,EAAAvH,EAAAyH,GAoCA,GACAE,IADAL,EAAA3G,OACAV,EAAAU,OAEA4G,MAAA,IAMA,IAAAmC,GAAArC,EAAAjD,EAAAnE,EAAAD,EAKAiI,GAFAR,GAAA,EAAAE,IAAA,GAAAkD,EAAA,EAEAtL,KAAAwL,QAAA1D,EAAAjD,EAAAnE,EAAAyJ,EAAAnC,EAAAvH,GAIAT,KAAA+L,aAAAzD,EAAAC,EAAAG,EAAAhI,EAAAyJ,EAEA,IAAAW,GAAAvD,EAAAwD,SAAAhD,EAAAoC,GAIAD,EAAA3C,EAAAwB,SAAAxB,EAAAK,UAAAkD,GAAAvD,EAAAuC,YAAAgB,EAAAnB,IAEAuC,EAAA3E,EAAAK,UAAAc,GAIAsB,EAAAzC,EAAAwB,SAAAmD,EAAA3E,EAAAuC,YAAApB,EAAAnB,EAAAwB,SAAAY,EAAA1E,EAAA4E,KAAA,EAAAzB,MAGA6B,EAAA1C,EAAAwB,SAAAmD,EAAA3E,EAAAuC,YAAAH,EAAAmB,GAGA,QAAgBd,OAAAC,QAAAC,SAAAC,QAAAzB,MAQhB7I,GAAAD,QAAAiH,GNqzBM,SAAShH,EAAQD,EAASM,GOzzChC,YAEAL,GAAAD,QAAAM,EAAA,GACAL,EAAAD,QAAAuM,eAAAtM,EAAAD,QAAAwM,GAAAlM,EAAA,IPg0CM,SAASL,EAAQD,GQn0CvB,YAMA,SAAAyM,GAAAC,GAIA,IAHA,GAAAlK,GAAA,EACAmK,EAAAD,EAAAlL,OACAoB,EAAA,GAAAgF,OAAA+E,GACUA,EAAAnK,EAAQA,IAClBI,EAAAJ,GAAAkK,EAAAlK,EAEA,OAAAI,GASA,QAAAyC,GAAAuH,EAAAC,GACA,GAAAC,GAAAC,EAAAvK,EAAA,CACA,IAAAoF,MAAAoF,QAAAJ,GAAA,CAKA,GAJAG,EAAAF,EACAC,EAAAC,EAAAN,EAAAG,KACAA,EAAAE,EAAAtL,OACAqL,EAAAC,EAAA,GAAAtL,OACA,mBAAAqL,GACA,SAAAI,WAAA,0BAEA,MAAAL,EAAA,GAAAC,EAAA,GASA,SAAAK,YAAA,uBAAAN,EAAA,IAAAC,EARA,MAAkBD,EAAApK,EAAWA,IAAA,CAC7B,GAAAsK,EAAAtK,GAAAhB,SAAAqL,EACA,SAAAK,YAAA,gCACiBH,KACjBD,EAAAtK,GAAAiK,EAAAK,EAAAtK,UAMK,oBAAAoK,GAUL,SAAAK,WAAA,oBATA,MAAAL,EAAA,GAAAC,EAAA,GAMA,SAAAK,YAAA,uBAAAN,EAAA,IAAAC,EAJA,KADAC,EAAA,GAAAlF,OAAAgF,GACkBA,EAAApK,EAAWA,IAC7BsK,EAAAtK,GAAA,GAAAoF,OAAAiF,GAcA,MALAtG,QAAA4G,eAAAL,EAAA,QAA2CM,UAAA,EAAAC,MAAAT,IAC3CrG,OAAA4G,eAAAL,EAAA,WAA8CM,UAAA,EAAAC,MAAAR,IAE9CC,EAAAQ,UAAAjI,EAAAkI,UAEAT,EA3DA,GAAAU,GAAA5F,MAAA2F,UAAAxJ,OACA0J,EAAA7F,MAAA2F,UAAAG,MAoEArI,GAAAsI,YAAA,SAAAC,EAAAC,EAAAC,GACA,GAAAtM,GAAAuM,EAAAvL,EAAA,CAGA,IADAhB,EAAAoM,EAAAC,EACArM,IAAAsM,EAAAtM,OACA,SAAA0L,YAAA,8CAGA,KADAa,EAAA,GAAAnG,OAAAgG,GACUA,EAAApL,EAAaA,IACvBuL,EAAAvL,GAAAsL,EAAArB,MAAAjK,EAAAqL,GAAArL,EAAA,GAAAqL,EAEA,WAAAxI,GAAA0I,IAQA1I,EAAA2I,UAAA,SAAAF,GACA,UAAAzI,IAAAyI,KAQAzI,EAAA4I,aAAA,SAAAH,GAEA,OADAI,GAAAJ,EAAAtM,OAAA2M,EAAA,GAAAvG,OAAAsG,GACA1L,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1B2L,EAAA3L,IAAAsL,EAAAtL,GACA,WAAA6C,GAAA8I,IASA9I,EAAA+I,MAAA,SAAAhJ,EAAAK,GACA,UAAAJ,GAAAD,EAAAK,IASAJ,EAAAC,MAAA,SAAAF,EAAAK,GACA,MAAAJ,GAAA+I,MAAAhJ,EAAAK,GAAA4I,KAAA,IASAhJ,EAAA4E,KAAA,SAAA7E,EAAAK,GACA,MAAAJ,GAAA+I,MAAAhJ,EAAAK,GAAA4I,KAAA,IASAhJ,EAAAiJ,KAAA,SAAAlJ,EAAAK,GAEA,OADAqH,GAAAzH,EAAA+I,MAAAhJ,EAAAK,GACAjD,EAAA,EAAAmK,EAAAG,EAAA1H,KAAqCuH,EAAAnK,EAAQA,IAC7C,OAAAC,GAAA,EAAA8L,EAAAzB,EAAArH,QAA4C8I,EAAA9L,EAAQA,IACpDqK,EAAAtK,GAAAC,GAAAb,KAAA4M,QAGA,OAAA1B,IAQAzH,EAAAyF,IAAA,SAAAxI,GAEA,OADAwK,GAAAzH,EAAAC,MAAAhD,KAAA4L,EAAApB,EAAA1H,KACA5C,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1BsK,EAAAtK,MAAA,CAEA,OAAAsK,IAQAzH,EAAAoF,KAAA,SAAAsD,GAEA,OADAG,GAAAH,EAAAvM,OAAAsL,EAAAzH,EAAAC,MAAA4I,KACA1L,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1BsK,EAAAtK,MAAAuL,EAAAvL,EAEA,OAAAsK,IASAzH,EAAAoJ,QAAA,SAAAvN,EAAAC,GAEA,OADAgN,GAAA,GAAAvG,OAAAzG,EAAAD,GACAsB,EAAA,EAAmBA,EAAA2L,EAAA3M,OAAmBgB,IACtC2L,EAAA3L,GAAAtB,GACA,OAAAiN,IAIA9I,EAAAqJ,MAAA,SAAAC,GACA,GAAAnM,GAAAC,EAAAoF,CACA,IAAAxC,EAAAuJ,SAAAD,GAAA,CACA,GAAAvJ,GAAA,EACAD,EAAA,CACA,KAAA3C,EAAA,EAAmBA,EAAAqM,UAAArN,OAAsBgB,IACzC4C,GAAAyJ,UAAArM,GAAA4C,KACAyJ,UAAArM,GAAAiD,QAAAN,IACAA,EAAA0J,UAAArM,GAAAiD,QAGA,IAAAqJ,GAAAzJ,EAAAC,MAAAF,EAAAD,GACAtE,EAAA,CACA,KAAA2B,EAAA,EAAmBA,EAAAqM,UAAArN,OAAsBgB,IAAA,CACzC,GAAA+E,GAAAsH,UAAArM,EACA,KAAAC,EAAA,EAAuBA,EAAA8E,EAAAnC,KAAkB3C,IAAA,CACzC,IAAAoF,EAAA,EAA2BA,EAAAN,EAAA9B,QAAqBoC,IAChDiH,EAAAjO,GAAAgH,GAAAN,EAAA9E,GAAAoF,EACAhH,MAGA,MAAAiO,GAEA,GAAAlH,MAAAoF,QAAA2B,GAAA,CACA,GAAA7B,GAAAzH,EAAA+I,MAAAS,UAAArN,OAAAmN,EAAAnN,OACA,KAAAgB,EAAA,EAAmBA,EAAAqM,UAAArN,OAAsBgB,IACzCsK,EAAAiC,OAAAvM,EAAAqM,UAAArM,GACA,OAAAsK,KAKAzH,EAAA2J,OAAA,SAAAC,EAAA5K,GAEA,OADA6K,MACA1M,EAAA,EAAmBA,EAAA6B,EAAA7C,OAAkBgB,IACrC,OAAAC,GAAA,EAAuBA,EAAA4B,EAAA7B,GAAcC,IACrCyM,EAAA/M,KAAA8M,EAAAzM,GACA,WAAA6C,GAAA6J,IASA7J,EAAA8J,YAAA,SAAA9B,GACA,IAAAA,EACA,SAAAJ,WAAA,8BAKA,OAHA,WAAAI,EAAA+B,QACA/B,EAAA,GAAAhI,GAAAgI,IAEAA,GAQAhI,EAAAuJ,SAAA,SAAAvB,GACA,MAAAA,GAAA,WAAAA,EAAA+B,OAAA,GAMA7I,OAAA4G,eAAA9H,EAAAkI,UAAA,SACA8B,IAAA,WACA,kBAOA9I,OAAA4G,eAAA9H,EAAAkI,UAAA,QACA8B,IAAA,WACA,MAAAjP,MAAAgF,KAAAhF,KAAAqF,WASAJ,EAAAkI,UAAA+B,cAAA,SAAApN,GACA,KAAAA,KAAA9B,KAAAgF,KAAA,EACA,SAAA8H,YAAA,4BAQA7H,EAAAkI,UAAAgC,iBAAA,SAAArN,GACA,KAAAA,KAAA9B,KAAAqF,QAAA,EACA,SAAAyH,YAAA,+BAQA7H,EAAAkI,UAAAiC,gBAAA,SAAAC,GACA,GAAArP,KAAAgF,OAAAqK,EAAArK,MAAAhF,KAAAqF,UAAAgK,EAAAhK,QACA,SAAAyH,YAAA,uCAQA7H,EAAAkI,UAAA5B,MAAA,SAAA+D,GAEA,OADA/C,GAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BiN,EAAA/O,KAAAP,KAAAoC,EAAAC,EAGA,OAAArC,OAOAiF,EAAAkI,UAAAzB,MAAA,WACA,UAAAzG,GAAAjF,KAAAuP,cAOAtK,EAAAkI,UAAAqC,UAAA,WACA,MAAAnC,GAAA9B,SAAAvL,OAOAiF,EAAAkI,UAAAoC,UAAA,WAEA,OADAzB,GAAA9N,KAAAgF,KAAAyK,EAAA,GAAAjI,OAAAsG,GACA1L,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1BqN,EAAArN,GAAAiK,EAAArM,KAAAoC,GAEA,OAAAqN,IAMAxK,EAAAkI,UAAAuC,YAAA,WACA,WAAA1P,KAAAgF,MAMAC,EAAAkI,UAAAwC,eAAA,WACA,WAAA3P,KAAAqF,SAMAJ,EAAAkI,UAAAyC,SAAA,WACA,WAAA5P,KAAAgF,MAAA,IAAAhF,KAAAqF,SAMAJ,EAAAkI,UAAA0C,SAAA,WACA,MAAA7P,MAAAgF,OAAAhF,KAAAqF,SAMAJ,EAAAkI,UAAA2C,YAAA,WACA,GAAA9P,KAAA6P,WAAA,CAEA,OADA/B,GAAA9N,KAAAgF,KACA5C,EAAA,EAAuB0L,EAAA1L,EAAOA,IAC9B,OAAAC,GAAA,EAA2BD,GAAAC,EAAQA,IACnC,GAAArC,KAAAoC,GAAAC,KAAArC,KAAAqC,GAAAD,GACA,QAIA,UAEA,UAUA6C,EAAAkI,UAAA4C,IAAA,SAAAC,EAAAC,EAAAhD,GAEA,MADAjN,MAAAgQ,GAAAC,GAAAhD,EACAjN,MASAiF,EAAAkI,UAAA8B,IAAA,SAAAe,EAAAC,GACA,MAAAjQ,MAAAgQ,GAAAC,IAQAhL,EAAAkI,UAAAc,KAAA,SAAAhB,GAEA,OADAV,GAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,GAAA4K,CAGA,OAAAjN,OAOAiF,EAAAkI,UAAA+C,IAAA,WACA,MAAAlQ,MAAAmQ,KAAA,KAQAlL,EAAAkI,UAAA1C,IAAA,SAAAwC,GACA,sBAAAA,GACAjN,KAAAoQ,KAAAnD,IACAA,EAAAhI,EAAA8J,YAAA9B,GACAjN,KAAAqQ,KAAApD,KAQAhI,EAAAkI,UAAAiD,KAAA,SAAAnD,GAEA,OADAV,GAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,IAAA4K,CAGA,OAAAjN,OAQAiF,EAAAkI,UAAAkD,KAAA,SAAA3D,GACA1M,KAAAoP,gBAAA1C,EAEA,QADAH,GAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,IAAAqK,EAAAtK,GAAAC,EAGA,OAAArC,OAQAiF,EAAAkI,UAAAmD,IAAA,SAAArD,GACA,sBAAAA,GACAjN,KAAAuQ,KAAAtD,IACAA,EAAAhI,EAAA8J,YAAA9B,GACAjN,KAAAwQ,KAAAvD,KAQAhI,EAAAkI,UAAAoD,KAAA,SAAAtD,GAEA,OADAV,GAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,IAAA4K,CAGA,OAAAjN,OAQAiF,EAAAkI,UAAAqD,KAAA,SAAA9D,GACA1M,KAAAoP,gBAAA1C,EAEA,QADAH,GAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,IAAAqK,EAAAtK,GAAAC,EAGA,OAAArC,OAQAiF,EAAAkI,UAAAsD,IAAA,SAAAxD,GACA,sBAAAA,GACAjN,KAAAmQ,KAAAlD,IACAA,EAAAhI,EAAA8J,YAAA9B,GACAjN,KAAA0Q,KAAAzD,KAQAhI,EAAAkI,UAAAgD,KAAA,SAAAlD,GAEA,OADAV,GAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,IAAA4K,CAGA,OAAAjN,OAQAiF,EAAAkI,UAAAuD,KAAA,SAAAhE,GACA1M,KAAAoP,gBAAA1C,EAEA,QADAH,GAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,IAAAqK,EAAAtK,GAAAC,EAGA,OAAArC,OAQAiF,EAAAkI,UAAAlB,IAAA,SAAAgB,GACA,sBAAAA,GACAjN,KAAA2Q,KAAA1D,IACAA,EAAAhI,EAAA8J,YAAA9B,GACAjN,KAAA4Q,KAAA3D,KAQAhI,EAAAkI,UAAAwD,KAAA,SAAA1D,GAEA,OADAV,GAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,IAAA4K,CAGA,OAAAjN,OAQAiF,EAAAkI,UAAAyD,KAAA,SAAAlE,GACA1M,KAAAoP,gBAAA1C,EAEA,QADAH,GAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,IAAAqK,EAAAtK,GAAAC,EAGA,OAAArC,OAQAiF,EAAAkI,UAAA0D,OAAA,SAAA/O,GAEA,MADA9B,MAAAkP,cAAApN,GACAuK,EAAArM,KAAA8B,KAQAmD,EAAAkI,UAAA2D,aAAA,SAAAhP,GACA,MAAAmD,GAAA2I,UAAA5N,KAAA6Q,OAAA/O,KASAmD,EAAAkI,UAAAwB,OAAA,SAAA7M,EAAAiP,GAGA,GAFA/Q,KAAAkP,cAAApN,GACAmD,EAAAuJ,SAAAuC,SAAAvB,aACAuB,EAAA3P,SAAApB,KAAAqF,QACA,SAAAyH,YAAA,mBAEA,OADA9M,MAAA8B,GAAAuK,EAAA0E,GACA/Q,MAQAiF,EAAAkI,UAAA6D,UAAA,SAAAlP,GAEA,GADA9B,KAAAkP,cAAApN,GACA,IAAA9B,KAAAgF,KACA,SAAA8H,YAAA,yCAGA,OAFAM,GAAA7M,KAAAP,KAAA8B,EAAA,GACA9B,KAAAgF,MAAA,EACAhF,MASAiF,EAAAkI,UAAA8D,OAAA,SAAAnP,EAAAiP,GAKA,GAJA,mBAAAA,KACAA,EAAAjP,EACAA,EAAA9B,KAAAgF,MAEA,EAAAlD,KAAA9B,KAAAgF,KACA,SAAA8H,YAAA,0BAEA,IADA7H,EAAAuJ,SAAAuC,SAAAvB,aACAuB,EAAA3P,SAAApB,KAAAqF,QACA,SAAAyH,YAAA,mBAGA,OAFAM,GAAA7M,KAAAP,KAAA8B,EAAA,EAAAuK,EAAA0E,IACA/Q,KAAAgF,MAAA,EACAhF,MASAiF,EAAAkI,UAAA+D,SAAA,SAAAC,EAAAC,GACApR,KAAAkP,cAAAiC,GACAnR,KAAAkP,cAAAkC,EACA,IAAAC,GAAArR,KAAAmR,EAGA,OAFAnR,MAAAmR,GAAAnR,KAAAoR,GACApR,KAAAoR,GAAAC,EACArR,MAQAiF,EAAAkI,UAAAmE,UAAA,SAAAxP,GACA9B,KAAAmP,iBAAArN,EAEA,QADAgM,GAAA9N,KAAAgF,KAAA6G,EAAA,GAAArE,OAAAsG,GACA1L,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1ByJ,EAAAzJ,GAAApC,KAAAoC,GAAAN,EAEA,OAAA+J,IAQA5G,EAAAkI,UAAAoE,gBAAA,SAAAzP,GACA,MAAAmD,GAAA4I,aAAA7N,KAAAsR,UAAAxP,KASAmD,EAAAkI,UAAAqE,UAAA,SAAA1P,EAAAiP,GACA/Q,KAAAmP,iBAAArN,GACAmD,EAAAuJ,SAAAuC,SAAAvB,YACA,IAAA1B,GAAA9N,KAAAgF,IACA,IAAA+L,EAAA3P,SAAA0M,EACA,SAAAhB,YAAA,sBACA,QAAA1K,GAAA,EAAmB0L,EAAA1L,EAAOA,IAC1BpC,KAAAoC,GAAAN,GAAAiP,EAAA3O,EAEA,OAAApC,OAQAiF,EAAAkI,UAAAsE,aAAA,SAAA3P,GAEA,GADA9B,KAAAmP,iBAAArN,GACA,IAAA9B,KAAAqF,QACA,SAAAyH,YAAA,4CACA,QAAA1K,GAAA,EAAAmK,EAAAvM,KAAAgF,KAAmCuH,EAAAnK,EAAQA,IAC3CpC,KAAAoC,GAAAuB,OAAA7B,EAAA,EAGA,OADA9B,MAAAqF,SAAA,EACArF,MASAiF,EAAAkI,UAAAuE,UAAA,SAAA5P,EAAAiP,GAKA,GAJA,mBAAAA,KACAA,EAAAjP,EACAA,EAAA9B,KAAAqF,SAEA,EAAAvD,KAAA9B,KAAAqF,QACA,SAAAyH,YAAA,6BACA7H,GAAAuJ,SAAAuC,SAAAvB,YACA,IAAA1B,GAAA9N,KAAAgF,IACA,IAAA+L,EAAA3P,SAAA0M,EACA,SAAAhB,YAAA,sBACA,QAAA1K,GAAA,EAAmB0L,EAAA1L,EAAOA,IAC1BpC,KAAAoC,GAAAuB,OAAA7B,EAAA,EAAAiP,EAAA3O,GAGA,OADApC,MAAAqF,SAAA,EACArF,MASAiF,EAAAkI,UAAAwE,YAAA,SAAAC,EAAAC,GACA7R,KAAAkP,cAAA0C,GACA5R,KAAAkP,cAAA2C,EAEA,QADAR,GAAAS,EAAAhE,EAAA9N,KAAAgF,KACA5C,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1B0P,EAAA9R,KAAAoC,GACAiP,EAAAS,EAAAF,GACAE,EAAAF,GAAAE,EAAAD,GACAC,EAAAD,GAAAR,CAEA,OAAArR,OAUAiF,EAAAkI,UAAA4E,eAAA,SAAAhE,GAGA,GAFA9I,EAAAuJ,SAAAT,KACAA,IAAAyB,aACAzB,EAAA3M,SAAApB,KAAAqF,QACA,SAAAyH,YAAA,wDACA,OAAAiB,IAUA9I,EAAAkI,UAAA6E,kBAAA,SAAAjE,GAGA,GAFA9I,EAAAuJ,SAAAT,KACAA,IAAAyB,aACAzB,EAAA3M,SAAApB,KAAAgF,KACA,SAAA8H,YAAA,qDACA,OAAAiB,IAQA9I,EAAAkI,UAAA8E,aAAA,SAAAlE,GACAA,EAAA/N,KAAA+R,eAAAhE,EAEA,QADAxB,GAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,IAAA0L,EAAA1L,EAGA,OAAArC,OAQAiF,EAAAkI,UAAA+E,aAAA,SAAAnE,GACAA,EAAA/N,KAAA+R,eAAAhE,EAEA,QADAxB,GAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,IAAA0L,EAAA1L,EAGA,OAAArC,OAQAiF,EAAAkI,UAAAgF,aAAA,SAAApE,GACAA,EAAA/N,KAAA+R,eAAAhE,EAEA,QADAxB,GAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,IAAA0L,EAAA1L,EAGA,OAAArC,OAQAiF,EAAAkI,UAAAiF,aAAA,SAAArE,GACAA,EAAA/N,KAAA+R,eAAAhE,EAEA,QADAxB,GAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,IAAA0L,EAAA1L,EAGA,OAAArC,OAQAiF,EAAAkI,UAAAkF,gBAAA,SAAAtE,GACAA,EAAA/N,KAAAgS,kBAAAjE,EAEA,QADAxB,GAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,IAAA0L,EAAA3L,EAGA,OAAApC,OAQAiF,EAAAkI,UAAAmF,gBAAA,SAAAvE,GACAA,EAAA/N,KAAAgS,kBAAAjE,EAEA,QADAxB,GAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,IAAA0L,EAAA3L,EAGA,OAAApC,OAQAiF,EAAAkI,UAAAoF,gBAAA,SAAAxE,GACAA,EAAA/N,KAAAgS,kBAAAjE,EAEA,QADAxB,GAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,IAAA0L,EAAA3L,EAGA,OAAApC,OAQAiF,EAAAkI,UAAAqF,gBAAA,SAAAzE,GACAA,EAAA/N,KAAAgS,kBAAAjE,EAEA,QADAxB,GAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,IAAA0L,EAAA3L,EAGA,OAAApC,OASAiF,EAAAkI,UAAAsF,OAAA,SAAA3Q,EAAAmL,GACAjN,KAAAkP,cAAApN,EAEA,KADA,GAAAM,GAAA,EAAA0L,EAAA9N,KAAAqF,QACUyI,EAAA1L,EAAOA,IACjBpC,KAAA8B,GAAAM,IAAA6K,CAEA,OAAAjN,OASAiF,EAAAkI,UAAAuF,UAAA,SAAA5Q,EAAAmL,GACAjN,KAAAmP,iBAAArN,EAEA,KADA,GAAAM,GAAA,EAAA0L,EAAA9N,KAAAgF,KACU8I,EAAA1L,EAAOA,IACjBpC,KAAAoC,GAAAN,IAAAmL,GAeAhI,EAAAkI,UAAApJ,IAAA,WAGA,OAFA4O,KAAAC,KACArG,EAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,GAAAsQ,IACAA,EAAA3S,KAAAoC,GAAAC,GAIA,OAAAsQ,IAOA1N,EAAAkI,UAAA0F,SAAA,WAIA,OAHAF,KAAAC,KACAnJ,KACA8C,EAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,GAAAsQ,IACAA,EAAA3S,KAAAoC,GAAAC,GACAoH,EAAAqI,IAAA1P,EACAqH,EAAAoC,OAAAxJ,EAIA,OAAAoH,IAOAxE,EAAAkI,UAAAtC,IAAA,WAGA,OAFA8H,GAAAC,IACArG,EAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,GAAAsQ,IACAA,EAAA3S,KAAAoC,GAAAC,GAIA,OAAAsQ,IAOA1N,EAAAkI,UAAA2F,SAAA,WAIA,OAHAH,GAAAC,IACAnJ,KACA8C,EAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,GAAAsQ,IACAA,EAAA3S,KAAAoC,GAAAC,GACAoH,EAAAqI,IAAA1P,EACAqH,EAAAoC,OAAAxJ,EAIA,OAAAoH,IAQAxE,EAAAkI,UAAA4F,OAAA,SAAAjR,GACA9B,KAAAkP,cAAApN,EAEA,QADA6Q,KAAAC,KACAxQ,EAAA,EAAAmK,EAAAvM,KAAAqF,QAAsCkH,EAAAnK,EAAQA,IAC9CpC,KAAA8B,GAAAM,GAAAuQ,IACAA,EAAA3S,KAAA8B,GAAAM,GAGA,OAAAuQ,IAQA1N,EAAAkI,UAAA6F,YAAA,SAAAlR,GACA9B,KAAAkP,cAAApN,EAKA,QAJA6Q,KAAAC,KACAnJ,GACAqI,IAAAhQ,GAEAM,EAAA,EAAAmK,EAAAvM,KAAAqF,QAAsCkH,EAAAnK,EAAQA,IAC9CpC,KAAA8B,GAAAM,GAAAuQ,IACAA,EAAA3S,KAAA8B,GAAAM,GACAqH,EAAAoC,OAAAzJ,EAGA,OAAAqH,IAQAxE,EAAAkI,UAAA8F,OAAA,SAAAnR,GACA9B,KAAAkP,cAAApN,EAEA,QADA6Q,GAAAC,IACAxQ,EAAA,EAAAmK,EAAAvM,KAAAqF,QAAsCkH,EAAAnK,EAAQA,IAC9CpC,KAAA8B,GAAAM,GAAAuQ,IACAA,EAAA3S,KAAA8B,GAAAM,GAGA,OAAAuQ,IAQA1N,EAAAkI,UAAA+F,YAAA,SAAApR,GACA9B,KAAAkP,cAAApN,EAMA,QALA6Q,GAAAC,IACAnJ,GACAqI,IAAAhQ,EACA+J,OAAA,GAEAzJ,EAAA,EAAAmK,EAAAvM,KAAAqF,QAAsCkH,EAAAnK,EAAQA,IAC9CpC,KAAA8B,GAAAM,GAAAuQ,IACAA,EAAA3S,KAAA8B,GAAAM,GACAqH,EAAAoC,OAAAzJ,EAGA,OAAAqH,IAQAxE,EAAAkI,UAAAgG,UAAA,SAAArR,GACA9B,KAAAmP,iBAAArN,EAEA,QADA6Q,KAAAC,KACAxQ,EAAA,EAAAmK,EAAAvM,KAAAgF,KAAmCuH,EAAAnK,EAAQA,IAC3CpC,KAAAoC,GAAAN,GAAA6Q,IACAA,EAAA3S,KAAAoC,GAAAN,GAGA,OAAA6Q,IAQA1N,EAAAkI,UAAAiG,eAAA,SAAAtR,GACA9B,KAAAmP,iBAAArN,EAMA,QALA6Q,KAAAC,KACAnJ,GACAqI,IAAA,EACAjG,OAAA/J,GAEAM,EAAA,EAAAmK,EAAAvM,KAAAgF,KAAmCuH,EAAAnK,EAAQA,IAC3CpC,KAAAoC,GAAAN,GAAA6Q,IACAA,EAAA3S,KAAAoC,GAAAN,GACA2H,EAAAqI,IAAA1P,EAGA,OAAAqH,IAQAxE,EAAAkI,UAAAkG,UAAA,SAAAvR,GACA9B,KAAAmP,iBAAArN,EAEA,QADA6Q,GAAAC,IACAxQ,EAAA,EAAAmK,EAAAvM,KAAAgF,KAAmCuH,EAAAnK,EAAQA,IAC3CpC,KAAAoC,GAAAN,GAAA6Q,IACAA,EAAA3S,KAAAoC,GAAAN,GAGA,OAAA6Q,IAQA1N,EAAAkI,UAAAmG,eAAA,SAAAxR,GACA9B,KAAAmP,iBAAArN,EAMA,QALA6Q,GAAAC,IACAnJ,GACAqI,IAAA,EACAjG,OAAA/J,GAEAM,EAAA,EAAAmK,EAAAvM,KAAAgF,KAAmCuH,EAAAnK,EAAQA,IAC3CpC,KAAAoC,GAAAN,GAAA6Q,IACAA,EAAA3S,KAAAoC,GAAAN,GACA2H,EAAAqI,IAAA1P,EAGA,OAAAqH,IAOAxE,EAAAkI,UAAA9C,KAAA,QAAAA,KACA,IAAArK,KAAA6P,WACA,SAAAhD,WAAA,wCAEA,QADAxC,GAAA,GAAA7C,OAAAxH,KAAAgF,MACA5C,EAAA,EAAAmK,EAAAvM,KAAAgF,KAAmCuH,EAAAnK,EAAQA,IAC3CiI,EAAAjI,GAAApC,KAAAoC,KAEA,OAAAiI,IAOApF,EAAAkI,UAAAoG,IAAA,WAGA,OAFAZ,GAAA,EACApG,EAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BsQ,GAAA3S,KAAAoC,GAAAC,EAGA,OAAAsQ,IAOA1N,EAAAkI,UAAAqG,KAAA,WACA,MAAAxT,MAAAuT,MAAAvT,KAAAyT,MAOAxO,EAAAkI,UAAAuG,KAAA,QAAAA,KAGA,OAFAA,GAAA,EACAnH,EAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BqR,GAAA1T,KAAAoC,GAAAC,EAGA,OAAAqR,IAOAzO,EAAAkI,UAAAwG,cAAA,WAGA,OAFAJ,GAAA,EACAhH,EAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BkR,GAAAvT,KAAAoC,GAAAC,GACArC,KAAAoC,GAAAC,GAAAkR,CAGA,OAAAvT,OAQAiF,EAAAkI,UAAAjH,IAAA,QAAAA,GAAA0N,GACA,GAAA5T,KAAAyT,OAAAG,EAAAH,KACA,SAAA3G,YAAA,oCAIA,QAHA+G,GAAA7T,KAAAwP,YACAsE,EAAAF,EAAApE,YACAtJ,EAAA,EAAA4H,EAAA+F,EAAAzS,OACAgB,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1B8D,GAAA2N,EAAAzR,GAAA0R,EAAA1R,EAEA,OAAA8D,IAOAjB,EAAAkI,UAAA4G,KAAA,SAAAH,GACA,IAAA3O,EAAAuJ,SAAAoF,GACA,SAAA/G,WAAA,qCACA7M,MAAAqF,UAAAuO,EAAA5O,MACA2D,QAAAqL,KAAA,oFAEA,IAIA5R,GAAAC,EAAAoF,EAJAjH,EAAAR,KAAAgF,KAAA9C,EAAAlC,KAAAqF,QAAA3E,EAAAkT,EAAAvO,QACA7C,EAAA,GAAAyC,GAAAzE,EAAAE,GAEAuT,EAAA,GAAAzM,OAAAtF,EAEA,KAAAG,EAAA,EAAe3B,EAAA2B,EAAOA,IAAA,CACtB,IAAAoF,EAAA,EAAmBvF,EAAAuF,EAAOA,IAC1BwM,EAAAxM,GAAAmM,EAAAnM,GAAApF,EAEA,KAAAD,EAAA,EAAmB5B,EAAA4B,EAAOA,IAAA,CAC1B,GAAA8R,GAAAlU,KAAAoC,GAEA+R,EAAA,CACA,KAAA1M,EAAA,EAAuBvF,EAAAuF,EAAOA,IAC9B0M,GAAAD,EAAAzM,GAAAwM,EAAAxM,EAEAjF,GAAAJ,GAAAC,GAAA8R,GAGA,MAAA3R,IAQAyC,EAAAkI,UAAAiH,SAAA,SAAAC,GACA,OAAAjS,GAAA,EAAAmK,EAAAvM,KAAAgF,KAAmCuH,EAAAnK,EAAQA,IAC3CpC,KAAAoC,GAAAqC,KAAA4P,EAEA,OAAArU,OAQAiF,EAAAkI,UAAAmH,YAAA,SAAAD,GACA,OAAAjS,GAAA,EAAAmK,EAAAvM,KAAAqF,QAAsCkH,EAAAnK,EAAQA,IAC9CpC,KAAAwR,UAAApP,EAAApC,KAAAsR,UAAAlP,GAAAqC,KAAA4P,GAEA,OAAArU,OAOAiF,EAAAkI,UAAAvF,UAAA,WAGA,OAFApF,GAAA,GAAAyC,GAAAjF,KAAAqF,QAAArF,KAAAgF,MACAuH,EAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BG,EAAAH,GAAAD,GAAApC,KAAAoC,GAAAC,EAGA,OAAAG,IAWAyC,EAAAkI,UAAAoH,UAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAH,EAAAC,GAAAC,EAAAC,GAAA,EAAAH,MAAAxU,KAAAgF,MAAA,EAAAyP,MAAAzU,KAAAgF,MAAA,EAAA0P,MAAA1U,KAAAqF,SAAA,EAAAsP,MAAA3U,KAAAqF,QACA,SAAAyH,YAAA,wBAEA,QADA8H,GAAA,GAAA3P,GAAAwP,EAAAD,EAAA,EAAAG,EAAAD,EAAA,GACAtS,EAAAoS,EAA0BC,GAAArS,EAAaA,IACvC,OAAAC,GAAAqS,EAAiCC,GAAAtS,EAAgBA,IACjDuS,EAAAxS,EAAAoS,GAAAnS,EAAAqS,GAAA1U,KAAAoC,GAAAC,EAGA,OAAAuS,IAUA3P,EAAAkI,UAAA0H,aAAA,SAAAxG,EAAAqG,EAAAC,GAOA,GANA,mBAAAD,IACAA,EAAA,EACAC,EAAA3U,KAAAqF,QAAA,GACK,mBAAAsP,KACLA,EAAA3U,KAAAqF,QAAA,GAEAqP,EAAAC,GAAA,EAAAD,MAAA1U,KAAAqF,SAAA,EAAAsP,MAAA3U,KAAAqF,QACA,SAAAyH,YAAA,yBAGA,QAFAgB,GAAAO,EAAAjN,OAAA4D,EAAAhF,KAAAgF,KACA8P,EAAA,GAAA7P,GAAA6I,EAAA6G,EAAAD,EAAA,GACAtS,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1B,OAAAC,GAAAqS,EAAiCC,GAAAtS,EAAgBA,IAAA,CACjD,GAAAgM,EAAAjM,GAAA,GAAAiM,EAAAjM,IAAA4C,EACA,SAAA8H,YAAA,yBACAgI,GAAA1S,GAAAC,EAAAqS,GAAA1U,KAAAqO,EAAAjM,IAAAC,GAGA,MAAAyS,IAUA7P,EAAAkI,UAAA4H,gBAAA,SAAA1G,EAAAmG,EAAAC,GAOA,GANA,mBAAAD,IACAA,EAAA,EACAC,EAAAzU,KAAAgF,KAAA,GACK,mBAAAyP,KACLA,EAAAzU,KAAAgF,KAAA,GAEAwP,EAAAC,GAAA,EAAAD,MAAAxU,KAAAgF,MAAA,EAAAyP,MAAAzU,KAAAgF,KACA,SAAA8H,YAAA,yBAGA,QAFAgB,GAAAO,EAAAjN,OAAAiE,EAAArF,KAAAqF,QACAyP,EAAA,GAAA7P,GAAAwP,EAAAD,EAAA,EAAA1G,GACA1L,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1B,OAAAC,GAAAmS,EAA8BC,GAAApS,EAAaA,IAAA,CAC3C,GAAAgM,EAAAjM,GAAA,GAAAiM,EAAAjM,IAAAiD,EACA,SAAAyH,YAAA,yBACAgI,GAAAzS,EAAAmS,GAAApS,GAAApC,KAAAqC,GAAAgM,EAAAjM,IAGA,MAAA0S,IAOA7P,EAAAkI,UAAA6H,MAAA,QAAAA,KACA,IAAAhV,KAAA6P,WACA,SAAAhD,WAAA,2BAEA,KADA,GAAAmI,GAAA,EAAA5S,EAAA,EAAA0L,EAAA9N,KAAAgF,KACU8I,EAAA1L,EAAOA,IACjB4S,GAAAhV,KAAAoC,KAEA,OAAA4S,IAOA/P,EAAAkI,UAAAxL,IAAA,WAEA,OADA4K,GAAAvM,KAAAgF,KAAAmJ,EAAAnO,KAAAqF,QACAjD,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BrC,KAAAoC,GAAAC,GAAAb,KAAAG,IAAA3B,KAAAoC,GAAAC,KAKAxC,EAAAD,QAAAqF,GR00CM,SAASpF,EAAQD,EAASM,GSvwFhC,YAUA,SAAA+U,GAAAvI,GACA,MAAAlC,GAAAkC,EAAAzH,EAAAyF,IAAAgC,EAAA1H,OAOA,QAAAwF,GAAA0K,EAAAC,GACA,MAAAD,GAAArF,WAAA,GAAAuF,GAAAF,GAAA1K,MAAA2K,GAAA,GAAAE,GAAAH,GAAA1K,MAAA2K,GAjBA,GAAAlQ,GAAA/E,EAAA,GAEAoV,EAAApV,EAAA,GACAqV,EAAArV,EAAA,IACAkV,EAAAlV,EAAA,IACAmV,EAAAnV,EAAA,IACAsV,EAAAtV,EAAA,GAMA+E,GAAAkI,UAAA8H,QAAA,WACA,MAAAA,GAAAjV,OAOAiF,EAAAkI,UAAA3C,MAAA,SAAAoJ,GACA,MAAApJ,GAAAxK,KAAA4T,IAGA/T,EAAAD,SACA0V,6BACAG,IAAAH,EACAC,0BACAG,IAAAH,EACAH,kBACAO,GAAAP,EACAC,kBACAO,GAAAP,EACAG,wBACAK,IAAAL,EACAP,UACAzK,UT+wFM,SAAS3K,EAAQD,EAASM,GUrzFhC,YAMA,SAAAoV,GAAArI,EAAApJ,GACA,KAAA7D,eAAAsV,IACA,UAAAA,GAAArI,EAAApJ,EAEAoJ,GAAAhI,EAAA8J,YAAA9B,GAEApJ,OAEA,IAAAa,GAAAuI,EAAAvB,QACAlL,EAAAyM,EAAAjI,KACA9C,EAAA+K,EAAA5H,QACAiF,EAAA9I,KAAAqJ,IAAArK,EAAA0B,GAEA4T,GAAA,EAAAC,GAAA,CACAlS,GAAAmS,8BAAA,IACAF,GAAA,GACAjS,EAAAoS,+BAAA,IACAF,GAAA,EACA,IAAAG,GAAArS,EAAAqS,iBAAA,EAEAC,GAAA,CACA,IAAAjU,EAAA1B,EACA,GAAA0V,EAES,CACTxR,IAAAkD,YACApH,EAAAkE,EAAAM,KACA9C,EAAAwC,EAAAW,QACA8Q,GAAA,CACA,IAAAC,GAAAN,CACAA,GAAAC,EACAA,EAAAK,MARAzN,SAAAqL,KAAA,yFAYA,IASA5R,GAAAC,EAAAoF,EAAA/G,EAAAmE,EAAAwR,EAAAC,EAAAC,EAAAC,EAAAzS,EAAA0S,EACAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAApS,EAAAlE,EAAAuW,EAAAC,EAVA9C,EAAA,GAAA3M,OAAAhG,KAAAqJ,IAAArK,EAAA,EAAA0B,IACAgV,EAAAjS,EAAAC,MAAA1E,EAAA8J,GACA6M,EAAAlS,EAAAC,MAAAhD,KACAkV,EAAA,GAAA5P,OAAAtF,GACAmV,EAAA,GAAA7P,OAAAhH,GAEA8W,EAAA9V,KAAAqJ,IAAArK,EAAA,EAAA0B,GACAqV,EAAA/V,KAAAuC,IAAA,EAAAvC,KAAAqJ,IAAA3I,EAAA,EAAA1B,GAKA,KAAAiH,EAAA,EAAA1D,EAAAvC,KAAAuC,IAAAuT,EAAAC,GAAyCxT,EAAA0D,EAASA,IAAA,CAClD,GAAA6P,EAAA7P,EAAA,CAEA,IADA0M,EAAA1M,GAAA,EACArF,EAAAqF,EAAuBjH,EAAA4B,EAAOA,IAC9B+R,EAAA1M,GAAA+P,EAAArD,EAAA1M,GAAA/C,EAAAtC,GAAAqF,GAEA,QAAA0M,EAAA1M,GAAA,CAIA,IAHA/C,EAAA+C,MAAA,IACA0M,EAAA1M,IAAA0M,EAAA1M,IAEArF,EAAAqF,EAA2BjH,EAAA4B,EAAOA,IAClCsC,EAAAtC,GAAAqF,IAAA0M,EAAA1M,EAEA/C,GAAA+C,OAAA,EAEA0M,EAAA1M,IAAA0M,EAAA1M,GAGA,IAAApF,EAAAoF,EAAA,EAAuBvF,EAAAG,EAAOA,IAAA,CAC9B,GAAAiV,EAAA7P,GAAA,IAAA0M,EAAA1M,GAAA,CAEA,IADA5C,EAAA,EACAzC,EAAAqF,EAA2BjH,EAAA4B,EAAOA,IAClCyC,GAAAH,EAAAtC,GAAAqF,GAAA/C,EAAAtC,GAAAC,EAGA,KADAwC,KAAAH,EAAA+C,MACArF,EAAAqF,EAA2BjH,EAAA4B,EAAOA,IAClCsC,EAAAtC,GAAAC,IAAAwC,EAAAH,EAAAtC,GAAAqF,GAGA2P,EAAA/U,GAAAqC,EAAA+C,GAAApF,GAGA,GAAAyT,GAAAwB,EAAA7P,EACA,IAAArF,EAAAqF,EAAuBjH,EAAA4B,EAAOA,IAC9B8U,EAAA9U,GAAAqF,GAAA/C,EAAAtC,GAAAqF,EAIA,IAAA8P,EAAA9P,EAAA,CAEA,IADA2P,EAAA3P,GAAA,EACArF,EAAAqF,EAAA,EAA2BvF,EAAAE,EAAOA,IAClCgV,EAAA3P,GAAA+P,EAAAJ,EAAA3P,GAAA2P,EAAAhV,GAEA,QAAAgV,EAAA3P,GAAA,CAGA,IAFA2P,EAAA3P,EAAA,OACA2P,EAAA3P,IAAA2P,EAAA3P,IACArF,EAAAqF,EAAA,EAA+BvF,EAAAE,EAAOA,IACtCgV,EAAAhV,IAAAgV,EAAA3P,EAEA2P,GAAA3P,EAAA,MAGA,GADA2P,EAAA3P,IAAA2P,EAAA3P,GACAjH,EAAAiH,EAAA,OAAA2P,EAAA3P,GAAA,CACA,IAAArF,EAAAqF,EAAA,EAA+BjH,EAAA4B,EAAOA,IACtCiV,EAAAjV,GAAA,CAEA,KAAAC,EAAAoF,EAAA,EAA+BvF,EAAAG,EAAOA,IACtC,IAAAD,EAAAqF,EAAA,EAAmCjH,EAAA4B,EAAOA,IAC1CiV,EAAAjV,IAAAgV,EAAA/U,GAAAqC,EAAAtC,GAAAC,EAGA,KAAAA,EAAAoF,EAAA,EAA+BvF,EAAAG,EAAOA,IAEtC,IADAwC,GAAAuS,EAAA/U,GAAA+U,EAAA3P,EAAA,GACArF,EAAAqF,EAAA,EAAmCjH,EAAA4B,EAAOA,IAC1CsC,EAAAtC,GAAAC,IAAAwC,EAAAwS,EAAAjV,GAIA,GAAA2T,EACA,IAAA3T,EAAAqF,EAAA,EAA+BvF,EAAAE,EAAOA,IACtC+U,EAAA/U,GAAAqF,GAAA2P,EAAAhV,IAkBA,GAZA1B,EAAAc,KAAAqJ,IAAA3I,EAAA1B,EAAA,GACA0B,EAAAoV,IACAnD,EAAAmD,GAAA5S,EAAA4S,OAEA5W,EAAAF,IACA2T,EAAAzT,EAAA,MAEAA,EAAA6W,EAAA,IACAH,EAAAG,GAAA7S,EAAA6S,GAAA7W,EAAA,IAEA0W,EAAA1W,EAAA,KAEAoV,EAAA,CACA,IAAAzT,EAAAiV,EAAqBhN,EAAAjI,EAAQA,IAAA,CAC7B,IAAAD,EAAA,EAAuB5B,EAAA4B,EAAOA,IAC9B8U,EAAA9U,GAAAC,GAAA,CAEA6U,GAAA7U,MAAA,EAEA,IAAAoF,EAAA6P,EAAA,EAAyB7P,GAAA,EAAQA,IACjC,OAAA0M,EAAA1M,GAAA,CACA,IAAApF,EAAAoF,EAAA,EAA+B6C,EAAAjI,EAAQA,IAAA,CAEvC,IADAwC,EAAA,EACAzC,EAAAqF,EAA+BjH,EAAA4B,EAAOA,IACtCyC,GAAAqS,EAAA9U,GAAAqF,GAAAyP,EAAA9U,GAAAC,EAGA,KADAwC,KAAAqS,EAAAzP,MACArF,EAAAqF,EAA+BjH,EAAA4B,EAAOA,IACtC8U,EAAA9U,GAAAC,IAAAwC,EAAAqS,EAAA9U,GAAAqF,GAGA,IAAArF,EAAAqF,EAA2BjH,EAAA4B,EAAOA,IAClC8U,EAAA9U,GAAAqF,IAAAyP,EAAA9U,GAAAqF,EAGA,KADAyP,EAAAzP,MAAA,EAAAyP,EAAAzP,MACArF,EAAA,EAA2BqF,EAAA,EAAArF,EAAWA,IACtC8U,EAAA9U,GAAAqF,GAAA,MAEa,CACb,IAAArF,EAAA,EAA2B5B,EAAA4B,EAAOA,IAClC8U,EAAA9U,GAAAqF,GAAA,CAEAyP,GAAAzP,MAAA,GAKA,GAAAsO,EACA,IAAAtO,EAAAvF,EAAA,EAAuBuF,GAAA,EAAQA,IAAA,CAC/B,GAAA8P,EAAA9P,GAAA,IAAA2P,EAAA3P,GACA,IAAApF,EAAAoF,EAAA,EAA+BvF,EAAAG,EAAOA,IAAA,CAEtC,IADAwC,EAAA,EACAzC,EAAAqF,EAAA,EAAmCvF,EAAAE,EAAOA,IAC1CyC,GAAAsS,EAAA/U,GAAAqF,GAAA0P,EAAA/U,GAAAC,EAGA,KADAwC,KAAAsS,EAAA1P,EAAA,GAAAA,GACArF,EAAAqF,EAAA,EAAmCvF,EAAAE,EAAOA,IAC1C+U,EAAA/U,GAAAC,IAAAwC,EAAAsS,EAAA/U,GAAAqF,GAIA,IAAArF,EAAA,EAAuBF,EAAAE,EAAOA,IAC9B+U,EAAA/U,GAAAqF,GAAA,CAEA0P,GAAA1P,MAAA,EAOA,IAHA,GAAAgQ,GAAA/W,EAAA,EACAgX,EAAA,EACAvP,EAAA3G,KAAA2D,IAAA,OACAzE,EAAA,IACA,IAAA+G,EAAA/G,EAAA,EAAuB+G,GAAA,IACvB,KAAAA,EADgCA,IAIhC,GAAAjG,KAAAG,IAAAyV,EAAA3P,KAAAU,GAAA3G,KAAAG,IAAAwS,EAAA1M,IAAAjG,KAAAG,IAAAwS,EAAA1M,EAAA,MACA2P,EAAA3P,GAAA,CACA,OAGA,GAAAA,IAAA/G,EAAA,EACA+V,EAAA,MACS,CACT,IAAAJ,EAAA3V,EAAA,EAA4B2V,GAAA5O,GAC5B4O,IAAA5O,EADqC4O,IAKrC,GADAxR,GAAAwR,IAAA3V,EAAAc,KAAAG,IAAAyV,EAAAf,IAAA,IAAAA,IAAA5O,EAAA,EAAAjG,KAAAG,IAAAyV,EAAAf,EAAA,OACA7U,KAAAG,IAAAwS,EAAAkC,KAAAlO,EAAAtD,EAAA,CACAsP,EAAAkC,GAAA,CACA,OAGAA,IAAA5O,EACAgP,EAAA,EACaJ,IAAA3V,EAAA,EACb+V,EAAA,GAEAA,EAAA,EACAhP,EAAA4O,GAMA,OAFA5O,IAEAgP,GACA,OAGA,IAFAH,EAAAc,EAAA1W,EAAA,GACA0W,EAAA1W,EAAA,KACA2B,EAAA3B,EAAA,EAA+B2B,GAAAoF,EAAQpF,IASvC,GARAwC,EAAA2S,EAAArD,EAAA9R,GAAAiU,GACAC,EAAApC,EAAA9R,GAAAwC,EACA2R,EAAAF,EAAAzR,EACAsP,EAAA9R,GAAAwC,EACAxC,IAAAoF,IACA6O,GAAAE,EAAAY,EAAA/U,EAAA,GACA+U,EAAA/U,EAAA,GAAAkU,EAAAa,EAAA/U,EAAA,IAEA0T,EACA,IAAA3T,EAAA,EAAmCF,EAAAE,EAAOA,IAC1CyC,EAAA0R,EAAAY,EAAA/U,GAAAC,GAAAmU,EAAAW,EAAA/U,GAAA1B,EAAA,GACAyW,EAAA/U,GAAA1B,EAAA,IAAA8V,EAAAW,EAAA/U,GAAAC,GAAAkU,EAAAY,EAAA/U,GAAA1B,EAAA,GACAyW,EAAA/U,GAAAC,GAAAwC,CAIA,MAEA,QAGA,IAFAyR,EAAAc,EAAA3P,EAAA,GACA2P,EAAA3P,EAAA,KACApF,EAAAoF,EAA2B/G,EAAA2B,EAAOA,IAOlC,GANAwC,EAAA2S,EAAArD,EAAA9R,GAAAiU,GACAC,EAAApC,EAAA9R,GAAAwC,EACA2R,EAAAF,EAAAzR,EACAsP,EAAA9R,GAAAwC,EACAyR,GAAAE,EAAAY,EAAA/U,GACA+U,EAAA/U,GAAAkU,EAAAa,EAAA/U,GACAyT,EACA,IAAA1T,EAAA,EAAmC5B,EAAA4B,EAAOA,IAC1CyC,EAAA0R,EAAAW,EAAA9U,GAAAC,GAAAmU,EAAAU,EAAA9U,GAAAqF,EAAA,GACAyP,EAAA9U,GAAAqF,EAAA,IAAA+O,EAAAU,EAAA9U,GAAAC,GAAAkU,EAAAW,EAAA9U,GAAAqF,EAAA,GACAyP,EAAA9U,GAAAC,GAAAwC,CAIA,MAEA,QAmBA,IAlBA6R,EAAAlV,KAAAuC,IAAAvC,KAAAuC,IAAAvC,KAAAuC,IAAAvC,KAAAuC,IAAAvC,KAAAG,IAAAwS,EAAAzT,EAAA,IAAAc,KAAAG,IAAAwS,EAAAzT,EAAA,KAAAc,KAAAG,IAAAyV,EAAA1W,EAAA,KAAAc,KAAAG,IAAAwS,EAAA1M,KAAAjG,KAAAG,IAAAyV,EAAA3P,KACAkP,EAAAxC,EAAAzT,EAAA,GAAAgW,EACAE,EAAAzC,EAAAzT,EAAA,GAAAgW,EACAG,EAAAO,EAAA1W,EAAA,GAAAgW,EACAI,EAAA3C,EAAA1M,GAAAiP,EACAK,EAAAK,EAAA3P,GAAAiP,EACA/R,IAAAiS,EAAAD,IAAAC,EAAAD,GAAAE,KAAA,EACApW,EAAAkW,EAAAE,GAAAF,EAAAE,GACAG,EAAA,GACA,IAAArS,GAAA,IAAAlE,KACAuW,EAAAxV,KAAAyE,KAAAtB,IAAAlE,GACA,EAAAkE,IACAqS,MAEAA,EAAAvW,GAAAkE,EAAAqS,IAEAV,GAAAQ,EAAAH,IAAAG,EAAAH,GAAAK,EACAC,EAAAH,EAAAC,EACA1U,EAAAoF,EAA2B/G,EAAA,EAAA2B,EAAWA,IAAA,CAWtC,GAVAwC,EAAA2S,EAAAlB,EAAAW,GACAV,EAAAD,EAAAzR,EACA2R,EAAAS,EAAApS,EACAxC,IAAAoF,IACA2P,EAAA/U,EAAA,GAAAwC,GAEAyR,EAAAC,EAAApC,EAAA9R,GAAAmU,EAAAY,EAAA/U,GACA+U,EAAA/U,GAAAkU,EAAAa,EAAA/U,GAAAmU,EAAArC,EAAA9R,GACA4U,EAAAT,EAAArC,EAAA9R,EAAA,GACA8R,EAAA9R,EAAA,GAAAkU,EAAApC,EAAA9R,EAAA,GACA0T,EACA,IAAA3T,EAAA,EAAmCF,EAAAE,EAAOA,IAC1CyC,EAAA0R,EAAAY,EAAA/U,GAAAC,GAAAmU,EAAAW,EAAA/U,GAAAC,EAAA,GACA8U,EAAA/U,GAAAC,EAAA,IAAAmU,EAAAW,EAAA/U,GAAAC,GAAAkU,EAAAY,EAAA/U,GAAAC,EAAA,GACA8U,EAAA/U,GAAAC,GAAAwC,CAWA,IARAA,EAAA2S,EAAAlB,EAAAW,GACAV,EAAAD,EAAAzR,EACA2R,EAAAS,EAAApS,EACAsP,EAAA9R,GAAAwC,EACAyR,EAAAC,EAAAa,EAAA/U,GAAAmU,EAAArC,EAAA9R,EAAA,GACA8R,EAAA9R,EAAA,IAAAmU,EAAAY,EAAA/U,GAAAkU,EAAApC,EAAA9R,EAAA,GACA4U,EAAAT,EAAAY,EAAA/U,EAAA,GACA+U,EAAA/U,EAAA,GAAAkU,EAAAa,EAAA/U,EAAA,GACAyT,GAAAtV,EAAA,EAAA6B,EACA,IAAAD,EAAA,EAAmC5B,EAAA4B,EAAOA,IAC1CyC,EAAA0R,EAAAW,EAAA9U,GAAAC,GAAAmU,EAAAU,EAAA9U,GAAAC,EAAA,GACA6U,EAAA9U,GAAAC,EAAA,IAAAmU,EAAAU,EAAA9U,GAAAC,GAAAkU,EAAAW,EAAA9U,GAAAC,EAAA,GACA6U,EAAA9U,GAAAC,GAAAwC,EAIAuS,EAAA1W,EAAA,GAAA4V,EACAoB,GAAA,CACA,MAEA,QACA,GAAAvD,EAAA1M,IAAA,IACA0M,EAAA1M,GAAA0M,EAAA1M,GAAA,GAAA0M,EAAA1M,GAAA,EACAsO,GACA,IAAA3T,EAAA,EAAmCqV,GAAArV,EAASA,IAC5C+U,EAAA/U,GAAAqF,IAAA0P,EAAA/U,GAAAqF,EAIA,MAAAgQ,EAAAhQ,KACA0M,EAAA1M,IAAA0M,EAAA1M,EAAA,KADA,CAOA,GAHA5C,EAAAsP,EAAA1M,GACA0M,EAAA1M,GAAA0M,EAAA1M,EAAA,GACA0M,EAAA1M,EAAA,GAAA5C,EACAkR,GAAA7T,EAAA,EAAAuF,EACA,IAAArF,EAAA,EAAmCF,EAAAE,EAAOA,IAC1CyC,EAAAsS,EAAA/U,GAAAqF,EAAA,GACA0P,EAAA/U,GAAAqF,EAAA,GAAA0P,EAAA/U,GAAAqF,GACA0P,EAAA/U,GAAAqF,GAAA5C,CAGA,IAAAiR,GAAAtV,EAAA,EAAAiH,EACA,IAAArF,EAAA,EAAmC5B,EAAA4B,EAAOA,IAC1CyC,EAAAqS,EAAA9U,GAAAqF,EAAA,GACAyP,EAAA9U,GAAAqF,EAAA,GAAAyP,EAAA9U,GAAAqF,GACAyP,EAAA9U,GAAAqF,GAAA5C,CAGA4C,KAEAiQ,EAAA,EACAhX,KAMA,GAAAyV,EAAA,CACA,GAAAvM,GAAAuN,CACAA,GAAAD,EACAA,EAAAtN,EAGA5J,KAAAQ,IACAR,KAAAkC,IACAlC,KAAAmU,IACAnU,KAAAkX,IACAlX,KAAAmX,IA9XA,GAAAlS,GAAA/E,EAAA,GACAsX,EAAAtX,EAAA,GAAAsX,UAgYAlC,GAAAnI,WACAwK,gBACA,MAAA3X,MAAAmU,EAAA,GAAAnU,KAAAmU,EAAA3S,KAAAqJ,IAAA7K,KAAAQ,EAAAR,KAAAkC,GAAA,IAEA0V,YACA,MAAA5X,MAAAmU,EAAA,IAEA0D,WAKA,OAJA1P,GAAA3G,KAAA2D,IAAA,OACA2S,EAAAtW,KAAAuC,IAAA/D,KAAAQ,EAAAR,KAAAkC,GAAAlC,KAAAmU,EAAA,GAAAhM,EACAuG,EAAA,EACAyF,EAAAnU,KAAAmU,EACA/R,EAAA,EAAAmK,EAAA4H,EAAA/S,OAAsCmL,EAAAnK,EAAQA,IAC9C+R,EAAA/R,GAAA0V,GACApJ,GAGA,OAAAA,IAEAqJ,eACA,MAAA/X,MAAAmU,GAGAzM,gBACA,MAAAlG,MAAA2D,IAAA,SAAA3D,KAAAuC,IAAA/D,KAAAQ,EAAAR,KAAAkC,GAAAlC,KAAAmU,EAAA,IAEA6D,0BACA,MAAAhY,MAAAkX,GAEAe,2BACA,MAAAjY,MAAAmX,GAEAe,qBACA,MAAAjT,GAAAoF,KAAArK,KAAAmU,IAEA3J,MAAA,SAAAyC,GAEA,GAIA7K,GAJA+V,EAAAlL,EACAmK,EAAApX,KAAA0H,UACA0Q,EAAApY,KAAAmU,EAAA/S,OACAiX,EAAApT,EAAAC,MAAAkT,IAGA,KAAAhW,EAAA,EAAmBgW,EAAAhW,EAAWA,IAC9BZ,KAAAG,IAAA3B,KAAAmU,EAAA/R,KAAAgV,EACAiB,EAAAjW,MAAA,EAEAiW,EAAAjW,MAAA,EAAApC,KAAAmU,EAAA/R,EAKA,IAIAC,GAAAoF,EAAA8L,EAJA+E,EAAAtY,KAAAmX,EAAApD,KAAAsE,GACAE,EAAAvY,KAAAmX,EAAAnS,KACAwT,EAAAxY,KAAAkX,EAAAlS,KACAyT,EAAAxT,EAAAC,MAAAqT,EAAAC,EAGA,KAAApW,EAAA,EAAmBmW,EAAAnW,EAAWA,IAC9B,IAAAC,EAAA,EAAuBmW,EAAAnW,EAAWA,IAAA,CAElC,IADAkR,EAAA,EACA9L,EAAA,EAA2B2Q,EAAA3Q,EAAWA,IACtC8L,GAAA+E,EAAAlW,GAAAqF,GAAAzH,KAAAkX,EAAA7U,GAAAoF,EAEAgR,GAAArW,GAAAC,GAAAkR,EAIA,MAAAkF,GAAA1E,KAAAoE,IAEAO,iBAAA,SAAAzL,GACA,MAAAjN,MAAAwK,MAAAvF,EAAAoF,KAAA4C,KAEAgI,QAAA,WACA,GAIA7S,GAAAC,EAJA+U,EAAApX,KAAA0H,UACA6Q,EAAAvY,KAAAmX,EAAAnS,KACA2T,EAAA3Y,KAAAmX,EAAA9R,QACAyP,EAAA,GAAA7P,GAAAsT,EAAAvY,KAAAmU,EAAA/S,OAGA,KAAAgB,EAAA,EAAmBmW,EAAAnW,EAAWA,IAC9B,IAAAC,EAAA,EAAuBsW,EAAAtW,EAAWA,IAClCb,KAAAG,IAAA3B,KAAAmU,EAAA9R,IAAA+U,EACAtC,EAAA1S,GAAAC,GAAArC,KAAAmX,EAAA/U,GAAAC,GAAArC,KAAAmU,EAAA9R,GAEAyS,EAAA1S,GAAAC,GAAA,CAKA,IAGAoF,GAAA8L,EAHAiF,EAAAxY,KAAAkX,EAAAlS,KACA4T,EAAA5Y,KAAAkX,EAAA7R,QACA8S,EAAA,GAAAlT,GAAAsT,EAAAC,EAGA,KAAApW,EAAA,EAAmBmW,EAAAnW,EAAWA,IAC9B,IAAAC,EAAA,EAAuBmW,EAAAnW,EAAWA,IAAA,CAElC,IADAkR,EAAA,EACA9L,EAAA,EAA2BmR,EAAAnR,EAAWA,IACtC8L,GAAAuB,EAAA1S,GAAAqF,GAAAzH,KAAAkX,EAAA7U,GAAAoF,EAEA0Q,GAAA/V,GAAAC,GAAAkR,EAIA,MAAA4E,KAIAtY,EAAAD,QAAA0V,GV4zFM,SAASzV,EAAQD,GW5yGvB,YAEAA,GAAA4X,WAAA,SAAA9S,EAAAC,GACA,GAAA+J,EACA,OAAAlN,MAAAG,IAAA+C,GAAAlD,KAAAG,IAAAgD,IACA+J,EAAA/J,EAAAD,EACAlD,KAAAG,IAAA+C,GAAAlD,KAAAyE,KAAA,EAAAyI,MAEA,IAAA/J,GACA+J,EAAAhK,EAAAC,EACAnD,KAAAG,IAAAgD,GAAAnD,KAAAyE,KAAA,EAAAyI,MAEA,IXozGM,SAAS7O,EAAQD,EAASM,GYh0GhC,YAMA,SAAAqV,GAAA7I,GACA,KAAA1M,eAAAuV,IACA,UAAAA,GAAA7I,EAGA,IADAA,EAAAzH,EAAA8J,YAAArC,IACAA,EAAAmD,WACA,SAAAgJ,OAAA,gCAGA,IAKAzW,GAAAC,EALAH,EAAAwK,EAAArH,QACA8R,EAAAlS,EAAAC,MAAAhD,KACA4W,EAAA,GAAAtR,OAAAtF,GACAkV,EAAA,GAAA5P,OAAAtF,GACA+K,EAAAP,CAGA,IAAAA,EAAAoD,cAAA,CACA,IAAA1N,EAAA,EAAmBF,EAAAE,EAAOA,IAC1B,IAAAC,EAAA,EAAuBH,EAAAG,EAAOA,IAC9B8U,EAAA/U,GAAAC,GAAA4K,EAAA7K,GAAAC,EAGA0W,GAAA7W,EAAAkV,EAAA0B,EAAA3B,GACA6B,EAAA9W,EAAAkV,EAAA0B,EAAA3B,OAEA,CACA,GAAA8B,GAAAhU,EAAAC,MAAAhD,KACAgX,EAAA,GAAA1R,OAAAtF,EACA,KAAAG,EAAA,EAAmBH,EAAAG,EAAOA,IAC1B,IAAAD,EAAA,EAAuBF,EAAAE,EAAOA,IAC9B6W,EAAA7W,GAAAC,GAAA4K,EAAA7K,GAAAC,EAGA8W,GAAAjX,EAAA+W,EAAAC,EAAA/B,GACAiC,EAAAlX,EAAAkV,EAAA0B,EAAA3B,EAAA8B,GAGAjZ,KAAAkC,IACAlC,KAAAoX;AACApX,KAAA8Y,IACA9Y,KAAAmX,IAmCA,QAAA4B,GAAA7W,EAAAkV,EAAA0B,EAAA3B,GAEA,GAAAb,GAAAW,EAAA1M,EAAAnI,EAAAC,EAAAoF,EACA4R,EAAA3C,CAEA,KAAArU,EAAA,EAAeH,EAAAG,EAAOA,IACtByW,EAAAzW,GAAA8U,EAAAjV,EAAA,GAAAG,EAGA,KAAAD,EAAAF,EAAA,EAAmBE,EAAA,EAAOA,IAAA,CAG1B,IAFAsU,EAAA,EACAnM,EAAA,EACA9C,EAAA,EAAmBrF,EAAAqF,EAAOA,IAC1BiP,GAAAlV,KAAAG,IAAAmX,EAAArR,GAGA,QAAAiP,EAEA,IADAU,EAAAhV,GAAA0W,EAAA1W,EAAA,GACAC,EAAA,EAAuBD,EAAAC,EAAOA,IAC9ByW,EAAAzW,GAAA8U,EAAA/U,EAAA,GAAAC,GACA8U,EAAA/U,GAAAC,GAAA,EACA8U,EAAA9U,GAAAD,GAAA,MAES,CACT,IAAAqF,EAAA,EAAuBrF,EAAAqF,EAAOA,IAC9BqR,EAAArR,IAAAiP,EACAnM,GAAAuO,EAAArR,GAAAqR,EAAArR,EAYA,KATA6O,EAAAwC,EAAA1W,EAAA,GACA6U,EAAAzV,KAAAyE,KAAAsE,GACA+L,EAAA,IACAW,MAGAG,EAAAhV,GAAAsU,EAAAO,EACA1M,GAAA+L,EAAAW,EACA6B,EAAA1W,EAAA,GAAAkU,EAAAW,EACA5U,EAAA,EAAuBD,EAAAC,EAAOA,IAC9B+U,EAAA/U,GAAA,CAGA,KAAAA,EAAA,EAAuBD,EAAAC,EAAOA,IAAA,CAI9B,IAHAiU,EAAAwC,EAAAzW,GACA8U,EAAA9U,GAAAD,GAAAkU,EACAW,EAAAG,EAAA/U,GAAA8U,EAAA9U,MAAAiU,EACA7O,EAAApF,EAAA,EAA+BD,EAAA,GAAAqF,EAAYA,IAC3CwP,GAAAE,EAAA1P,GAAApF,GAAAyW,EAAArR,GACA2P,EAAA3P,IAAA0P,EAAA1P,GAAApF,GAAAiU,CAEAc,GAAA/U,GAAA4U,EAIA,IADAX,EAAA,EACAjU,EAAA,EAAuBD,EAAAC,EAAOA,IAC9B+U,EAAA/U,IAAAkI,EACA+L,GAAAc,EAAA/U,GAAAyW,EAAAzW,EAIA,KADAgX,EAAA/C,GAAA/L,KACAlI,EAAA,EAAuBD,EAAAC,EAAOA,IAC9B+U,EAAA/U,IAAAgX,EAAAP,EAAAzW,EAGA,KAAAA,EAAA,EAAuBD,EAAAC,EAAOA,IAAA,CAG9B,IAFAiU,EAAAwC,EAAAzW,GACA4U,EAAAG,EAAA/U,GACAoF,EAAApF,EAA2BD,EAAA,GAAAqF,EAAYA,IACvC0P,EAAA1P,GAAApF,IAAAiU,EAAAc,EAAA3P,GAAAwP,EAAA6B,EAAArR,EAEAqR,GAAAzW,GAAA8U,EAAA/U,EAAA,GAAAC,GACA8U,EAAA/U,GAAAC,GAAA,GAGAyW,EAAA1W,GAAAmI,EAGA,IAAAnI,EAAA,EAAeF,EAAA,EAAAE,EAAWA,IAAA,CAI1B,GAHA+U,EAAAjV,EAAA,GAAAE,GAAA+U,EAAA/U,MACA+U,EAAA/U,MAAA,EACAmI,EAAAuO,EAAA1W,EAAA,GACA,IAAAmI,EAAA,CACA,IAAA9C,EAAA,EAAuBrF,GAAAqF,EAAQA,IAC/BqR,EAAArR,GAAA0P,EAAA1P,GAAArF,EAAA,GAAAmI,CAGA,KAAAlI,EAAA,EAAuBD,GAAAC,EAAQA,IAAA,CAE/B,IADA4U,EAAA,EACAxP,EAAA,EAA2BrF,GAAAqF,EAAQA,IACnCwP,GAAAE,EAAA1P,GAAArF,EAAA,GAAA+U,EAAA1P,GAAApF,EAEA,KAAAoF,EAAA,EAA2BrF,GAAAqF,EAAQA,IACnC0P,EAAA1P,GAAApF,IAAA4U,EAAA6B,EAAArR,IAKA,IAAAA,EAAA,EAAmBrF,GAAAqF,EAAQA,IAC3B0P,EAAA1P,GAAArF,EAAA,KAIA,IAAAC,EAAA,EAAeH,EAAAG,EAAOA,IACtByW,EAAAzW,GAAA8U,EAAAjV,EAAA,GAAAG,GACA8U,EAAAjV,EAAA,GAAAG,GAAA,CAGA8U,GAAAjV,EAAA,GAAAA,EAAA,KACAkV,EAAA,KAGA,QAAA4B,GAAA9W,EAAAkV,EAAA0B,EAAA3B,GAEA,GAAAF,GAAA1M,EAAAnI,EAAAC,EAAAoF,EAAAqG,EAAAtN,EAAAE,EAAAgO,EACA4K,EAAA7Y,EAAA8Y,EAAAC,EAAAC,EAAAtF,EAAAuF,EACAhC,CAEA,KAAAtV,EAAA,EAAeF,EAAAE,EAAOA,IACtBgV,EAAAhV,EAAA,GAAAgV,EAAAhV,EAGAgV,GAAAlV,EAAA,IAEA,IAAAoU,GAAA,EACAqD,EAAA,EACAxR,EAAA3G,KAAA2D,IAAA,MAEA,KAAA2I,EAAA,EAAe5L,EAAA4L,EAAOA,IAAA,CAGtB,IAFA6L,EAAAnY,KAAAuC,IAAA4V,EAAAnY,KAAAG,IAAAmX,EAAAhL,IAAAtM,KAAAG,IAAAyV,EAAAtJ,KACAtN,EAAAsN,EACA5L,EAAA1B,KACAgB,KAAAG,IAAAyV,EAAA5W,KAAA2H,EAAAwR,IAGAnZ,GAGA,IAAAA,EAAAsN,EAAA,CACA4J,EAAA,CACA,IAcA,IAbAA,GAAA,EAEAT,EAAA6B,EAAAhL,GACApN,GAAAoY,EAAAhL,EAAA,GAAAmJ,IAAA,EAAAG,EAAAtJ,IACAY,EAAA8I,EAAA9W,EAAA,GACA,EAAAA,IACAgO,MAGAoK,EAAAhL,GAAAsJ,EAAAtJ,IAAApN,EAAAgO,GACAoK,EAAAhL,EAAA,GAAAsJ,EAAAtJ,IAAApN,EAAAgO,GACA4K,EAAAR,EAAAhL,EAAA,GACAvD,EAAA0M,EAAA6B,EAAAhL,GACA1L,EAAA0L,EAAA,EAA+B5L,EAAAE,EAAOA,IACtC0W,EAAA1W,IAAAmI,CAYA,KATA+L,GAAA/L,EAEA7J,EAAAoY,EAAAtY,GACAC,EAAA,EACA8Y,EAAA9Y,EACA+Y,EAAA/Y,EACAgZ,EAAArC,EAAAtJ,EAAA,GACAqG,EAAA,EACAuF,EAAA,EACAtX,EAAA5B,EAAA,EAA+B4B,GAAA0L,EAAQ1L,IAavC,IAZAoX,EAAAD,EACAA,EAAA9Y,EACAiZ,EAAAvF,EACA8C,EAAAxW,EAAA2W,EAAAhV,GACAmI,EAAA9J,EAAAC,EACAgO,EAAA8I,EAAA9W,EAAA0W,EAAAhV,IACAgV,EAAAhV,EAAA,GAAA+R,EAAAzF,EACAyF,EAAAiD,EAAAhV,GAAAsM,EACAjO,EAAAC,EAAAgO,EACAhO,EAAAD,EAAAqY,EAAA1W,GAAA+R,EAAA8C,EACA6B,EAAA1W,EAAA,GAAAmI,EAAA4J,GAAA1T,EAAAwW,EAAA9C,EAAA2E,EAAA1W,IAEAqF,EAAA,EAA+BvF,EAAAuF,EAAOA,IACtC8C,EAAA4M,EAAA1P,GAAArF,EAAA,GACA+U,EAAA1P,GAAArF,EAAA,GAAA+R,EAAAgD,EAAA1P,GAAArF,GAAA3B,EAAA8J,EACA4M,EAAA1P,GAAArF,GAAA3B,EAAA0W,EAAA1P,GAAArF,GAAA+R,EAAA5J,CAIA7J,IAAAyT,EAAAuF,EAAAF,EAAAC,EAAArC,EAAAtJ,GAAAwL,EACAlC,EAAAtJ,GAAAqG,EAAAzT,EACAoY,EAAAhL,GAAArN,EAAAC,QAGAc,KAAAG,IAAAyV,EAAAtJ,IAAA3F,EAAAwR,GAEAb,EAAAhL,GAAAgL,EAAAhL,GAAAwI,EACAc,EAAAtJ,GAAA,EAGA,IAAA1L,EAAA,EAAeF,EAAA,EAAAE,EAAWA,IAAA,CAG1B,IAFAqF,EAAArF,EACA1B,EAAAoY,EAAA1W,GACAC,EAAAD,EAAA,EAAuBF,EAAAG,EAAOA,IAC9ByW,EAAAzW,GAAA3B,IACA+G,EAAApF,EACA3B,EAAAoY,EAAAzW,GAIA,IAAAoF,IAAArF,EAGA,IAFA0W,EAAArR,GAAAqR,EAAA1W,GACA0W,EAAA1W,GAAA1B,EACA2B,EAAA,EAAuBH,EAAAG,EAAOA,IAC9B3B,EAAAyW,EAAA9U,GAAAD,GACA+U,EAAA9U,GAAAD,GAAA+U,EAAA9U,GAAAoF,GACA0P,EAAA9U,GAAAoF,GAAA/G,GAMA,QAAAyY,GAAAjX,EAAA+W,EAAAC,EAAA/B,GAEA,GAEAb,GAAAW,EAAA1M,EAAAnI,EAAAC,EAAA7B,EACAkW,EAHAkD,EAAA,EACAC,EAAA3X,EAAA,CAIA,KAAA1B,EAAAoZ,EAAA,EAAqBC,EAAA,GAAArZ,EAAeA,IAAA,CAEpC,IADAkW,EAAA,EACAtU,EAAA5B,EAAmBqZ,GAAAzX,EAAWA,IAC9BsU,GAAAlV,KAAAG,IAAAsX,EAAA7W,GAAA5B,EAAA,GAGA,QAAAkW,EAAA,CAEA,IADAnM,EAAA,EACAnI,EAAAyX,EAA0BzX,GAAA5B,EAAQ4B,IAClC8W,EAAA9W,GAAA6W,EAAA7W,GAAA5B,EAAA,GAAAkW,EACAnM,GAAA2O,EAAA9W,GAAA8W,EAAA9W,EAWA,KARA6U,EAAAzV,KAAAyE,KAAAsE,GACA2O,EAAA1Y,GAAA,IACAyW,MAGA1M,GAAA2O,EAAA1Y,GAAAyW,EACAiC,EAAA1Y,GAAA0Y,EAAA1Y,GAAAyW,EAEA5U,EAAA7B,EAAuB0B,EAAAG,EAAOA,IAAA,CAE9B,IADAiU,EAAA,EACAlU,EAAAyX,EAA8BzX,GAAA5B,EAAQ4B,IACtCkU,GAAA4C,EAAA9W,GAAA6W,EAAA7W,GAAAC,EAIA,KADAiU,GAAA/L,EACAnI,EAAA5B,EAA2BqZ,GAAAzX,EAAWA,IACtC6W,EAAA7W,GAAAC,IAAAiU,EAAA4C,EAAA9W,GAIA,IAAAA,EAAA,EAAuByX,GAAAzX,EAAWA,IAAA,CAElC,IADAkU,EAAA,EACAjU,EAAAwX,EAA8BxX,GAAA7B,EAAQ6B,IACtCiU,GAAA4C,EAAA7W,GAAA4W,EAAA7W,GAAAC,EAIA,KADAiU,GAAA/L,EACAlI,EAAA7B,EAA2BqZ,GAAAxX,EAAWA,IACtC4W,EAAA7W,GAAAC,IAAAiU,EAAA4C,EAAA7W,GAIA6W,EAAA1Y,GAAAkW,EAAAwC,EAAA1Y,GACAyY,EAAAzY,KAAA,GAAAkW,EAAAO,GAIA,IAAA7U,EAAA,EAAeF,EAAAE,EAAOA,IACtB,IAAAC,EAAA,EAAmBH,EAAAG,EAAOA,IAC1B8U,EAAA/U,GAAAC,GAAAD,IAAAC,EAAA,GAIA,KAAA7B,EAAAqZ,EAAA,EAAsBrZ,GAAAoZ,EAAA,EAAcpZ,IACpC,OAAAyY,EAAAzY,KAAA,IACA,IAAA4B,EAAA5B,EAAA,EAA2BqZ,GAAAzX,EAAWA,IACtC8W,EAAA9W,GAAA6W,EAAA7W,GAAA5B,EAAA,EAGA,KAAA6B,EAAA7B,EAAuBqZ,GAAAxX,EAAWA,IAAA,CAElC,IADA4U,EAAA,EACA7U,EAAA5B,EAA2BqZ,GAAAzX,EAAWA,IACtC6U,GAAAiC,EAAA9W,GAAA+U,EAAA/U,GAAAC,EAIA,KADA4U,IAAAiC,EAAA1Y,GAAAyY,EAAAzY,KAAA,GACA4B,EAAA5B,EAA2BqZ,GAAAzX,EAAWA,IACtC+U,EAAA/U,GAAAC,IAAA4U,EAAAiC,EAAA9W,KAOA,QAAAgX,GAAAU,EAAA1C,EAAA0B,EAAA3B,EAAA8B,GACA,GAYA7W,GAAAC,EAAAoF,EAAAqG,EAAAtN,EAAAqE,EAAAkV,EAAA/Y,EAAAC,EACA+Y,EAAAC,EAAAC,EAAAC,EACAC,EAAAC,EAdAnY,EAAA4X,EAAA,EACAF,EAAA,EACAC,EAAAC,EAAA,EACA3R,EAAA3G,KAAA2D,IAAA,OACAmV,EAAA,EACAC,EAAA,EACA7Z,EAAA,EACA8Z,EAAA,EACA9L,EAAA,EACAyF,EAAA,EACAsG,EAAA,EACA/C,EAAA,CAKA,KAAAtV,EAAA,EAAe0X,EAAA1X,EAAQA,IAMvB,KALAwX,EAAAxX,KAAAyX,KACAf,EAAA1W,GAAA6W,EAAA7W,MACAgV,EAAAhV,GAAA,GAGAC,EAAAb,KAAAuC,IAAA3B,EAAA,KAAoC0X,EAAAzX,EAAQA,IAC5CkY,GAAA/Y,KAAAG,IAAAsX,EAAA7W,GAAAC,GAIA,MAAAH,GAAA0X,GAAA,CAEA,IADA9L,EAAA5L,EACA4L,EAAA8L,IACAzF,EAAA3S,KAAAG,IAAAsX,EAAAnL,EAAA,GAAAA,EAAA,IAAAtM,KAAAG,IAAAsX,EAAAnL,OACA,IAAAqG,IACAA,EAAAoG,KAEA/Y,KAAAG,IAAAsX,EAAAnL,KAAA,IAAA3F,EAAAgM,KAGArG,GAGA,IAAAA,IAAA5L,EACA+W,EAAA/W,MAAA+W,EAAA/W,MAAAoY,EACAxB,EAAA5W,GAAA+W,EAAA/W,MACAkV,EAAAlV,GAAA,EACAA,IACAwV,EAAA,MACS,IAAA5J,IAAA5L,EAAA,GAST,GARA6X,EAAAd,EAAA/W,KAAA,GAAA+W,EAAA/W,EAAA,GAAAA,GACAxB,GAAAuY,EAAA/W,EAAA,GAAAA,EAAA,GAAA+W,EAAA/W,OAAA,EACAsY,EAAA9Z,IAAAqZ,EACAU,EAAAjZ,KAAAyE,KAAAzE,KAAAG,IAAA6Y,IACAvB,EAAA/W,MAAA+W,EAAA/W,MAAAoY,EACArB,EAAA/W,EAAA,GAAAA,EAAA,GAAA+W,EAAA/W,EAAA,GAAAA,EAAA,GAAAoY,EACAtZ,EAAAiY,EAAA/W,MAEAsY,GAAA,GAiBA,IAhBAC,EAAA/Z,GAAA,EAAAA,EAAA+Z,EAAA/Z,EAAA+Z,EACA3B,EAAA5W,EAAA,GAAAlB,EAAAyZ,EACA3B,EAAA5W,GAAA4W,EAAA5W,EAAA,GACA,IAAAuY,IACA3B,EAAA5W,GAAAlB,EAAA+Y,EAAAU,GAEArD,EAAAlV,EAAA,KACAkV,EAAAlV,GAAA,EACAlB,EAAAiY,EAAA/W,KAAA,GACAiS,EAAA3S,KAAAG,IAAAX,GAAAQ,KAAAG,IAAA8Y,GACA/Z,EAAAM,EAAAmT,EACAqG,EAAAC,EAAAtG,EACAzF,EAAAlN,KAAAyE,KAAAvF,IAAA8Z,KACA9Z,GAAAgO,EACA8L,GAAA9L,EAEArM,EAAAH,EAAA,EAA+B4X,EAAAzX,EAAQA,IACvCoY,EAAAxB,EAAA/W,EAAA,GAAAG,GACA4W,EAAA/W,EAAA,GAAAG,GAAAmY,EAAAC,EAAA/Z,EAAAuY,EAAA/W,GAAAG,GACA4W,EAAA/W,GAAAG,GAAAmY,EAAAvB,EAAA/W,GAAAG,GAAA3B,EAAA+Z,CAGA,KAAArY,EAAA,EAA2BF,GAAAE,EAAQA,IACnCqY,EAAAxB,EAAA7W,GAAAF,EAAA,GACA+W,EAAA7W,GAAAF,EAAA,GAAAsY,EAAAC,EAAA/Z,EAAAuY,EAAA7W,GAAAF,GACA+W,EAAA7W,GAAAF,GAAAsY,EAAAvB,EAAA7W,GAAAF,GAAAxB,EAAA+Z,CAGA,KAAArY,EAAAwX,EAA6BC,GAAAzX,EAAWA,IACxCqY,EAAAtD,EAAA/U,GAAAF,EAAA,GACAiV,EAAA/U,GAAAF,EAAA,GAAAsY,EAAAC,EAAA/Z,EAAAyW,EAAA/U,GAAAF,GACAiV,EAAA/U,GAAAF,GAAAsY,EAAArD,EAAA/U,GAAAF,GAAAxB,EAAA+Z,MAGA3B,GAAA5W,EAAA,GAAAlB,EAAAN,EACAoY,EAAA5W,GAAAlB,EAAAN,EACA0W,EAAAlV,EAAA,GAAAuY,EACArD,EAAAlV,IAAAuY,CAGAvY,IAAA,EACAwV,EAAA,MACS,CAST,GARA1W,EAAAiY,EAAA/W,MACAjB,EAAA,EACA8Y,EAAA,EACA7X,EAAA4L,IACA7M,EAAAgY,EAAA/W,EAAA,GAAAA,EAAA,GACA6X,EAAAd,EAAA/W,KAAA,GAAA+W,EAAA/W,EAAA,GAAAA,IAGA,KAAAwV,EAAA,CAEA,IADA4C,GAAAtZ,EACAoB,EAAAwX,EAA6B1X,GAAAE,EAAQA,IACrC6W,EAAA7W,OAAApB,CAEAmT,GAAA3S,KAAAG,IAAAsX,EAAA/W,KAAA,IAAAV,KAAAG,IAAAsX,EAAA/W,EAAA,GAAAA,EAAA,IACAlB,EAAAC,EAAA,IAAAkT,EACA4F,GAAA,MAAA5F,IAGA,QAAAuD,IACAvD,GAAAlT,EAAAD,GAAA,EACAmT,MAAA4F,EACA5F,EAAA,IAMA,IALAA,EAAA3S,KAAAyE,KAAAkO,GACAnT,EAAAC,IACAkT,MAEAA,EAAAnT,EAAA+Y,IAAA9Y,EAAAD,GAAA,EAAAmT,GACA/R,EAAAwX,EAAiC1X,GAAAE,EAAQA,IACzC6W,EAAA7W,OAAA+R,CAEAmG,IAAAnG,EACAnT,EAAAC,EAAA8Y,EAAA,KAOA,IAHArC,GAAA,EAEAlX,EAAA0B,EAAA,EACA1B,GAAAsN,IACA2M,EAAAxB,EAAAzY,MACAkO,EAAA1N,EAAAyZ,EACAtG,EAAAlT,EAAAwZ,EACA/Z,GAAAgO,EAAAyF,EAAA4F,GAAAd,EAAAzY,EAAA,GAAAA,GAAAyY,EAAAzY,KAAA,GACAga,EAAAvB,EAAAzY,EAAA,GAAAA,EAAA,GAAAia,EAAA/L,EAAAyF,EACAzF,EAAAuK,EAAAzY,EAAA,GAAAA,EAAA,GACA2T,EAAA3S,KAAAG,IAAAjB,GAAAc,KAAAG,IAAA6Y,GAAAhZ,KAAAG,IAAA+M,GACAhO,GAAAyT,EACAqG,GAAArG,EACAzF,GAAAyF,EACA3T,IAAAsN,MAGAtM,KAAAG,IAAAsX,EAAAzY,KAAA,KAAAgB,KAAAG,IAAA6Y,GAAAhZ,KAAAG,IAAA+M,IAAAvG,GAAA3G,KAAAG,IAAAjB,IAAAc,KAAAG,IAAAsX,EAAAzY,EAAA,GAAAA,EAAA,IAAAgB,KAAAG,IAAA8Y,GAAAjZ,KAAAG,IAAAsX,EAAAzY,EAAA,GAAAA,EAAA,QAGAA,GAGA,KAAA4B,EAAA5B,EAAA,EAA2B0B,GAAAE,EAAQA,IACnC6W,EAAA7W,KAAA,KACAA,EAAA5B,EAAA,IACAyY,EAAA7W,KAAA,KAIA,KAAAqF,EAAAjH,EAAuB0B,EAAA,GAAAuF,IACvB2S,EAAA3S,IAAAvF,EAAA,EACAuF,IAAAjH,IACAE,EAAAuY,EAAAxR,KAAA,GACA+S,EAAAvB,EAAAxR,EAAA,GAAAA,EAAA,GACAiH,EAAA0L,EAAAnB,EAAAxR,EAAA,GAAAA,EAAA,KACAzG,EAAAQ,KAAAG,IAAAjB,GAAAc,KAAAG,IAAA6Y,GAAAhZ,KAAAG,IAAA+M,GACA,IAAA1N,IACAN,GAAAM,EACAwZ,GAAAxZ,EACA0N,GAAA1N,IAIA,IAAAA,GAdmCyG,IAuBnC,GALA0M,EAAA3S,KAAAyE,KAAAvF,IAAA8Z,IAAA9L,KACA,EAAAhO,IACAyT,MAGA,IAAAA,EAAA,CAcA,IAbA1M,IAAAjH,EACAyY,EAAAxR,KAAA,IAAA0M,EAAAnT,EACqB8M,IAAAtN,IACrByY,EAAAxR,KAAA,IAAAwR,EAAAxR,KAAA,IAGA/G,GAAAyT,EACAnT,EAAAN,EAAAyT,EACAlT,EAAAuZ,EAAArG,EACAsG,EAAA/L,EAAAyF,EACAqG,GAAA9Z,EACAgO,GAAAhO,EAEA2B,EAAAoF,EAA+BqS,EAAAzX,EAAQA,IACvC3B,EAAAuY,EAAAxR,GAAApF,GAAAmY,EAAAvB,EAAAxR,EAAA,GAAApF,GACA+X,IACA1Z,GAAAgO,EAAAuK,EAAAxR,EAAA,GAAApF,GACA4W,EAAAxR,EAAA,GAAApF,GAAA4W,EAAAxR,EAAA,GAAApF,GAAA3B,EAAA+Z,GAGAxB,EAAAxR,GAAApF,GAAA4W,EAAAxR,GAAApF,GAAA3B,EAAAM,EACAiY,EAAAxR,EAAA,GAAApF,GAAA4W,EAAAxR,EAAA,GAAApF,GAAA3B,EAAAO,CAGA,KAAAmB,EAAA,EAA+BA,GAAAZ,KAAAqJ,IAAA3I,EAAAuF,EAAA,GAAyBrF,IACxD1B,EAAAM,EAAAiY,EAAA7W,GAAAqF,GAAAxG,EAAAgY,EAAA7W,GAAAqF,EAAA,GACA2S,IACA1Z,GAAA+Z,EAAAxB,EAAA7W,GAAAqF,EAAA,GACAwR,EAAA7W,GAAAqF,EAAA,GAAAwR,EAAA7W,GAAAqF,EAAA,GAAA/G,EAAAgO,GAGAuK,EAAA7W,GAAAqF,GAAAwR,EAAA7W,GAAAqF,GAAA/G,EACAuY,EAAA7W,GAAAqF,EAAA,GAAAwR,EAAA7W,GAAAqF,EAAA,GAAA/G,EAAA8Z,CAGA,KAAApY,EAAAwX,EAAiCC,GAAAzX,EAAWA,IAC5C1B,EAAAM,EAAAmW,EAAA/U,GAAAqF,GAAAxG,EAAAkW,EAAA/U,GAAAqF,EAAA,GACA2S,IACA1Z,GAAA+Z,EAAAtD,EAAA/U,GAAAqF,EAAA,GACA0P,EAAA/U,GAAAqF,EAAA,GAAA0P,EAAA/U,GAAAqF,EAAA,GAAA/G,EAAAgO,GAGAyI,EAAA/U,GAAAqF,GAAA0P,EAAA/U,GAAAqF,GAAA/G,EACAyW,EAAA/U,GAAAqF,EAAA,GAAA0P,EAAA/U,GAAAqF,EAAA,GAAA/G,EAAA8Z,IAOA,OAAAD,EAAA,CAIA,IAAArY,EAAA4X,EAAA,EAAoB5X,GAAA,EAAQA,IAI5B,GAHAxB,EAAAoY,EAAA5W,GACAsY,EAAApD,EAAAlV,GAEA,IAAAsY,EAGA,IAFA1M,EAAA5L,EACA+W,EAAA/W,MAAA,EACAE,EAAAF,EAAA,EAA2BE,GAAA,EAAQA,IAAA,CAGnC,IAFA2X,EAAAd,EAAA7W,MAAA1B,EACAgO,EAAA,EACArM,EAAAyL,EAA2B5L,GAAAG,EAAQA,IACnCqM,GAAAuK,EAAA7W,GAAAC,GAAA4W,EAAA5W,GAAAH,EAGA,IAAAkV,EAAAhV,GAAA,EACAqY,EAAAV,EACA5F,EAAAzF,MAeA,IAbAZ,EAAA1L,EACA,IAAAgV,EAAAhV,GACA6W,EAAA7W,GAAAF,GAAA,IAAA6X,GAAArL,EAAAqL,GAAArL,GAAAvG,EAAAoS,IAEAvZ,EAAAiY,EAAA7W,KAAA,GACAnB,EAAAgY,EAAA7W,EAAA,GAAAA,GACAoY,GAAA1B,EAAA1W,GAAA1B,IAAAoY,EAAA1W,GAAA1B,GAAA0W,EAAAhV,GAAAgV,EAAAhV,GACAyC,GAAA7D,EAAAmT,EAAAsG,EAAA/L,GAAA8L,EACAvB,EAAA7W,GAAAF,GAAA2C,EACAoU,EAAA7W,EAAA,GAAAF,GAAAV,KAAAG,IAAAX,GAAAQ,KAAAG,IAAA8Y,KAAA/L,EAAAqL,EAAAlV,GAAA7D,IAAAmT,EAAAlT,EAAA4D,GAAA4V,GAGA5V,EAAArD,KAAAG,IAAAsX,EAAA7W,GAAAF,IACAiG,EAAAtD,IAAA,EACA,IAAAxC,EAAAD,EAAmCF,GAAAG,EAAQA,IAC3C4W,EAAA5W,GAAAH,GAAA+W,EAAA5W,GAAAH,GAAA2C,MAKS,MAAA2V,EAcT,IAbA1M,EAAA5L,EAAA,EAEAV,KAAAG,IAAAsX,EAAA/W,KAAA,IAAAV,KAAAG,IAAAsX,EAAA/W,EAAA,GAAAA,KACA+W,EAAA/W,EAAA,GAAAA,EAAA,GAAAsY,EAAAvB,EAAA/W,KAAA,GACA+W,EAAA/W,EAAA,GAAAA,KAAA+W,EAAA/W,MAAAxB,GAAAuY,EAAA/W,KAAA,KAEAmY,EAAAK,EAAA,GAAAzB,EAAA/W,EAAA,GAAAA,GAAA+W,EAAA/W,EAAA,GAAAA,EAAA,GAAAxB,EAAA8Z,GACAvB,EAAA/W,EAAA,GAAAA,EAAA,GAAAmY,EAAA,GACApB,EAAA/W,EAAA,GAAAA,GAAAmY,EAAA,IAGApB,EAAA/W,KAAA,KACA+W,EAAA/W,MAAA,EACAE,EAAAF,EAAA,EAA2BE,GAAA,EAAQA,IAAA,CAGnC,IAFA4X,EAAA,EACAC,EAAA,EACA5X,EAAAyL,EAA2B5L,GAAAG,EAAQA,IACnC2X,GAAAf,EAAA7W,GAAAC,GAAA4W,EAAA5W,GAAAH,EAAA,GACA+X,GAAAhB,EAAA7W,GAAAC,GAAA4W,EAAA5W,GAAAH,EAKA,IAFA6X,EAAAd,EAAA7W,MAAA1B,EAEA0W,EAAAhV,GAAA,EACAqY,EAAAV,EACArL,EAAAsL,EACA7F,EAAA8F,MA6BA,IA3BAnM,EAAA1L,EACA,IAAAgV,EAAAhV,IACAiY,EAAAK,GAAAV,GAAAC,EAAAF,EAAAS,GACAvB,EAAA7W,GAAAF,EAAA,GAAAmY,EAAA,GACApB,EAAA7W,GAAAF,GAAAmY,EAAA,KAEArZ,EAAAiY,EAAA7W,KAAA,GACAnB,EAAAgY,EAAA7W,EAAA,GAAAA,GACA8X,GAAApB,EAAA1W,GAAA1B,IAAAoY,EAAA1W,GAAA1B,GAAA0W,EAAAhV,GAAAgV,EAAAhV,GAAAoY,IACAL,EAAA,GAAArB,EAAA1W,GAAA1B,GAAA8Z,EACA,IAAAN,GAAA,IAAAC,IACAD,EAAA/R,EAAAoS,GAAA/Y,KAAAG,IAAAoY,GAAAvY,KAAAG,IAAA6Y,GAAAhZ,KAAAG,IAAAX,GAAAQ,KAAAG,IAAAV,GAAAO,KAAAG,IAAA8Y,KAEAJ,EAAAK,EAAA1Z,EAAA0N,EAAA+L,EAAAT,EAAAQ,EAAAP,EAAAjZ,EAAAmT,EAAAsG,EAAAR,EAAAO,EAAAR,EAAAE,EAAAC,GACAlB,EAAA7W,GAAAF,EAAA,GAAAmY,EAAA,GACApB,EAAA7W,GAAAF,GAAAmY,EAAA,GACA7Y,KAAAG,IAAAX,GAAAQ,KAAAG,IAAA8Y,GAAAjZ,KAAAG,IAAA6Y,IACAvB,EAAA7W,EAAA,GAAAF,EAAA,KAAA8X,EAAAD,EAAAd,EAAA7W,GAAAF,EAAA,GAAAsY,EAAAvB,EAAA7W,GAAAF,IAAAlB,EACAiY,EAAA7W,EAAA,GAAAF,KAAA+X,EAAAF,EAAAd,EAAA7W,GAAAF,GAAAsY,EAAAvB,EAAA7W,GAAAF,EAAA,IAAAlB,IAEAqZ,EAAAK,GAAAhM,EAAAzN,EAAAgY,EAAA7W,GAAAF,EAAA,IAAAiS,EAAAlT,EAAAgY,EAAA7W,GAAAF,GAAAuY,EAAAD,GACAvB,EAAA7W,EAAA,GAAAF,EAAA,GAAAmY,EAAA,GACApB,EAAA7W,EAAA,GAAAF,GAAAmY,EAAA,KAIAxV,EAAArD,KAAAuC,IAAAvC,KAAAG,IAAAsX,EAAA7W,GAAAF,EAAA,IAAAV,KAAAG,IAAAsX,EAAA7W,GAAAF,KACAiG,EAAAtD,IAAA,EACA,IAAAxC,EAAAD,EAAmCF,GAAAG,EAAQA,IAC3C4W,EAAA5W,GAAAH,EAAA,GAAA+W,EAAA5W,GAAAH,EAAA,GAAA2C,EACAoU,EAAA5W,GAAAH,GAAA+W,EAAA5W,GAAAH,GAAA2C,EAQA,IAAAzC,EAAA,EAAe0X,EAAA1X,EAAQA,IACvB,GAAAwX,EAAAxX,KAAAyX,EACA,IAAAxX,EAAAD,EAAuB0X,EAAAzX,EAAQA,IAC/B8U,EAAA/U,GAAAC,GAAA4W,EAAA7W,GAAAC,EAKA,KAAAA,EAAAyX,EAAA,EAAoBzX,GAAAuX,EAAUvX,IAC9B,IAAAD,EAAAwX,EAAqBC,GAAAzX,EAAWA,IAAA,CAEhC,IADAqY,EAAA,EACAhT,EAAAmS,EAAyBnS,GAAAjG,KAAAqJ,IAAAxI,EAAAwX,GAAwBpS,IACjDgT,GAAAtD,EAAA/U,GAAAqF,GAAAwR,EAAAxR,GAAApF,EAEA8U,GAAA/U,GAAAC,GAAAoY,IAKA,QAAAC,GAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAApM,GAAAoK,CACA,OAAAtX,MAAAG,IAAAkZ,GAAArZ,KAAAG,IAAAmZ,IACApM,EAAAoM,EAAAD,EACA/B,EAAA+B,EAAAnM,EAAAoM,IACAH,EAAAjM,EAAAkM,GAAA9B,GAAA8B,EAAAlM,EAAAiM,GAAA7B,KAGApK,EAAAmM,EAAAC,EACAhC,EAAAgC,EAAApM,EAAAmM,IACAnM,EAAAiM,EAAAC,GAAA9B,GAAApK,EAAAkM,EAAAD,GAAA7B,IAvvBA,GAAA7T,GAAA/E,EAAA,GACAsX,EAAAtX,EAAA,GAAAsX,UA8CAjC,GAAApI,WACA4N,sBACA,MAAA/a,MAAA8Y,GAEAkC,2BACA,MAAAhb,MAAAoX,GAEA6D,wBACA,MAAAjb,MAAAmX,GAEAe,qBACA,GAIA9V,GAAAC,EAJAH,EAAAlC,KAAAkC,EACAkV,EAAApX,KAAAoX,EACA0B,EAAA9Y,KAAA8Y,EACAhE,EAAA,GAAA7P,GAAA/C,IAEA,KAAAE,EAAA,EAAmBF,EAAAE,EAAOA,IAAA,CAC1B,IAAAC,EAAA,EAAuBH,EAAAG,EAAOA,IAC9ByS,EAAA1S,GAAAC,GAAA,CAEAyS,GAAA1S,MAAA0W,EAAA1W,GACAgV,EAAAhV,GAAA,EACA0S,EAAA1S,KAAA,GAAAgV,EAAAhV,GAEAgV,EAAAhV,GAAA,IACA0S,EAAA1S,KAAA,GAAAgV,EAAAhV,IAGA,MAAA0S,KAgrBAjV,EAAAD,QAAA2V,GZu0GM,SAAS1V,EAAQD,EAASM,GapkIhC,YAKA,SAAAkV,GAAA1I,GACA,KAAA1M,eAAAoV,IACA,UAAAA,GAAA1I,EAEAA,GAAAzH,EAAA8J,YAAArC,EAEA,IAKAtK,GAAAC,EAAAoF,EAAA/G,EAAAyT,EAAAtP,EAAA8N,EACAuI,EAAAC,EAAAC,EANAC,EAAA3O,EAAAhB,QACA1G,EAAAqW,EAAArW,KACAK,EAAAgW,EAAAhW,QACAiW,EAAA,GAAA9T,OAAAxC,GACAuW,EAAA,CAIA,KAAAnZ,EAAA,EAAe4C,EAAA5C,EAAUA,IACzBkZ,EAAAlZ,IAKA,KAFA+Y,EAAA,GAAA3T,OAAAxC,GAEA3C,EAAA,EAAegD,EAAAhD,EAAaA,IAAA,CAE5B,IAAAD,EAAA,EAAmB4C,EAAA5C,EAAUA,IAC7B+Y,EAAA/Y,GAAAiZ,EAAAjZ,GAAAC,EAGA,KAAAD,EAAA,EAAmB4C,EAAA5C,EAAUA,IAAA,CAI7B,IAHA8Y,EAAAG,EAAAjZ,GACAgZ,EAAA5Z,KAAAqJ,IAAAzI,EAAAC,GACA8R,EAAA,EACA1M,EAAA,EAAuB2T,EAAA3T,EAAUA,IACjC0M,GAAA+G,EAAAzT,GAAA0T,EAAA1T,EAEAyT,GAAA7Y,GAAA8Y,EAAA/Y,IAAA+R,EAIA,IADAzT,EAAA2B,EACAD,EAAAC,EAAA,EAAuB2C,EAAA5C,EAAUA,IACjCZ,KAAAG,IAAAwZ,EAAA/Y,IAAAZ,KAAAG,IAAAwZ,EAAAza,MACAA,EAAA0B,EAIA,IAAA1B,IAAA2B,EAAA,CACA,IAAAoF,EAAA,EAAuBpC,EAAAoC,EAAaA,IACpC5C,EAAAwW,EAAA3a,GAAA+G,GACA4T,EAAA3a,GAAA+G,GAAA4T,EAAAhZ,GAAAoF,GACA4T,EAAAhZ,GAAAoF,GAAA5C,CAGA8N,GAAA2I,EAAA5a,GACA4a,EAAA5a,GAAA4a,EAAAjZ,GACAiZ,EAAAjZ,GAAAsQ,EAEA4I,KAGA,GAAAvW,EAAA3C,GAAA,IAAAgZ,EAAAhZ,MACA,IAAAD,EAAAC,EAAA,EAA2B2C,EAAA5C,EAAUA,IACrCiZ,EAAAjZ,GAAAC,IAAAgZ,EAAAhZ,MAKArC,KAAA2V,GAAA0F,EACArb,KAAAsb,cACAtb,KAAAub,YArEA,GAAAtW,GAAA/E,EAAA,EAwEAkV,GAAAjI,WACAqO,WAAA,WAGA,OAFA7N,GAAA3N,KAAA2V,GACA8F,EAAA9N,EAAAtI,QACAhD,EAAA,EAAuBoZ,EAAApZ,EAASA,IAChC,OAAAsL,EAAAtL,MACA,QAGA,WAEAqZ,kBACA,GAAA/N,GAAA3N,KAAA2V,EACA,KAAAhI,EAAAkC,WACA,SAAAgJ,OAAA,wBAEA,QADA6C,GAAA1b,KAAAub,UAAAE,EAAA9N,EAAAtI,QACAhD,EAAA,EAAuBoZ,EAAApZ,EAASA,IAChCqZ,GAAA/N,EAAAtL,KACA,OAAAqZ,IAEAC,4BAKA,OAJAhO,GAAA3N,KAAA2V,GACA3Q,EAAA2I,EAAA3I,KACAK,EAAAsI,EAAAtI,QACAyP,EAAA,GAAA7P,GAAAD,EAAAK,GACAjD,EAAA,EAAuB4C,EAAA5C,EAAUA,IACjC,OAAAC,GAAA,EAA2BgD,EAAAhD,EAAaA,IACxCD,EAAAC,EACAyS,EAAA1S,GAAAC,GAAAsL,EAAAvL,GAAAC,GACiBD,IAAAC,EACjByS,EAAA1S,GAAAC,GAAA,EAEAyS,EAAA1S,GAAAC,GAAA,CAIA,OAAAyS,IAEA8G,4BAKA,OAJAjO,GAAA3N,KAAA2V,GACA3Q,EAAA2I,EAAA3I,KACAK,EAAAsI,EAAAtI,QACAyP,EAAA,GAAA7P,GAAAD,EAAAK,GACAjD,EAAA,EAAuB4C,EAAA5C,EAAUA,IACjC,OAAAC,GAAA,EAA2BgD,EAAAhD,EAAaA,IACxCA,GAAAD,EACA0S,EAAA1S,GAAAC,GAAAsL,EAAAvL,GAAAC,GAEAyS,EAAA1S,GAAAC,GAAA,CAIA,OAAAyS,IAEA+G,6BACA,MAAA7b,MAAAsb,YAAAjP,SAEA7B,MAAA,SAAAyC,GACAA,EAAAhI,EAAA8J,YAAA9B,EAEA,IAAAoO,GAAArb,KAAA2V,GACA3Q,EAAAqW,EAAArW,IAEA,IAAAA,IAAAiI,EAAAjI,KACA,SAAA6T,OAAA,4BACA,IAAA7Y,KAAAwb,aACA,SAAA3C,OAAA,wBAEA,IAGAzW,GAAAC,EAAAoF,EAHAxD,EAAAgJ,EAAA5H,QACAyP,EAAA7H,EAAA4H,aAAA7U,KAAAsb,YAAA,EAAArX,EAAA,GACAoB,EAAAgW,EAAAhW,OAGA,KAAAoC,EAAA,EAAmBpC,EAAAoC,EAAaA,IAChC,IAAArF,EAAAqF,EAAA,EAA2BpC,EAAAjD,EAAaA,IACxC,IAAAC,EAAA,EAA2B4B,EAAA5B,EAAWA,IACtCyS,EAAA1S,GAAAC,IAAAyS,EAAArN,GAAApF,GAAAgZ,EAAAjZ,GAAAqF,EAIA,KAAAA,EAAApC,EAAA,EAA6BoC,GAAA,EAAQA,IAAA,CACrC,IAAApF,EAAA,EAAuB4B,EAAA5B,EAAWA,IAClCyS,EAAArN,GAAApF,IAAAgZ,EAAA5T,KAEA,KAAArF,EAAA,EAAuBqF,EAAArF,EAAOA,IAC9B,IAAAC,EAAA,EAA2B4B,EAAA5B,EAAWA,IACtCyS,EAAA1S,GAAAC,IAAAyS,EAAArN,GAAApF,GAAAgZ,EAAAjZ,GAAAqF,GAIA,MAAAqN,KAIAjV,EAAAD,QAAAwV,Gb2kIM,SAASvV,EAAQD,EAASM,GcnvIhC,YAMA,SAAAmV,GAAApI,GACA,KAAAjN,eAAAqV,IACA,UAAAA,GAAApI,EAEAA,GAAAhI,EAAA8J,YAAA9B,EAEA,IAIA7K,GAAAC,EAAAoF,EAAA0M,EAJA2H,EAAA7O,EAAAvB,QACAlL,EAAAyM,EAAAjI,KACA9C,EAAA+K,EAAA5H,QACA0W,EAAA,GAAAvU,OAAAtF,EAGA,KAAAuF,EAAA,EAAevF,EAAAuF,EAAOA,IAAA,CACtB,GAAAuU,GAAA,CACA,KAAA5Z,EAAAqF,EAAmBjH,EAAA4B,EAAOA,IAC1B4Z,EAAAxE,EAAAwE,EAAAF,EAAA1Z,GAAAqF,GAEA,QAAAuU,EAAA,CAIA,IAHAF,EAAArU,MAAA,IACAuU,MAEA5Z,EAAAqF,EAAuBjH,EAAA4B,EAAOA,IAC9B0Z,EAAA1Z,GAAAqF,IAAAuU,CAGA,KADAF,EAAArU,OAAA,EACApF,EAAAoF,EAAA,EAA2BvF,EAAAG,EAAOA,IAAA,CAElC,IADA8R,EAAA,EACA/R,EAAAqF,EAA2BjH,EAAA4B,EAAOA,IAClC+R,GAAA2H,EAAA1Z,GAAAqF,GAAAqU,EAAA1Z,GAAAC,EAGA,KADA8R,KAAA2H,EAAArU,MACArF,EAAAqF,EAA2BjH,EAAA4B,EAAOA,IAClC0Z,EAAA1Z,GAAAC,IAAA8R,EAAA2H,EAAA1Z,GAAAqF,IAIAsU,EAAAtU,IAAAuU,EAGAhc,KAAA4V,GAAAkG,EACA9b,KAAAic,MAAAF,EA5CA,GAAA9W,GAAA/E,EAAA,GACAsX,EAAAtX,EAAA,GAAAsX,UA8CAnC,GAAAlI,WACA3C,MAAA,SAAAyC,GACAA,EAAAhI,EAAA8J,YAAA9B,EAEA,IAAA6O,GAAA9b,KAAA4V,GACApV,EAAAsb,EAAA9W,IAEA,IAAAiI,EAAAjI,OAAAxE,EACA,SAAAqY,OAAA,mCACA,KAAA7Y,KAAAkc,aACA,SAAArD,OAAA,2BAEA,IAGAzW,GAAAC,EAAAoF,EAAA0M,EAHAlQ,EAAAgJ,EAAA5H,QACAyP,EAAA7H,EAAAvB,QACAxJ,EAAA4Z,EAAAzW,OAGA,KAAAoC,EAAA,EAAmBvF,EAAAuF,EAAOA,IAC1B,IAAApF,EAAA,EAAuB4B,EAAA5B,EAAWA,IAAA,CAElC,IADA8R,EAAA,EACA/R,EAAAqF,EAA2BjH,EAAA4B,EAAOA,IAClC+R,GAAA2H,EAAA1Z,GAAAqF,GAAAqN,EAAA1S,GAAAC,EAGA,KADA8R,KAAA2H,EAAArU,MACArF,EAAAqF,EAA2BjH,EAAA4B,EAAOA,IAClC0S,EAAA1S,GAAAC,IAAA8R,EAAA2H,EAAA1Z,GAAAqF,GAIA,IAAAA,EAAAvF,EAAA,EAAuBuF,GAAA,EAAQA,IAAA,CAC/B,IAAApF,EAAA,EAAuB4B,EAAA5B,EAAWA,IAClCyS,EAAArN,GAAApF,IAAArC,KAAAic,MAAAxU,EAEA,KAAArF,EAAA,EAAuBqF,EAAArF,EAAOA,IAC9B,IAAAC,EAAA,EAA2B4B,EAAA5B,EAAWA,IACtCyS,EAAA1S,GAAAC,IAAAyS,EAAArN,GAAApF,GAAAyZ,EAAA1Z,GAAAqF,GAKA,MAAAqN,GAAAP,UAAA,EAAArS,EAAA,IAAA+B,EAAA,IAEAiY,WAAA,WAEA,OADA7W,GAAArF,KAAA4V,GAAAvQ,QACAjD,EAAA,EAAuBiD,EAAAjD,EAAaA,IACpC,OAAApC,KAAAic,MAAA7Z,GACA,QAGA,WAEAwZ,4BACA,GAGAxZ,GAAAC,EAHAyZ,EAAA9b,KAAA4V,GACA1T,EAAA4Z,EAAAzW,QACAyP,EAAA,GAAA7P,GAAA/C,IAEA,KAAAE,EAAA,EAAmBF,EAAAE,EAAOA,IAC1B,IAAAC,EAAA,EAAuBH,EAAAG,EAAOA,IAC9BA,EAAAD,EACA0S,EAAA1S,GAAAC,GAAAyZ,EAAA1Z,GAAAC,GACiBD,IAAAC,EACjByS,EAAA1S,GAAAC,GAAArC,KAAAic,MAAA7Z,GAEA0S,EAAA1S,GAAAC,GAAA,CAIA,OAAAyS,IAEAqH,uBACA,GAIA/Z,GAAAC,EAAAoF,EAAA0M,EAJA2H,EAAA9b,KAAA4V,GACA5Q,EAAA8W,EAAA9W,KACAK,EAAAyW,EAAAzW,QACAyP,EAAA,GAAA7P,GAAAD,EAAAK,EAGA,KAAAoC,EAAApC,EAAA,EAA6BoC,GAAA,EAAQA,IAAA,CACrC,IAAArF,EAAA,EAAuB4C,EAAA5C,EAAUA,IACjC0S,EAAA1S,GAAAqF,GAAA,CAGA,KADAqN,EAAArN,MAAA,EACApF,EAAAoF,EAAuBpC,EAAAhD,EAAaA,IACpC,OAAAyZ,EAAArU,MAAA,CAEA,IADA0M,EAAA,EACA/R,EAAAqF,EAA+BzC,EAAA5C,EAAUA,IACzC+R,GAAA2H,EAAA1Z,GAAAqF,GAAAqN,EAAA1S,GAAAC,EAKA,KAFA8R,KAAA2H,EAAArU,MAEArF,EAAAqF,EAA+BzC,EAAA5C,EAAUA,IACzC0S,EAAA1S,GAAAC,IAAA8R,EAAA2H,EAAA1Z,GAAAqF,IAKA,MAAAqN,KAIAjV,EAAAD,QAAAyV,Gd0vIM,SAASxV,EAAQD,EAASM,Ge/4IhC,YAKA,SAAAsV,GAAAvI,GACA,KAAAjN,eAAAwV,IACA,UAAAA,GAAAvI,EAGA,IADAA,EAAAhI,EAAA8J,YAAA9B,IACAA,EAAA6C,cACA,SAAA+I,OAAA,0BAEA,IAIAzW,GAAAC,EAAAoF,EAJA/C,EAAAuI,EACAmP,EAAA1X,EAAAM,KACA8I,EAAA,GAAA7I,GAAAmX,KACAC,GAAA,CAGA,KAAAha,EAAA,EAAe+Z,EAAA/Z,EAAeA,IAAA,CAC9B,GAAAia,GAAAxO,EAAAzL,GACAyW,EAAA,CACA,KAAArR,EAAA,EAAmBpF,EAAAoF,EAAOA,IAAA,CAC1B,GAAA8U,GAAAzO,EAAArG,GACA0M,EAAA,CACA,KAAA/R,EAAA,EAAuBqF,EAAArF,EAAOA,IAC9B+R,GAAAoI,EAAAna,GAAAka,EAAAla,EAEAka,GAAA7U,GAAA0M,GAAAzP,EAAArC,GAAAoF,GAAA0M,GAAArG,EAAArG,MACAqR,GAAA3E,IAOA,IAJA2E,EAAApU,EAAArC,MAAAyW,EAEAuD,GAAAvD,EAAA,EACAhL,EAAAzL,MAAAb,KAAAyE,KAAAzE,KAAAuC,IAAA+U,EAAA,IACArR,EAAApF,EAAA,EAAuB+Z,EAAA3U,EAAeA,IACtCqG,EAAAzL,GAAAoF,GAAA,EAIA,IAAA4U,EACA,SAAAxD,OAAA,kCAGA7Y,MAAAwc,EAAA1O,EA3CA,GAAA7I,GAAA/E,EAAA,EA8CAsV,GAAArI,WACAsP,2BACA,MAAAzc,MAAAwc,GAEAhS,MAAA,SAAAyC,GACAA,EAAAhI,EAAA8J,YAAA9B,EAEA,IAAAa,GAAA9N,KAAAwc,EACAJ,EAAAtO,EAAA9I,IAEA,IAAAiI,EAAAjI,OAAAoX,EACA,SAAAvD,OAAA,iCAGA,IAEAzW,GAAAC,EAAAoF,EAFAxD,EAAAgJ,EAAA5H,QACAqX,EAAAzP,EAAAvB,OAGA,KAAAjE,EAAA,EAAmB2U,EAAA3U,EAAeA,IAClC,IAAApF,EAAA,EAAuB4B,EAAA5B,EAAWA,IAAA,CAClC,IAAAD,EAAA,EAA2BqF,EAAArF,EAAOA,IAClCsa,EAAAjV,GAAApF,IAAAqa,EAAAta,GAAAC,GAAAyL,EAAArG,GAAArF,EAEAsa,GAAAjV,GAAApF,IAAAyL,EAAArG,MAIA,IAAAA,EAAA2U,EAAA,EAA+B3U,GAAA,EAAQA,IACvC,IAAApF,EAAA,EAAuB4B,EAAA5B,EAAWA,IAAA,CAClC,IAAAD,EAAAqF,EAAA,EAA+B2U,EAAAha,EAAeA,IAC9Csa,EAAAjV,GAAApF,IAAAqa,EAAAta,GAAAC,GAAAyL,EAAA1L,GAAAqF,EAEAiV,GAAAjV,GAAApF,IAAAyL,EAAArG,MAIA,MAAAiV,KAIA7c,EAAAD,QAAA4V,Gfs5IM,SAAS3V,EAAQD,EAASM,GgBv+IhC,YAIA,SAAAwM,GAAAiQ,EAAAD,GACA,UAAAzX,GAAA0X,EAAAD,GAGA,QAAA7S,GAAA7E,EAAAD,GACA,MAAAE,GAAA4E,KAAA7E,EAAAD,GAGA,QAAA2F,GAAA1F,EAAAD,GACA,MAAAE,GAAAyF,IAAA1F,EAAAD,GAGA,QAAAG,GAAAF,EAAAD,GACA,MAAAE,GAAAC,MAAAF,EAAAD,GAGA,QAAAqJ,GAAApJ,EAAAD,GACA,MAAAE,GAAAiJ,KAAAlJ,EAAAD,GAGA,QAAA6C,GAAA+U,GACA,mBAAAA,GACA,MAAAA,EACA,IAAAna,GAAAma,EAAAjR,OACA,OAAAlJ,GAAAoF,YAGA,QAAA6C,GAAAkS,EAAAD,GACA,mBAAAC,IAAA,gBAAAD,GACA,MAAAC,GAAAD,CACA,oBAAAC,GACA,MAAA3c,MAAAyK,IAAAiS,EAAAC,EAEA,IAAAna,GAAAma,EAAAjR,OACA,OAAAlJ,GAAAiI,IAAAiS,GAIA,QAAA3R,GAAA4R,EAAAD,GACA,mBAAAC,IAAA,gBAAAD,GACA,MAAAC,GAAAD,CACA,oBAAAC,GACA,MAAA3c,MAAA+K,SAAA2R,EAAAC,EACA,IAAAna,GAAAma,EAAAjR,OACA,OAAAlJ,GAAA8N,IAAAoM,GAGA,QAAA3T,GAAA4T,EAAAD,GACA,mBAAAC,IAAA,gBAAAD,GACA,MAAAC,GAAAD,CACA,oBAAAC,GACA,MAAA3c,MAAA+I,SAAA2T,EAAAC,EAEA,IAAAna,GAAAma,EAAAjR,OAOA,OALA,gBAAAgR,GACAla,EAAAiO,IAAAiM,GAEAla,IAAAuR,KAAA2I,GAEA,GAAAla,EAAAwC,MAAA,GAAAxC,EAAA6C,QACA7C,EAAA,MAEAA,EAIA,QAAAsH,GAAA6S,EAAAD,GACA,GAAAla,GAAAma,EAAAjR,OACA,OAAAlJ,GAAAiO,IAAAiM,GAGA,QAAA5Q,GAAA6Q,EAAAD,GACA,GAAAla,GAAAma,EAAAjR,OACA,OAAAlJ,GAAAyJ,IAAAyQ,GAGA,QAAArS,GAAAsS,GACA,GACAta,GAAAqM,EADArE,EAAA,KACArF,EAAA2X,EAAA3X,KAAAD,EAAA4X,EAAAtX,OAEA,uBAAAN,IAAA,gBAAA4X,GACA,GAAAA,EAAA,IAAAA,EAAA,GAAAvb,OAKA,IAJA4D,EAAA2X,EAAAvb,OACA2D,EAAA4X,EAAA,GAAAvb,OACAsN,EAAAlN,KAAAqJ,IAAA7F,EAAAD,GACAsF,EAAApF,EAAAC,MAAAH,KACA1C,EAAA,EAAuB0C,EAAA1C,EAAUA,IACjCgI,EAAAhI,MAAAsa,EAAAta,UAMA,KAFA0C,EAAA4X,EAAAvb,OACAiJ,EAAApF,EAAAC,MAAAH,KACA1C,EAAA,EAAuB0C,EAAA1C,EAAUA,IACjCgI,EAAAhI,MAAAsa,EAAAta,EAKA,OAAA2C,EAEA,IADAqF,EAAApF,EAAAC,MAAAH,KACA1C,EAAA,EAAmB0C,EAAA1C,EAAUA,IAC7BgI,EAAAhI,MAAAsa,EAAA,GAAAta,OAIA,IAAA2C,EAAA,GAAAD,EAAA,EAGA,IAFA2J,EAAAlN,KAAAqJ,IAAA7F,EAAAD,GACAsF,EAAA,GAAA7C,OAAAkH,GACArM,EAAA,EAAuBqM,EAAArM,EAAOA,IAC9BgI,EAAAhI,GAAAsa,EAAAta,KAIA,OAAAgI,GAGA,QAAAQ,GAAA8R,EAAAD,GACA,mBAAAC,IAAA,gBAAAD,GACA,MAAAlb,MAAAqJ,IAAA8R,EAAAD,EAGA,QAFAnQ,GAAAoQ,EAAA3X,KAAAmJ,EAAAwO,EAAAtX,QACA7C,EAAA,GAAAyC,GAAAsH,EAAA4B,GACA/L,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/Bsa,EAAAva,GAAAC,GAAAqa,EAAAta,GAAAC,GACAG,EAAAJ,GAAAC,GAAAsa,EAAAva,GAAAC,GAGAG,EAAAJ,GAAAC,GAAAqa,EAAAta,GAAAC,EAIA,OAAAG,GAGA,QAAAuB,GAAA4Y,EAAAD,GACA,mBAAAC,IAAA,gBAAAD,GACA,MAAAlb,MAAAuC,IAAA4Y,EAAAD,EAGA,QAFAnQ,GAAAoQ,EAAA3X,KAAAmJ,EAAAwO,EAAAtX,QACA7C,EAAA,GAAAyC,GAAAsH,EAAA4B,GACA/L,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/Bsa,EAAAva,GAAAC,GAAAqa,EAAAta,GAAAC,GACAG,EAAAJ,GAAAC,GAAAsa,EAAAva,GAAAC,GAGAG,EAAAJ,GAAAC,GAAAqa,EAAAta,GAAAC,EAIA,OAAAG,GAGA,QAAAyD,GAAA0W,GACA,mBAAAA,GACA,MAAAnb,MAAAyE,KAAA0W,EAGA,QAFApQ,GAAAoQ,EAAA3X,KAAAmJ,EAAAwO,EAAAtX,QACA7C,EAAA,GAAAyC,GAAAsH,EAAA4B,GACA/L,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BG,EAAAJ,GAAAC,GAAAb,KAAAyE,KAAA0W,EAAAva,GAAAC,GAIA,OAAAG,GAGA,QAAAb,GAAAgb,GACA,mBAAAA,GACA,MAAAnb,MAAAG,IAAAgb,EAGA,QAFApQ,GAAAoQ,EAAA3X,KAAAmJ,EAAAwO,EAAAtX,QACA7C,EAAA,GAAAyC,GAAAsH,EAAA4B,GACA/L,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BG,EAAAJ,GAAAC,GAAAb,KAAAG,IAAAgb,EAAAva,GAAAC,GAIA,OAAAG,GAGA,QAAAgD,GAAAmX,GACA,mBAAAA,GACA,MAAAnb,MAAAyE,KAAA0W,EAGA,QAFApQ,GAAAoQ,EAAA3X,KAAAmJ,EAAAwO,EAAAtX,QACA7C,EAAA,GAAAyC,GAAAsH,EAAA4B,GACA/L,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BG,EAAAJ,GAAAC,GAAAb,KAAAgE,IAAAmX,EAAAva,GAAAC,GAGA,OAAAG,GAGA,QAAAoa,GAAAD,EAAAhY,GACA,mBAAAgY,GACA,MAAAnb,MAAA2D,IAAAwX,EAAAhY,EAIA,QAFA4H,GAAAoQ,EAAA3X,KAAAmJ,EAAAwO,EAAAtX,QACA7C,EAAA,GAAAyC,GAAAsH,EAAA4B,GACA/L,EAAA,EAAmBmK,EAAAnK,EAAQA,IAC3B,OAAAC,GAAA,EAAuB8L,EAAA9L,EAAQA,IAC/BG,EAAAJ,GAAAC,GAAAb,KAAA2D,IAAAwX,EAAAva,GAAAC,GAAAsC,EAGA,OAAAnC,GAGA,QAAAgI,GAAAmS,EAAAD,GACA,MAAAC,GAAAnS,MAAAkS,GAGA,QAAAvR,GAAAwR,GACA,sBAAAA,GACA,EAAAA,EACAA,EAAA1H,UA1NA,GAAAhQ,GAAA/E,EAAA,EA6NAL,GAAAD,SACAgI,YACA6C,MACAM,WACAhC,WACAe,cACAgC,YACAzB,OACAQ,MACA9G,MACAyG,QACAW,MACAlF,OACAT,MACAoX,SACAjb,MACA+K,SACA7C,OACA3E,QACAkJ,SACA1D,QhBs/IM,SAAS7K,EAAQD,EAASM,GiBruJhC,QAAAU,GAAAI,EAAAC,EAAA4C,GAEA,GAAAA,GAAAsC,OAAAC,OAAAvC,MACAgZ,UAAAhZ,EAAAiZ,cAAAjZ,EAAAiZ,YAAA,OACAD,SAAAhZ,EAAAkZ,aAAAlZ,EAAAkZ,WAAA,GACAF,SAAAhZ,EAAAmZ,aAAAnZ,EAAAmZ,WAAAH,QACAA,SAAAhZ,EAAAoZ,cAAApZ,EAAAoZ,YAAA,GACAJ,SAAAhZ,EAAAqZ,cAAArZ,EAAAqZ,aAAA,GACAL,SAAAhZ,EAAAsZ,UAAAtZ,EAAAsZ,SAAA,GACAN,SAAAhZ,EAAAuZ,mBAAAvZ,EAAAuZ,kBAAA,EAEA,IAAAC,GAAAC,KAA6BC,EAAA1Z,EAAAwZ,UAG7B,IAAAR,SAAAhZ,EAAAmZ,WAAA,CAGA,OADApT,GAAA4T,EAAA,EAAAC,EAAAtZ,OAAAC,UACAhC,EAAA,EAAoBA,EAAApB,EAAAI,OAAA,EAAcgB,IAAA,CAClC,GAAAwH,GAAApI,KAAAG,IAAAX,EAAAoB,EAAA,GAAApB,EAAAoB,GACAqb,GAAA7T,IACA6T,EAAA7T,GAEAA,EAAA4T,IACAA,EAAA5T,GAIA,KAAA4T,EAAAC,GAAAD,EAEA3Z,EAAAmZ,WAAAU,EAAAzc,GAIA4C,EAAAmZ,WAAA,EAIA/b,KAAAqM,OAAArM,EACA,IAAA0c,IAAuBnd,EAAA,EAAAmE,EAAAd,EAAAmZ,WACvBnZ,GAAAqZ,cACAS,EAAAnd,EAAA,GACAmd,EAAAhZ,GAAA,GAGA,QAAAvC,GAAA,EAAiBA,EAAAnB,EAAAG,OAAYgB,IAC7BnB,EAAAmB,GAAAub,EAAAnd,EAAAS,EAAAmB,GAAAub,EAAAhZ,CAGA,QAAAvC,GAAA,EAAiBA,EAAAnB,EAAAG,OAAYgB,IAC7BnB,EAAAmB,GAAA,IACAnB,EAAAmB,GAAA,EAKA,IAAA+V,GAAAlX,CACA,SAAAuc,EAAAC,GAAAD,EAAA,CACA3Z,EAAAsZ,UACAhF,EAAAyF,EAAA3c,EAAAD,EAAA,GAAAA,EAAA,IAAkC6c,WAAAR,EAAAQ,WAAAC,WAAAT,EAAAS,WAAAC,WAAA,IAClC,IAAAC,GAAAJ,EAAA3c,EAAAD,EAAA,GAAAA,EAAA,IAAmC6c,WAAAR,EAAAQ,WAAAC,WAAAT,EAAAS,WAAAC,WAAA,IACnCE,EAAAL,EAAA3c,EAAAD,EAAA,GAAAA,EAAA,IAAoC6c,WAAAR,EAAAQ,WAAAC,WAAAT,EAAAS,WAAAC,WAAA,QAEpC,CACAla,EAAAsZ,UACAhF,EAAAyF,EAAA3c,EAAAD,GAA0B6c,WAAAR,EAAAQ,WAAAC,WAAAT,EAAAS,WAAAC,WAAA,IAC1B,IAAAC,GAAAJ,EAAA3c,EAAAD,GAA2B6c,WAAAR,EAAAQ,WAAAC,WAAAT,EAAAS,WAAAC,WAAA,IAC3BE,EAAAL,EAAA3c,EAAAD,GAA4B6c,WAAAR,EAAAQ,WAAAC,WAAAT,EAAAS,WAAAC,WAAA,IAQ5B,OALAjJ,GAAA9T,EACAwF,EAAAxF,EAAA,GAAAA,EAAA,GACAkd,EAAA,EACAnY,EAAA,EAEA3D,EAAA,EAAmBA,EAAA+V,EAAA/W,OAAegB,IAClCZ,KAAAG,IAAAsc,EAAA7b,IAAA8b,IACAA,EAAA1c,KAAAG,IAAAsc,EAAA7b,KAEAZ,KAAAG,IAAAwW,EAAA/V,IAAA2D,IACAA,EAAAvE,KAAAG,IAAAwW,EAAA/V,IAaA,QARA+b,MACAC,KACAC,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,GAAAhX,OAGApF,EAAA,EAAmBA,EAAA+V,EAAA/W,OAAA,EAAkBgB,KAErC4b,EAAA5b,GAAA4b,EAAA5b,EAAA,IAAA4b,EAAA5b,IAAA4b,EAAA5b,EAAA,IACA4b,EAAA5b,IAAA4b,EAAA5b,EAAA,IAAA4b,EAAA5b,GAAA4b,EAAA5b,EAAA,MACAmc,EAAAzJ,EAAA1S,GAEAoE,EAAA,SAAA8X,IACAF,EAAArc,KAAAuc,GACAD,EAAAtc,KAAAwc,MAKAP,EAAA5b,IAAA4b,EAAA5b,EAAA,IAAA4b,EAAA5b,GAAA4b,EAAA5b,EAAA,IACA4b,EAAA5b,GAAA4b,EAAA5b,EAAA,IAAA4b,EAAA5b,IAAA4b,EAAA5b,EAAA,MACAkc,EAAAxJ,EAAA1S,GAEA,EAAAoE,GAAA,MAAA+X,IACAH,EAAArc,KAAAuc,GACAD,EAAAtc,KAAAwc,KAGAN,EAAA7b,GAAA6b,EAAA7b,EAAA,IAAA6b,EAAA7b,GAAA6b,EAAA7b,EAAA,KACA+b,EAAApc,KAAAK,GACAZ,KAAAG,IAAAsc,EAAA7b,IAAAyB,EAAAkZ,WAAAmB,EACAM,EAAAzc,MAAA,GAGAyc,EAAAzc,MAAA,GAQA,QADA0c,GAAAhX,EAAAiX,EAAAC,EAAAC,EAAAC,EADAC,KACAC,EAAA,EACA1c,EAAA,EAAmBA,EAAA8b,EAAA/c,OAAmBiB,IAAA,CAOtC,IANAqc,EAAA5J,EAAAqJ,EAAA9b,IACAoc,EAAA,GACAhX,EAAAsX,EAAA,EACAH,EAAAza,OAAAC,UACAua,EAAA,EACAE,GAAA,EACA,IAAAJ,GAAAhX,EAAA2W,EAAAhd,QAAAyd,GACAF,EAAAnd,KAAAG,IAAA+c,GAAAN,EAAA3W,GAAA4W,EAAA5W,IAAA,GAEAmX,EAAAD,EACAC,EAAAD,EAGAE,GAAA,EAEAF,EAAAnd,KAAAG,IAAAyc,EAAA3W,GAAA4W,EAAA5W,IAAA,IACAgX,EAAAhX,EACAsX,EAAAtX,GAEAA,GAGA,KAAAgX,GAEAjd,KAAAG,IAAAwW,EAAAgG,EAAA9b,KAAAwB,EAAAiZ,YAAA/W,GACA+Y,EAAA/c,MACAK,EAAA+b,EAAA9b,GACArB,EAAA0d,EACAzd,GAAAkX,EAAAgG,EAAA9b,IAAAsb,EAAAhZ,GAAAgZ,EAAAnd,EACAuC,MAAAvB,KAAAG,IAAA0c,EAAAI,GAAAL,EAAAK,IACAva,KAAAsa,EAAAnc,KAOAwB,EAAAuZ,kBACAA,EAAA0B,EAAAhK,EAAAqD,EAIA,QAAA9V,GAAA,EAAgBA,EAAAyc,EAAA1d,OAAiBiB,IACjCyc,EAAAzc,GAAAwM,KAAAhL,EAAAmZ,UAOA,OAJA8B,GAAAra,KAAA,SAAAC,EAAAC,GACA,MAAAD,GAAA1D,EAAA2D,EAAA3D,IAGA8d,EAIA,QAAApB,GAAAzc,GACA,GAAAuS,GAAA,EAAAwL,EAAA,EACA5d,EAAAH,EAAAG,OAAAgB,EAAA,CACA,KAAAA,EAAA,EAAchB,EAAAgB,EAAYA,IAC1BoR,GAAAvS,EAAAmB,EAEAoR,IAAApS,CACA,IAAA6d,GAAA,GAAAzX,OAAApG,EACA,KAAAgB,EAAA,EAAehB,EAAAgB,EAAYA,IAC3B6c,EAAA7c,GAAAZ,KAAAG,IAAAV,EAAAmB,GAAAoR,EAQA,OAPAyL,GAAAxa,OAEAua,EADA5d,EAAA,KACA6d,GAAA7d,EAAA,YAEA,IAAA6d,EAAA7d,EAAA,GAAA6d,EAAA7d,EAAA,YAMA,QAAAgc,GAAAnb,EAAAjB,EAAAC,GAMA,OADAiK,GAAAgU,EAAAC,EAAAze,EAAA0e,EACA/c,EAAA,EAAgBA,EAAAJ,EAAAb,OAAkBiB,IAAA,CAClC+c,EAAAnd,EAAAI,GAAAD,CAGAnB,GAAAme,EAAA,IAAAne,EAAAme,EAAA,IACAne,EAAAme,EAAA,IAAAne,EAAAme,GACAA,IAGAne,EAAAme,EAAA,IAAAne,EAAAme,IACAne,EAAAme,EAAA,IAAAne,EAAAme,EAAA,GACAA,IAGAne,EAAAme,EAAA,IAAAne,EAAAme,EAAA,IACAne,EAAAme,EAAA,IAAAne,EAAAme,EAAA,GACAA,GAAA,EAGAne,EAAAme,EAAA,IAAAne,EAAAme,EAAA,IACAne,EAAAme,EAAA,IAAAne,EAAAme,EAAA,KACAA,GAAA,GAKAne,EAAAme,EAAA,MAAAne,EAAAme,EAAA,MACAne,EAAAme,IAAAne,EAAAme,EAAA,IACAne,EAAAme,IAAAne,EAAAme,EAAA,KACAlU,EAAA,GAAA1J,KAAA6d,MAAApe,EAAAme,EAAA,IACAF,EAAA,GAAA1d,KAAA6d,MAAApe,EAAAme,IACAD,EAAA,GAAA3d,KAAA6d,MAAApe,EAAAme,EAAA,IACA1e,EAAA,IAAAwK,EAAAiU,IAAAjU,EAAA,EAAAgU,EAAAC,GAGAld,EAAAI,GAAArB,IAAAoe,IAAApe,EAAAoe,GAAApe,EAAAoe,EAAA,IAAA1e,EACAuB,EAAAI,GAAApB,IAAAme,GAAA,KAAAne,EAAAme,EAAA,GACAne,EAAAme,EAAA,IAAA1e,IAjQA,GAEA4c,IAFApd,EAAA,GACAA,EAAA,IACAA,EAAA,KACA0d,EAAA1d,EAAA,IAEAqd,GACAM,WAAA,EACAC,WAAA,EAgQAje,GAAAD,QAAAgB,GjBuvJM,SAASf,EAAQD,EAASM,GkB9/JhC,YAEAN,GAAAmR,MAAA7Q,EAAA,IACAN,EAAA8M,OAAAxM,EAAA,KlBqgKM,SAASL,EAAQD,GmBxgKvB,YAEA,SAAA0f,GAAA5a,EAAAC,GACA,MAAAD,GAAAC,EAQA/E,EAAA2T,IAAA,QAAAA,GAAAgM,GAEA,OADAhM,GAAA,EACAnR,EAAA,EAAmBA,EAAAmd,EAAAne,OAAmBgB,IACtCmR,GAAAgM,EAAAnd,EAEA,OAAAmR,IAQA3T,EAAAmE,IAAA,QAAAA,GAAAwb,GAGA,OAFAxb,KAAA6O,KACA9E,EAAAyR,EAAAne,OACAgB,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1Bmd,EAAAnd,GAAA2B,MAAAwb,EAAAnd,GAEA,OAAA2B,IAQAnE,EAAAiL,IAAA,QAAAA,GAAA0U,GAGA,OAFA1U,GAAA+H,IACA9E,EAAAyR,EAAAne,OACAgB,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1Bmd,EAAAnd,GAAAyI,MAAA0U,EAAAnd,GAEA,OAAAyI,IAQAjL,EAAA4f,OAAA,SAAAD,GAIA,OAHA1U,GAAA+H,IACA7O,IAAA6O,KACA9E,EAAAyR,EAAAne,OACAgB,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1Bmd,EAAAnd,GAAAyI,MAAA0U,EAAAnd,IACAmd,EAAAnd,GAAA2B,MAAAwb,EAAAnd,GAEA,QACAyI,MACA9G,QASAnE,EAAA6f,eAAA,SAAAF,GAGA,OAFAhM,GAAA,EACAzF,EAAAyR,EAAAne,OACAgB,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1BmR,GAAAgM,EAAAnd,EAEA,OAAAmR,GAAAzF,GAMAlO,EAAA4T,KAAA5T,EAAA6f,eAOA7f,EAAA8f,cAAA,SAAAH,GAGA,OAFA9O,GAAA,EACA3C,EAAAyR,EAAAne,OACAgB,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1BqO,GAAA8O,EAAAnd,EAEA,OAAAZ,MAAA2D,IAAAsL,EAAA,EAAA3C,IAUAlO,EAAA+f,QAAA,SAAAJ,GAGA,OAFAK,GAAA,EACA9R,EAAAyR,EAAAne,OACAgB,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1Bwd,GAAApe,KAAAoH,IAAA2W,EAAAnd,GAEA,OAAAwd,GAAA9R,GASAlO,EAAAigB,UAAA,SAAAC,EAAAC,GAIA,OAHAxM,GAAA,EACArR,EAAA,EACA4L,EAAAgS,EAAA1e,OACAgB,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1BmR,GAAAwM,EAAA3d,GAAA0d,EAAA1d,GACAF,GAAA6d,EAAA3d,EAEA,OAAAmR,GAAArR,GAUAtC,EAAAogB,cAAA,SAAAT,EAAAU,EAAAC,GACArD,SAAAqD,OAAA,GACAA,IACAX,IAAAlT,QAAA5H,KAAA6a,GAKA,QAHAxR,GAAAyR,EAAAne,OACAqG,EAAAjG,KAAA2e,MAAArS,EAAAmS,GACA1M,EAAA,EACAnR,EAAAqF,EAAmBqG,EAAArG,EAAArF,EAAaA,IAChCmR,GAAAgM,EAAAnd,EAEA,OAAAmR,IAAAzF,EAAA,EAAArG,IAQA7H,EAAAwgB,aAAA,SAAAb,GAGA,OAFAhM,GAAA,EACAzF,EAAAyR,EAAAne,OACAgB,EAAA,EAAmB0L,EAAA1L,EAAOA,IAAA,CAC1B,OAAAmd,EAAAnd,GACA,SAAA0K,YAAA,kBAAA1K,EAAA,UAEAmR,IAAA,EAAAgM,EAAAnd,GAEA,MAAA0L,GAAAyF,GAQA3T,EAAAygB,mBAAA,SAAAd,GAIA,OAHAe,GAAA,EACAC,EAAA,EACAzS,EAAAyR,EAAAne,OACAgB,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1Bke,GAAAf,EAAAnd,GAAAmd,EAAAnd,GACAme,GAAAhB,EAAAnd,EAEA,MAAAme,EACA,SAAAzT,YAAA,4BAEA,OAAAwT,GAAAC,GASA3gB,EAAA4gB,OAAA,SAAAjB,EAAAW,GACArD,SAAAqD,OAAA,GACAA,IACAX,IAAAlT,QAAA5H,KAAA6a,GAEA,IAAAxR,GAAAyR,EAAAne,OACAqf,EAAAjf,KAAA2e,MAAArS,EAAA,EACA,OAAAA,GAAA,MACA,IAAAyR,EAAAkB,EAAA,GAAAlB,EAAAkB,IAEAlB,EAAAkB,IAUA7gB,EAAA8gB,SAAA,SAAAnB,EAAAoB,GACA9D,SAAA8D,OAAA,EAKA,QAJAC,GAAAhhB,EAAA4T,KAAA+L,GACAsB,EAAA,EACA/S,EAAAyR,EAAAne,OAEAgB,EAAA,EAAmB0L,EAAA1L,EAAOA,IAAA,CAC1B,GAAApB,GAAAue,EAAAnd,GAAAwe,CACAC,IAAA7f,IAGA,MAAA2f,GACAE,GAAA/S,EAAA,GAEA+S,EAAA/S,GAUAlO,EAAAkhB,kBAAA,SAAAvB,EAAAoB,GACA,MAAAnf,MAAAyE,KAAArG,EAAA8gB,SAAAnB,EAAAoB,KAGA/gB,EAAAmhB,cAAA,SAAAxB,GACA,MAAA3f,GAAAkhB,kBAAAvB,GAAA/d,KAAAyE,KAAAsZ,EAAAne,SAGAxB,EAAAohB,UAAA,SAAAzB,EAAAW,GACA,wBAAAA,GAAA,GACAA,IACAX,IAAAlT,QACAkT,EAAA9a,KAAA6a,GAGA,IAAA2B,GAAA1B,EAAAne,OAAA,EACA8f,EAAA3B,EAAA/d,KAAA2f,KAAAF,GAAA,GACAG,EAAAxhB,EAAA4gB,OAAAjB,GAAA,GACA8B,EAAA9B,EAAA/d,KAAA2f,KAAA,EAAAF,GAAA,EAEA,QAAYC,KAAAE,KAAAC,OAGZzhB,EAAA0hB,wBAAA,SAAAvB,EAAAY,GACA,MAAAnf,MAAAyE,KAAArG,EAAA2hB,eAAAxB,EAAAY,KAGA/gB,EAAA2hB,eAAA,SAAAxB,EAAAY,GACA,wBAAAA,GAAA,EAGA,QAFApN,GAAA,EACAnS,EAAA,EAAA0M,EAAAiS,EAAA3e,OACAgB,EAAA,EAAmB0L,EAAA1L,EAAOA,IAAA,CAC1B,GAAAmd,GAAAQ,EAAA3d,GACAof,EAAA5hB,EAAA8gB,SAAAnB,EAEAhM,KAAAgM,EAAAne,OAAA,GAAAogB,EAGApgB,GADAuf,EACApB,EAAAne,OAAA,EAEAme,EAAAne,OAEA,MAAAmS,GAAAnS,GAGAxB,EAAA6hB,KAAA,SAAAlC,GACA,GAEAnd,GAFA0L,EAAAyR,EAAAne,OACAsgB,EAAA,GAAAla,OAAAsG,EAEA,KAAA1L,EAAA,EAAe0L,EAAA1L,EAAOA,IACtBsf,EAAAtf,GAAA,CAEA,IAAAuf,GAAA,GAAAna,OAAAsG,GACA7J,EAAA,CAEA,KAAA7B,EAAA,EAAe0L,EAAA1L,EAAOA,IAAA,CACtB,GAAAN,GAAA6f,EAAAC,QAAArC,EAAAnd,GACAN,IAAA,EACA4f,EAAA5f,MAEA6f,EAAA1d,GAAAsb,EAAAnd,GACAsf,EAAAzd,GAAA,EACAA,KAIA,GAAA4d,GAAA,EAAAhP,EAAA,CACA,KAAAzQ,EAAA,EAAe6B,EAAA7B,EAAWA,IAC1Bsf,EAAAtf,GAAAyf,IACAA,EAAAH,EAAAtf,GACAyQ,EAAAzQ,EAIA,OAAAuf,GAAA9O,IAGAjT,EAAAkiB,WAAA,SAAAjO,EAAAC,EAAA6M,GACA,wBAAAA,GAAA,EACA,IAAAoB,GAAAniB,EAAA4T,KAAAK,GACAmO,EAAApiB,EAAA4T,KAAAM,EAEA,IAAAD,EAAAzS,SAAA0S,EAAA1S,OACA,8CAGA,QADA6gB,GAAA,EAAAnU,EAAA+F,EAAAzS,OACAgB,EAAA,EAAmB0L,EAAA1L,EAAOA,IAAA,CAC1B,GAAApB,GAAA6S,EAAAzR,GAAA2f,EACA9gB,EAAA6S,EAAA1R,GAAA4f,CACAC,IAAAjhB,EAAAC,EAGA,MAAA0f,GACAsB,GAAAnU,EAAA,GAEAmU,EAAAnU,GAGAlO,EAAAsiB,SAAA,SAAA3C,EAAAoB,GACA,wBAAAA,GAAA,EAIA,QAHAC,GAAAhhB,EAAA4T,KAAA+L,GAEA7F,EAAA,EAAAyI,EAAA,EAAArU,EAAAyR,EAAAne,OACAgB,EAAA,EAAmB0L,EAAA1L,EAAOA,IAAA,CAC1B,GAAAggB,GAAA7C,EAAAnd,GAAAwe,CACAlH,IAAA0I,IACAD,GAAAC,MAEA,GAAAC,GAAA3I,EAAA5L,EACAwU,EAAAH,EAAArU,EAEAmJ,EAAAqL,EAAA9gB,KAAA2D,IAAAkd,EAAA,IACA,IAAA1B,EAAA,CACA,GAAAjc,GAAAlD,KAAAyE,KAAA6H,KAAA,IACAnJ,EAAAmJ,EAAA,CACA,OAAApJ,GAAAC,EAAAsS,EAGA,MAAAA,IAIArX,EAAA2iB,SAAA,SAAAhD,EAAAoB,GACA,wBAAAA,GAAA,EAIA,QAHAC,GAAAhhB,EAAA4T,KAAA+L,GACArd,EAAAqd,EAAAne,OAAAsY,EAAA,EAAA8I,EAAA,EAEApgB,EAAA,EAAmBF,EAAAE,EAAOA,IAAA,CAC1B,GAAAggB,GAAA7C,EAAAnd,GAAAwe,CACAlH,IAAA0I,IACAI,GAAAJ,QAEA,GAAAC,GAAA3I,EAAAxX,EACAugB,EAAAD,EAAAtgB,CAEA,IAAAye,EAAA,CACA,GAAAhO,GAAA+G,GAAAxX,EAAA,GACAwC,EAAAxC,KAAA,KAAAA,EAAA,IAAAA,EAAA,IAAAA,EAAA,IACAyC,EAAA6d,GAAA7P,KACAlS,GAAAyB,EAAA,IAAAA,EAAA,KAAAA,EAAA,IAAAA,EAAA,GAEA,OAAAwC,GAAAC,EAAA,EAAAlE,EAGA,MAAAgiB,IAAAJ,KAAA,GAIAziB,EAAA8iB,QAAA,SAAAnD,EAAApX,GACA,wBAAAA,EAAA,EAEA,QADAoL,GAAA,EAAAzF,EAAAyR,EAAAne,OACAgB,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1BmR,GAAAgM,EAAAnd,GAAAZ,KAAAoH,IAAA2W,EAAAnd,GAAA+F,EACA,QAAAoL,GAGA3T,EAAA+iB,aAAA,SAAApD,EAAAqD,GAEA,OADArP,GAAA,EAAAzF,EAAAyR,EAAAne,OACAgB,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1BmR,GAAAgM,EAAAnd,GAAAwgB,EAAAxgB,EACA,OAAAmR,IAGA3T,EAAAijB,0BAAA,SAAAtD,EAAAqD,GACA,MAAAphB,MAAAyE,KAAArG,EAAAkjB,iBAAAvD,EAAAqD,KAGAhjB,EAAAkjB,iBAAA,SAAAvD,EAAAqD,GAKA,OAJAhC,GAAAhhB,EAAA+iB,aAAApD,EAAAqD,GACApB,EAAA,EAAA1T,EAAAyR,EAAAne,OACAsD,EAAA,EAAAC,EAAA,EAEAvC,EAAA,EAAmB0L,EAAA1L,EAAOA,IAAA,CAC1B,GAAAqY,GAAA8E,EAAAnd,GAAAwe,EACA7G,EAAA6I,EAAAxgB,EAEAof,IAAAzH,GAAAU,KACA9V,GAAAoV,EACArV,GAAAqV,IAGA,MAAAyH,IAAA7c,OAAAD,KAGA9E,EAAAmjB,OAAA,SAAAxD,EAAAyD,GACA,wBAAAA,GAAA,EAEA,IAAAxgB,GAAA+c,CACAyD,KACAxgB,EAAA+c,EAAAlT,QAGA,QADAuU,GAAAhhB,EAAA4T,KAAAhR,GAAAsL,EAAAtL,EAAApB,OACAgB,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1BI,EAAAJ,IAAAwe,GAGAhhB,EAAAqjB,YAAA,SAAA1D,EAAA2D,EAAAF,GACA,wBAAAE,EAAAtjB,EAAAkhB,kBAAAvB,IACA,wBAAAyD,GAAA,EAGA,QAFAlV,GAAAyR,EAAAne,OACAoB,EAAAwgB,EAAAzD,EAAA,GAAA/X,OAAAsG,GACA1L,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1BI,EAAAJ,GAAAmd,EAAAnd,GAAA8gB,CACA,OAAA1gB,IAGA5C,EAAA+T,cAAA,SAAA5C,GACA,GAAAjD,GAAAiD,EAAA3P,OACAoB,EAAA,GAAAgF,OAAAsG,EACAtL,GAAA,GAAAuO,EAAA,EACA,QAAA3O,GAAA,EAAmB0L,EAAA1L,EAAOA,IAC1BI,EAAAJ,GAAAI,EAAAJ,EAAA,GAAA2O,EAAA3O,EACA,OAAAI,KnBghKM,SAAS3C,EAAQD,EAASM,GoBn9KhC,YAKA,SAAAwiB,GAAAhW,EAAAvE,GACA,wBACAA,EAAA,EAKA,QAHAoL,GAAA,EACA4P,EAAAzW,EAAAtL,OACAgiB,EAAA1W,EAAA,GAAAtL,OACAgB,EAAA,EAAmB+gB,EAAA/gB,EAAQA,IAC3B,OAAAC,GAAA,EAAuB+gB,EAAA/gB,EAAQA,IAC/BkR,GAAA7G,EAAAtK,GAAAC,GAAAb,KAAAoH,IAAA8D,EAAAtK,GAAAC,GAAA8F,EAGA,QAAAoL,EAGA,QAAAC,GAAA9G,EAAA0P,GACA,wBACAA,EAAA,EAEA,IAEAwE,GAAAyC,EAAAjhB,EAAAC,EAFA2C,EAAA0H,EAAAtL,OACA2D,EAAA2H,EAAA,GAAAtL,MAGA,SAAAgb,EAAA,CAGA,IAFAwE,GAAA,GACAyC,EAAAre,EAAAD,EACA3C,EAAA,EAAmB4C,EAAA5C,EAAUA,IAC7B,IAAAC,EAAA,EAAuB0C,EAAA1C,EAAUA,IACjCue,EAAA,IAAAlU,EAAAtK,GAAAC,EAGAue,GAAA,IAAAyC,MACK,QAAAjH,EAGL,IAFAwE,EAAA,GAAApZ,OAAAzC,GACAse,EAAAre,EACA3C,EAAA,EAAmB0C,EAAA1C,EAAUA,IAAA,CAE7B,IADAue,EAAAve,GAAA,EACAD,EAAA,EAAuB4C,EAAA5C,EAAUA,IACjCwe,EAAAve,IAAAqK,EAAAtK,GAAAC,EAEAue,GAAAve,IAAAghB,MAEK,QAAAjH,EAWL,SAAAvD,OAAA,oBARA,KAFA+H,EAAA,GAAApZ,OAAAxC,GACAqe,EAAAte,EACA1C,EAAA,EAAmB2C,EAAA3C,EAAUA,IAAA,CAE7B,IADAue,EAAAve,GAAA,EACAD,EAAA,EAAuB2C,EAAA3C,EAAUA,IACjCwe,EAAAve,IAAAqK,EAAArK,GAAAD,EAEAwe,GAAAve,IAAAghB,GAKA,MAAAzC,GAGA,QAAAE,GAAApU,EAAAoT,EAAAa,GAEA,OADAa,GAAAd,EAAAhU,EAAAoT,EAAAa,GAAA7S,EAAA0T,EAAApgB,OACAgB,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1Bof,EAAApf,GAAAZ,KAAAyE,KAAAub,EAAApf,GAEA,OAAAof,GAGA,QAAAd,GAAAhU,EAAAoT,EAAAa,GACA,wBACAA,GAAA,GAEAb,KAAAtM,EAAA9G,EACA,IAAA1H,GAAA0H,EAAAtL,MACA,QAAA4D,EAAA,QAIA,QAHAD,GAAA2H,EAAA,GAAAtL,OACAogB,EAAA,GAAAha,OAAAzC,GAEA1C,EAAA,EAAmB0C,EAAA1C,EAAUA,IAAA,CAE7B,OADAihB,GAAA,EAAAC,EAAA,EAAAviB,EAAA,EACAoB,EAAA,EAAuB4C,EAAA5C,EAAUA,IACjCpB,EAAA0L,EAAAtK,GAAAC,GAAAyd,EAAAzd,GACAihB,GAAAtiB,EACAuiB,GAAAviB,GAEA2f,GACAa,EAAAnf,IAAAkhB,EAAAD,IAAAte,MAAA,GAEAwc,EAAAnf,IAAAkhB,EAAAD,IAAAte,KAGA,MAAAwc,GAGA,QAAAhB,GAAA9T,GAIA,OAHA1H,GAAA0H,EAAAtL,OAAA2D,EAAA2H,EAAA,GAAAtL,OACAoiB,EAAA,GAAAhc,OAAAzC,GAEA3C,EAAA,EAAmB2C,EAAA3C,EAAUA,IAAA,CAE7B,OADAuL,GAAA,GAAAnG,OAAAxC,GACA3C,EAAA,EAAuB2C,EAAA3C,EAAUA,IACjCsL,EAAAtL,GAAAqK,EAAArK,GAAAD,EAEAuL,GAAAlJ,MACA,IAAA4e,GAAA1V,EAAAvM,MACAiiB,GAAA,MACAG,EAAAphB,GAAA,IAAAuL,EAAA0V,EAAA,GAAA1V,EAAA0V,EAAA,MAEAG,EAAAphB,GAAAuL,EAAAnM,KAAA2e,MAAAkD,EAAA,IAGA,MAAAG,GAGA,QAAA/B,GAAA/U,GACA,GAGAtK,GAAAC,EAHA2C,EAAA0H,EAAAtL,OACA2D,EAAA2H,EAAA,GAAAtL,OACAqiB,EAAA,GAAAjc,OAAAzC,EAEA,KAAA3C,EAAA,EAAe2C,EAAA3C,EAAUA,IAAA,CAEzB,OADAsf,GAAA,GAAAla,OAAAxC,GACAyC,EAAA,EAAuBzC,EAAAyC,EAAUA,IACjCia,EAAAja,GAAA,CAEA,IAAAka,GAAA,GAAAna,OAAAxC,GACAf,EAAA,CAEA,KAAA5B,EAAA,EAAmB2C,EAAA3C,EAAUA,IAAA,CAC7B,GAAAP,GAAA6f,EAAAC,QAAAlV,EAAArK,GAAAD,GACAN,IAAA,EACA4f,EAAA5f,MAEA6f,EAAA1d,GAAAyI,EAAArK,GAAAD,GACAsf,EAAAzd,GAAA,EACAA,KAIA,GAAA4d,GAAA,EAAAhP,EAAA,CACA,KAAAxQ,EAAA,EAAmB4B,EAAA5B,EAAWA,IAC9Bqf,EAAArf,GAAAwf,IACAA,EAAAH,EAAArf,GACAwQ,EAAAxQ,EAIAohB,GAAArhB,GAAAuf,EAAA9O,GAEA,MAAA4Q,GAGA,QAAAvB,GAAAxV,EAAAiU,GACA,wBAAAA,GAAA,EAKA,QAJAb,GAAAtM,EAAA9G,GACAxK,EAAAwK,EAAAtL,OAAA0M,EAAAgS,EAAA1e,OACAsiB,EAAA,GAAAlc,OAAAsG,GAEAzL,EAAA,EAAmByL,EAAAzL,EAAOA,IAAA,CAE1B,OADAqX,GAAA,EAAAyI,EAAA,EACA/f,EAAA,EAAuBF,EAAAE,EAAOA,IAAA,CAC9B,GAAAggB,GAAA1V,EAAAtK,GAAAC,GAAAyd,EAAAzd,EACAqX,IAAA0I,IACAD,GAAAC,MAGA,GAAAC,GAAA3I,EAAAxX,EACAogB,EAAAH,EAAAjgB,EACA+U,EAAAqL,EAAA9gB,KAAA2D,IAAAkd,EAAA,IAEA,IAAA1B,EAAA,CACA,GAAAjc,GAAAlD,KAAAyE,KAAA/D,KAAA,IACAyC,EAAAzC,EAAA,CACAwhB,GAAArhB,GAAAqC,EAAAC,EAAAsS,MAEAyM,GAAArhB,GAAA4U,EAGA,MAAAyM,GAGA,QAAAnB,GAAA7V,EAAAiU,GACA,wBAAAA,GAAA,EAKA,QAJAb,GAAAtM,EAAA9G,GACAxK,EAAAwK,EAAAtL,OAAAZ,EAAAkM,EAAA,GAAAtL,OACAuiB,EAAA,GAAAnc,OAAAhH,GAEA6B,EAAA,EAAmB7B,EAAA6B,EAAOA,IAAA,CAE1B,OADAqX,GAAA,EAAA8I,EAAA,EACApgB,EAAA,EAAuBF,EAAAE,EAAOA,IAAA,CAC9B,GAAAggB,GAAA1V,EAAAtK,GAAAC,GAAAyd,EAAAzd,EACAqX,IAAA0I,IACAI,GAAAJ,QAEA,GAAAC,GAAA3I,EAAAxX,EACAugB,EAAAD,EAAAtgB,CAEA,IAAAye,EAAA,CACA,GAAAhO,GAAA+G,GAAAxX,EAAA,GACAwC,EAAAxC,KAAA,KAAAA,EAAA,IAAAA,EAAA,IAAAA,EAAA,IACAyC,EAAA6d,GAAA7P,KACAlS,GAAAyB,EAAA,IAAAA,EAAA,KAAAA,EAAA,IAAAA,EAAA,GACAyhB,GAAAthB,GAAAqC,EAAAC,EAAA,EAAAlE,MAEAkjB,GAAAthB,GAAAogB,GAAAJ,KAAA,EAGA,MAAAsB,GAGA,QAAA5C,GAAArU,GAMA,OALAqT,GAAArT,EAAAtL,OACAwiB,EAAA9C,EAAApU,GAAAoB,EAAA8V,EAAAxiB,OACAyiB,EAAA,GAAArc,OAAAsG,GACAgW,EAAAtiB,KAAAyE,KAAA8Z,GAEA3d,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1ByhB,EAAAzhB,GAAAwhB,EAAAxhB,GAAA0hB,CAEA,OAAAD,GAGA,QAAA/B,GAAApV,EAAA0P,GACA,MAAA2H,GAAArX,EAAAmQ,OAAAT,GAGA,QAAA2H,GAAArX,EAAAsX,EAAA5H,GACA,wBACAA,EAAA,GAEA,wBACA,IAAAA,EACA4H,EAAAtX,EAAAtL,OAAA,EACS,IAAAgb,IACT4H,EAAAtX,EAAA,GAAAtL,OAAA,GAGA,IAAA0e,GAAAtM,EAAA9G,EAAA0P,GACApX,EAAA0H,EAAAtL,MACA,QAAA4D,EACA,UAEA,IACAid,GAAA7f,EAAAC,EAAA8R,EAAA1M,EADA1C,EAAA2H,EAAA,GAAAtL,MAGA,QAAAgb,EAAA,CAEA,IADA6F,EAAA,GAAAza,OAAAzC,GACA3C,EAAA,EAAmB2C,EAAA3C,EAAUA,IAC7B6f,EAAA7f,GAAA,GAAAoF,OAAAzC,EAEA,KAAA3C,EAAA,EAAmB2C,EAAA3C,EAAUA,IAC7B,IAAAC,EAAAD,EAAuB2C,EAAA1C,EAAUA,IAAA,CAEjC,IADA8R,EAAA,EACA1M,EAAA,EAA2BzC,EAAAyC,EAAUA,IACrC0M,IAAAzH,EAAAjF,GAAApF,GAAAyd,EAAAzd,KAAAqK,EAAAjF,GAAArF,GAAA0d,EAAA1d,GAEA+R,IAAA6P,EACA/B,EAAA7f,GAAAC,GAAA8R,EACA8N,EAAA5f,GAAAD,GAAA+R,OAGK,QAAAiI,EAiBL,SAAAvD,OAAA,oBAfA,KADAoJ,EAAA,GAAAza,OAAAxC,GACA5C,EAAA,EAAmB4C,EAAA5C,EAAUA,IAC7B6f,EAAA7f,GAAA,GAAAoF,OAAAxC,EAEA,KAAA5C,EAAA,EAAmB4C,EAAA5C,EAAUA,IAC7B,IAAAC,EAAAD,EAAuB4C,EAAA3C,EAAUA,IAAA,CAEjC,IADA8R,EAAA,EACA1M,EAAA,EAA2B1C,EAAA0C,EAAUA,IACrC0M,IAAAzH,EAAArK,GAAAoF,GAAAqY,EAAAzd,KAAAqK,EAAAtK,GAAAqF,GAAAqY,EAAA1d,GAEA+R,IAAA6P,EACA/B,EAAA7f,GAAAC,GAAA8R,EACA8N,EAAA5f,GAAAD,GAAA+R,GAOA,MAAA8N,GAGA,QAAAgC,GAAAvX,GACA,GAKAtK,GAAAC,EALAyd,EAAAtM,EAAA9G,GACAkX,EAAA9C,EAAApU,GAAA,EAAAoT,GACAoE,EAAAC,EAAAzX,EAAAoT,EAAA8D,GACA5e,EAAA0H,EAAAtL,OACA2D,EAAA2H,EAAA,GAAAtL,OAGAgjB,EAAA,GAAA5c,OAAAzC,EACA,KAAA3C,EAAA,EAAe2C,EAAA3C,EAAUA,IACzBgiB,EAAAhiB,GAAA,GAAAoF,OAAAzC,EAEA,KAAA3C,EAAA,EAAe2C,EAAA3C,EAAUA,IACzB,IAAAC,EAAAD,EAAmB2C,EAAA1C,EAAUA,IAAA,CAE7B,OADA5B,GAAA,EACAgH,EAAA,EAAAqG,EAAAoW,EAAA9iB,OAA8C0M,EAAArG,EAAOA,IACrDhH,GAAAyjB,EAAAzc,GAAApF,GAAA6hB,EAAAzc,GAAArF,EAEA3B,IAAAuE,EAAA,EACAof,EAAAhiB,GAAAC,GAAA5B,EACA2jB,EAAA/hB,GAAAD,GAAA3B,EAGA,MAAA2jB,GAGA,QAAAD,GAAAzX,EAAAoT,EAAA8D,GAGA,MAFA9D,MAAAtM,EAAA9G,GACA,wBAAAkX,EAAA9C,EAAApU,GAAA,EAAAoT,IACAmD,EAAAF,EAAArW,EAAAoT,GAAA,GAAA8D,GAAA,GAGA,QAAAb,GAAArW,EAAAoT,EAAAkD,GACAlD,KAAAtM,EAAA9G,EACA,IAEAtK,GAAAC,EAAA8L,EAFA3L,EAAAkK,EACAoB,EAAApB,EAAAtL,MAGA,KAAA4hB,EAEA,IADAxgB,EAAA,GAAAgF,OAAAsG,GACA1L,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1BI,EAAAJ,GAAA,GAAAoF,OAAAkF,EAAAtK,GAAAhB,OAIA,KAAAgB,EAAA,EAAe0L,EAAA1L,EAAOA,IAAA,CACtB,GAAA0P,GAAAtP,EAAAJ,EACA,KAAAC,EAAA,EAAA8L,EAAA2D,EAAA1Q,OAAoC+M,EAAA9L,EAAQA,IAC5CyP,EAAAzP,GAAAqK,EAAAtK,GAAAC,GAAAyd,EAAAzd,GAGA,MAAAG,GAGA,QAAAygB,GAAAvW,EAAAkX,EAAAZ,GACA,wBAAAY,EAAA9C,EAAApU,GACA,IAEAtK,GAAAC,EAAA8L,EAFA3L,EAAAkK,EACAoB,EAAApB,EAAAtL,MAGA,KAAA4hB,EAEA,IADAxgB,EAAA,GAAAgF,OAAAsG,GACA1L,EAAA,EAAmB0L,EAAA1L,EAAOA,IAC1BI,EAAAJ,GAAA,GAAAoF,OAAAkF,EAAAtK,GAAAhB,OAIA,KAAAgB,EAAA,EAAe0L,EAAA1L,EAAOA,IAAA,CACtB,GAAAiiB,GAAA7hB,EAAAJ,GACAkiB,EAAA5X,EAAAtK,EACA,KAAAC,EAAA,EAAA8L,EAAAkW,EAAAjjB,OAA0C+M,EAAA9L,EAAQA,IAClD,IAAAuhB,EAAAvhB,IAAAkiB,MAAAX,EAAAvhB,MACAgiB,EAAAhiB,GAAAiiB,EAAAjiB,GAAAuhB,EAAAvhB,IAIA,MAAAG,GAGA,QAAAsgB,GAAApW,EAAAkW,GACA,GAAA9C,GAAAtM,EAAA9G,GACA1H,EAAA0H,EAAAtL,MACA,QAAA4D,EAAA,QAIA,QAHAD,GAAA2H,EAAA,GAAAtL,OACAogB,EAAA,GAAAha,OAAAzC,GAEA1C,EAAA,EAAmB0C,EAAA1C,EAAUA,IAAA,CAI7B,OAHAkR,GAAA,EACA7O,EAAA,EAAAC,EAAA,EAEAvC,EAAA,EAAuB4C,EAAA5C,EAAUA,IAAA,CACjC,GAAAqY,GAAA/N,EAAAtK,GAAAC,GAAAyd,EAAAzd,GACA0X,EAAA6I,EAAAxgB,EAEAmR,IAAAwG,GAAAU,KACA9V,GAAAoV,EACArV,GAAAqV,IAGAyH,EAAAnf,GAAAkR,GAAA5O,OAAAD,IAGA,MAAA8c,GAGA,QAAAmB,GAAAjW,EAAAkW,EAAAxG,GACA,wBACAA,EAAA,EAEA,IAAApX,GAAA0H,EAAAtL,MACA,QAAA4D,EAAA,QACA,IACA8a,GAAA1d,EAAAmK,EAAAlK,EAAA0X,EAAAjI,EADA/M,EAAA2H,EAAA,GAAAtL,MAGA,QAAAgb,EAAA,CAEA,IADA0D,EAAA,GAAAtY,OAAAzC,GACA3C,EAAA,EAAmB2C,EAAA3C,EAAUA,IAC7B0d,EAAA1d,GAAA,CAEA,KAAAA,EAAA,EAAmB4C,EAAA5C,EAAUA,IAG7B,IAFA0P,EAAApF,EAAAtK,GACA2X,EAAA6I,EAAAxgB,GACAC,EAAA,EAAuB0C,EAAA1C,EAAUA,IACjCyd,EAAAzd,IAAAyP,EAAAzP,GAAA0X,MAGK,QAAAqC,EAaL,SAAAvD,OAAA,oBAXA,KADAiH,EAAA,GAAAtY,OAAAxC,GACA5C,EAAA,EAAmB4C,EAAA5C,EAAUA,IAC7B0d,EAAA1d,GAAA,CAEA,KAAAC,EAAA,EAAmB2C,EAAA3C,EAAUA,IAG7B,IAFAyP,EAAApF,EAAArK,GACA0X,EAAA6I,EAAAvgB,GACAD,EAAA,EAAuB2C,EAAA3C,EAAUA,IACjC0d,EAAAzd,IAAAyP,EAAA1P,GAAA2X,EAOA,GAAAyK,GAAAC,EAAAlR,IAAAqP,EACA,QAAA4B,EACA,IAAApiB,EAAA,EAAAmK,EAAAuT,EAAA1e,OAAsCmL,EAAAnK,EAAQA,IAC9C0d,EAAA1d,IAAAoiB,CAGA,OAAA1E,GAGA,QAAA4E,GAAAhY,EAAAkW,EAAA9C,EAAA1D,GACAA,KAAA,EACA0D,KAAA6C,EAAAjW,EAAAkW,EAAAxG,EAEA,QADAuI,GAAA,EAAAjL,EAAA,EACAtX,EAAA,EAAAmK,EAAAqW,EAAAxhB,OAAwCmL,EAAAnK,EAAQA,IAChDuiB,GAAA/B,EAAAxgB,GACAsX,GAAAkJ,EAAAxgB,GAAAwgB,EAAAxgB,EAEA,IAAAK,GAAAkiB,OAAAjL,EACA,OAAAkL,GAAAlY,EAAAkW,EAAA9C,EAAArd,EAAA2Z,GAGA,QAAAwI,GAAAlY,EAAAkW,EAAA9C,EAAArd,EAAA2Z,GACAA,KAAA,EACA0D,KAAA6C,EAAAjW,EAAAkW,EAAAxG,GACA,wBACA3Z,EAAA,EAEA,IAAAuC,GAAA0H,EAAAtL,MACA,QAAA4D,EACA,UAEA,IACAid,GAAA7f,EAAAC,EAAAoF,EAAA0M,EADApP,EAAA2H,EAAA,GAAAtL,MAGA,QAAAgb,EAAA,CAEA,IADA6F,EAAA,GAAAza,OAAAzC,GACA3C,EAAA,EAAmB2C,EAAA3C,EAAUA,IAC7B6f,EAAA7f,GAAA,GAAAoF,OAAAzC,EAEA,KAAA3C,EAAA,EAAmB2C,EAAA3C,EAAUA,IAC7B,IAAAC,EAAAD,EAAuB2C,EAAA1C,EAAUA,IAAA,CAEjC,IADA8R,EAAA,EACA1M,EAAA,EAA2BzC,EAAAyC,EAAUA,IACrC0M,GAAAyO,EAAAnb,IAAAiF,EAAAjF,GAAApF,GAAAyd,EAAAzd,KAAAqK,EAAAjF,GAAArF,GAAA0d,EAAA1d,GAEA6f,GAAA7f,GAAAC,GAAA8R,EAAA1R,EACAwf,EAAA5f,GAAAD,GAAA+R,EAAA1R,OAGK,QAAA2Z,EAgBL,SAAAvD,OAAA,oBAdA,KADAoJ,EAAA,GAAAza,OAAAxC,GACA5C,EAAA,EAAmB4C,EAAA5C,EAAUA,IAC7B6f,EAAA7f,GAAA,GAAAoF,OAAAxC,EAEA,KAAA5C,EAAA,EAAmB4C,EAAA5C,EAAUA,IAC7B,IAAAC,EAAAD,EAAuB4C,EAAA3C,EAAUA,IAAA,CAEjC,IADA8R,EAAA,EACA1M,EAAA,EAA2B1C,EAAA0C,EAAUA,IACrC0M,GAAAyO,EAAAnb,IAAAiF,EAAArK,GAAAoF,GAAAqY,EAAAzd,KAAAqK,EAAAtK,GAAAqF,GAAAqY,EAAA1d,GAEA6f,GAAA7f,GAAAC,GAAA8R,EAAA1R,EACAwf,EAAA5f,GAAAD,GAAA+R,EAAA1R,GAOA,MAAAwf,GA/eA,GAAAwC,GAAAvkB,EAAA,GAkfAL,GAAAD,SACA8iB,UACAlP,OACAsN,oBACAJ,WACAF,SACAiB,OACAS,WACAK,WACAxB,gBACAe,aACAiC,UACAE,cACAE,UACApB,SACAE,cACAH,mBACAH,eACA+B,qBACAE,oBpB29KM,SAAS/kB,EAAQD,GqBj+LvB,YAEA,IAAAilB,GAAA1e,OAAAgH,UAAA2X,eACAC,EAAA5e,OAAAgH,UAAA6X,SAEApY,EAAA,SAAAN,GACA,wBAAA9E,OAAAoF,QACApF,MAAAoF,QAAAN,GAGA,mBAAAyY,EAAAxkB,KAAA+L,IAGA2Y,EAAA,SAAAC,GACA,IAAAA,GAAA,oBAAAH,EAAAxkB,KAAA2kB,GACA,QAGA,IAAAC,GAAAN,EAAAtkB,KAAA2kB,EAAA,eACAE,EAAAF,EAAAG,aAAAH,EAAAG,YAAAlY,WAAA0X,EAAAtkB,KAAA2kB,EAAAG,YAAAlY,UAAA,gBAEA,IAAA+X,EAAAG,cAAAF,IAAAC,EACA,QAKA,IAAAE,EACA,KAAAA,IAAAJ,IAEA,yBAAAI,IAAAT,EAAAtkB,KAAA2kB,EAAAI,GAGAzlB,GAAAD,QAAA,QAAA0d,KACA,GAAAzZ,GAAA0hB,EAAAC,EAAA/V,EAAAgW,EAAA/Z,EACAga,EAAAjX,UAAA,GACArM,EAAA,EACAhB,EAAAqN,UAAArN,OACAukB,GAAA,CAYA,KATA,iBAAAD,IACAC,EAAAD,EACAA,EAAAjX,UAAA,OAEArM,EAAA,IACE,gBAAAsjB,IAAA,kBAAAA,IAAA,MAAAA,KACFA,MAGOtkB,EAAAgB,IAAYA,EAGnB,GAFAyB,EAAA4K,UAAArM,GAEA,MAAAyB,EAEA,IAAA0hB,IAAA1hB,GACA2hB,EAAAE,EAAAH,GACA9V,EAAA5L,EAAA0hB,GAGAG,IAAAjW,IAEAkW,GAAAlW,IAAAwV,EAAAxV,KAAAgW,EAAA7Y,EAAA6C,MACAgW,GACAA,GAAA,EACA/Z,EAAA8Z,GAAA5Y,EAAA4Y,SAEA9Z,EAAA8Z,GAAAP,EAAAO,QAIAE,EAAAH,GAAAjI,EAAAqI,EAAAja,EAAA+D,IAGM,mBAAAA,KACNiW,EAAAH,GAAA9V,GAQA,OAAAiW,KrB0+LM,SAAS7lB,EAAQD,EAASM,GsBljMhC,QAAA0lB,GAAAjY,EAAApD,EAAA1G,GAGA,GAFAA,EAAAyZ,KAAuBuI,EAAAhiB,GAEvBA,EAAAga,WAAA,OAAAha,EAAAga,WAAA,IAAA1Z,OAAA2hB,UAAAjiB,EAAAga,YACA,SAAA/Q,YAAA,oEAGA,IAAAjJ,EAAAga,WAAAlQ,EAAAvM,OACA,SAAA0L,YAAA,8CAAAjJ,EAAAga,WAAA,IAAAlQ,EAAAvM,OACA,IAAAyC,EAAAka,WAAA,IAAA5Z,OAAA2hB,UAAAjiB,EAAAka,YACA,SAAAjR,YAAA,0CACA,IAAAjJ,EAAAia,WAAA,IAAA3Z,OAAA2hB,UAAAjiB,EAAAia,YACA,SAAAhR,YAAA,0CACAjJ,GAAAia,YAAA,GACAnV,QAAAqL,KAAA,0JAGA,IAAA6J,GAAAha,EAAAga,WAEA4C,EAAAjf,KAAA2e,MAAAtC,EAAA,GACAkI,EAAApY,EAAAvM,OACA4kB,EAAA,GAAAxe,OAAAue,GACAnD,EAAAqD,EAAApI,EAAAha,EAAAia,WAAAja,EAAAka,YACAmI,EAAA,EACAC,GAAA,CACA,oBAAAhgB,OAAAgH,UAAA6X,SAAAzkB,KAAAgK,GACA4b,GAAA,EAGAD,EAAA1kB,KAAA2D,IAAAoF,EAAA1G,EAAAka,WAIA,QAAA3b,GAAA,EAAgBqe,EAAAre,EAAOA,IAAA,CAIvB,OAHAgkB,GAAAxD,EAAAnC,EAAAre,EAAA,GACAikB,EAAAzD,EAAAnC,EAAAre,EAAA,GACAkkB,EAAA,EAAAC,EAAA,EACAzY,EAAA,EAAuB+P,EAAA/P,EAAgBA,IACvCwY,GAAAF,EAAAtY,GAAAH,EAAAG,GACAyY,GAAAF,EAAAvY,GAAAH,EAAAoY,EAAAlI,EAAA/P,EAAA,EAEAqY,IACAH,EAAAvF,EAAAre,EAAA,GAAAkkB,EAAAJ,EACAF,EAAAD,EAAAtF,EAAAre,GAAAmkB,EAAAL,IAGAA,EAAAM,EAAAjc,EAAAkW,EAAAre,EAAA,EAAAqe,EAAA5c,EAAAka,YACAiI,EAAAvF,EAAAre,EAAA,GAAAkkB,EAAAJ,EACAA,EAAAM,EAAAjc,EAAAwb,EAAAtF,EAAAre,EAAAqe,EAAA5c,EAAAka,YACAiI,EAAAD,EAAAtF,EAAAre,GAAAmkB,EAAAL,GAKA,OADAO,GAAA7D,EAAAnC,GACAre,EAAAyb,EAAyBkI,EAAA,EAAA3jB,EAAOA,IAAA,CAEhC,OADA0W,GAAA,EACAhL,EAAA,EAAuB+P,EAAA/P,EAAgBA,IACvCgL,GAAA2N,EAAA3Y,GAAAH,EAAAG,EAAA1L,EAAAyb,EACAsI,KACAD,EAAAM,EAAAjc,EAAAnI,EAAAqe,EAAA,EAAAA,EAAA5c,EAAAka,aACAiI,EAAA5jB,EAAAqe,EAAA,GAAA3H,EAAAoN,EAEA,MAAAF,GAGA,QAAAQ,GAAAjc,EAAAwY,EAAAtC,EAAA1C,GAGA,OAFAmI,GAAA,EACAjiB,EAAA,EACA7B,EAAA2gB,EAAAtC,EAA0BsC,EAAAtC,EAAAre,EAAcA,IACxCA,GAAA,GAAAA,EAAAmI,EAAAnJ,OAAA,IACA8kB,GAAA3b,EAAAnI,EAAA,GAAAmI,EAAAnI,GACA6B,IAGA,OAAAzC,MAAA2D,IAAA+gB,EAAAjiB,EAAA8Z,GAGA,QAAA2I,GAAAtkB,EAAA5B,EAAAiH,EAAA0M,GACA,GAAAwS,GAAA,CAcA,OAZAA,GADAlf,EAAA,GACA,EAAAA,EAAA,IAAAA,GAAA,EAAAjH,EAAAiH,EAAA,KAAArF,EAAAskB,EAAAtkB,EAAA5B,EAAAiH,EAAA,EAAA0M,GACAA,EAAAuS,EAAAtkB,EAAA5B,EAAAiH,EAAA,EAAA0M,EAAA,KAAA1M,EAAA,MAAAjH,EAAAiH,OAAA,EAAAjH,EAAAiH,EAAA,IAAAif,EAAAtkB,EAAA5B,EAAAiH,EAAA,EAAA0M,GAGA,GAAA1M,GAAA,GAAA0M,EACA,EAGA,EAOA,QAAAyS,GAAAliB,EAAAC,GACA,GAAAkiB,GAAA,CACA,IAAAniB,GAAAC,EACA,OAAAtC,GAAAqC,EAAAC,EAAA,EAAwBD,GAAArC,EAAKA,IAC7BwkB,GAAAxkB,CAGA,OAAAwkB,GAGA,QAAAC,GAAA1kB,EAAAyC,EAAArE,EAAA0B,EAAAiS,GAEA,OADAZ,GAAA,EACA9L,EAAA,EAAgBvF,GAAAuF,EAAKA,IAErB8L,IAAA,EAAA9L,EAAA,IAAAmf,EAAA,EAAApmB,EAAAiH,GAAAmf,EAAA,EAAApmB,EAAAiH,EAAA,EAAAA,EAAA,IAAAif,EAAAtkB,EAAA5B,EAAAiH,EAAA,GAAAif,EAAA7hB,EAAArE,EAAAiH,EAAA0M,EAEA,OAAAZ,GASA,QAAA0S,GAAAzlB,EAAA0B,EAAAiS,GAGA,OAFAyO,GAAA,GAAApb,OAAAhH,GACAulB,EAAAvkB,KAAA2e,MAAA3f,EAAA,GACAqE,GAAAkhB,EAAkBA,GAAAlhB,EAAMA,IAAA,CACxB+d,EAAA/d,EAAAkhB,GAAA,GAAAve,OAAAhH,EACA,QAAA6B,IAAA0jB,EAAsBA,GAAA1jB,EAAMA,IAC5BugB,EAAA/d,EAAAkhB,GAAA1jB,EAAA0jB,GAAAe,EAAAzkB,EAAAwC,EAAAkhB,EAAA7jB,EAAAiS,GAGA,MAAAyO,GA3IA,GAAAtF,GAAApd,EAAA,IAGA2lB,GAFA3lB,EAAA,KAGA2d,WAAA,EACAE,WAAA,EACAD,WAAA,GAgKAje,GAAAD,QAAAgmB","file":"ml-gsd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"GSD\"] = factory();\n\telse\n\t\troot[\"GSD\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"GSD\"] = factory();\n\telse\n\t\troot[\"GSD\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tmodule.exports.post = __webpack_require__(1);\n\tmodule.exports.gsd = __webpack_require__(15);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Created by acastillo on 9/6/15.\n\t */\n\tvar Opt = __webpack_require__(2);\n\t\n\tfunction sampleFunction(from, to, x, y, lastIndex){\n\t    var nbPoints = x.length;\n\t    var sampleX = [];\n\t    var sampleY = [];\n\t    var direction = Math.sign(x[1]-x[0]);//Direction of the derivative\n\t    if(direction==-1){\n\t        lastIndex[0]= x.length-1;\n\t    }\n\t\n\t    var delta = Math.abs(to-from)/2;\n\t    var mid = (from+to)/2;\n\t    var stop = false;\n\t    var index = lastIndex[0];\n\t    while(!stop&&index<nbPoints&&index>=0){\n\t        if(Math.abs(x[index]-mid)<=delta){\n\t            sampleX.push(x[index]);\n\t            sampleY.push(y[index]);\n\t            index+=direction;\n\t        }\n\t        //It is outside the range.\n\t        else{\n\t\n\t            if(Math.sign(mid-x[index])==1){\n\t                //We'll reach the mid going in the current direction\n\t                index+=direction;\n\t            }\n\t            else{\n\t                //There is not more peaks in the current range\n\t                stop=true;\n\t            }\n\t        }\n\t        //console.log(sampleX);\n\t    }\n\t    lastIndex[0]=index;\n\t    return [sampleX, sampleY];\n\t}\n\t\n\tfunction optimizePeaks(peakList,x,y,n, fnType){\n\t    var i, j, lastIndex=[0];\n\t    var groups = groupPeaks(peakList,n);\n\t    var result = [];\n\t    var factor = 1;\n\t    if(fnType==\"gaussian\")\n\t        factor = 1.17741;//From https://en.wikipedia.org/wiki/Gaussian_function#Properties\n\t    for(i=0;i<groups.length;i++){\n\t        var peaks = groups[i].group;\n\t        if(peaks.length>1){\n\t            //Multiple peaks\n\t            //console.log(\"Pending group of overlaped peaks \"+peaks.length);\n\t            //console.log(\"here1\");\n\t            //console.log(groups[i].limits);\n\t            var sampling = sampleFunction(groups[i].limits[0]-groups[i].limits[1],groups[i].limits[0]+groups[i].limits[1],x,y,lastIndex);\n\t            //console.log(sampling);\n\t            if(sampling[0].length>5){\n\t                var error = peaks[0].width/1000;\n\t                var opts = [  3,    100, error, error, error, error*10, error*10,    11,    9,        1 ];\n\t                //var gauss = Opt.optimizeSingleGaussian(sampling[0], sampling[1], opts, peaks);\n\t                var optPeaks = [];\n\t                if(fnType==\"gaussian\")\n\t                    optPeaks = Opt.optimizeGaussianSum(sampling, peaks, opts);\n\t                else{\n\t                    if(fnType==\"lorentzian\"){\n\t                        optPeaks = Opt.optimizeLorentzianSum(sampling, peaks, opts);\n\t                    }\n\t                }\n\t                //console.log(optPeak);\n\t                for(j=0;j<optPeaks.length;j++){\n\t                    result.push({x:optPeaks[j][0][0],y:optPeaks[j][1][0],width:optPeaks[j][2][0]*factor});\n\t                }\n\t            }\n\t        }\n\t        else{\n\t            //Single peak\n\t            peaks = peaks[0];\n\t            var sampling = sampleFunction(peaks.x-n*peaks.width,\n\t                peaks.x+n*peaks.width,x,y,lastIndex);\n\t            //console.log(\"here2\");\n\t            //console.log(groups[i].limits);\n\t            if(sampling[0].length>5){\n\t                var error = peaks.width/1000;\n\t                var opts = [  3,    100, error, error, error, error*10, error*10,    11,    9,        1 ];\n\t                //var gauss = Opt.optimizeSingleGaussian(sampling[0], sampling[1], opts, peaks);\n\t                //var gauss = Opt.optimizeSingleGaussian([sampling[0],sampling[1]], peaks, opts);\n\t                var optPeak = [];\n\t                if(fnType==\"gaussian\")\n\t                    var optPeak = Opt.optimizeSingleGaussian([sampling[0],sampling[1]], peaks,  opts);\n\t                else{\n\t                    if(fnType==\"lorentzian\"){\n\t                        var optPeak = Opt.optimizeSingleLorentzian([sampling[0],sampling[1]], peaks,  opts);\n\t                    }\n\t                }\n\t                //console.log(optPeak);\n\t                result.push({x:optPeak[0][0],y:optPeak[1][0],width:optPeak[2][0]*factor}); // From https://en.wikipedia.org/wiki/Gaussian_function#Properties}\n\t            }\n\t        }\n\t\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction groupPeaks(peakList,nL){\n\t    var group = [];\n\t    var groups = [];\n\t    var i, j;\n\t    var limits = [peakList[0].x,nL*peakList[0].width];\n\t    var upperLimit, lowerLimit;\n\t    //Merge forward\n\t    for(i=0;i<peakList.length;i++){\n\t        //If the 2 things overlaps\n\t        if(Math.abs(peakList[i].x-limits[0])<(nL*peakList[i].width+limits[1])){\n\t            //Add the peak to the group\n\t            group.push(peakList[i]);\n\t            //Update the group limits\n\t            upperLimit = limits[0]+limits[1];\n\t            if(peakList[i].x+nL*peakList[i].width>upperLimit){\n\t                upperLimit = peakList[i].x+nL*peakList[i].width;\n\t            }\n\t            lowerLimit = limits[0]-limits[1];\n\t            if(peakList[i].x-nL*peakList[i].width<lowerLimit){\n\t                lowerLimit = peakList[i].x-nL*peakList[i].width;\n\t            }\n\t            limits = [(upperLimit+lowerLimit)/2,Math.abs(upperLimit-lowerLimit)/2];\n\t\n\t        }\n\t        else{\n\t            groups.push({limits:limits,group:group});\n\t            //var optmimalPeak = fitSpectrum(group,limits,spectrum);\n\t            group=[peakList[i]];\n\t            limits = [peakList[i].x,nL*peakList[i].width];\n\t        }\n\t    }\n\t    groups.push({limits:limits,group:group});\n\t    //Merge backward\n\t    for(i =groups.length-2;i>=0;i--){\n\t        //The groups overlaps\n\t        if(Math.abs(groups[i].limits[0]-groups[i+1].limits[0])<\n\t            (groups[i].limits[1]+groups[i+1].limits[1])/2){\n\t            for(j=0;j<groups[i+1].group.length;j++){\n\t                groups[i].group.push(groups[i+1].group[j]);\n\t            }\n\t            upperLimit = groups[i].limits[0]+groups[i].limits[1];\n\t            if(groups[i+1].limits[0]+groups[i+1].limits[1]>upperLimit){\n\t                upperLimit = groups[i+1].limits[0]+groups[i+1].limits[1];\n\t            }\n\t            lowerLimit = groups[i].limits[0]-groups[i].limits[1];\n\t            if(groups[i+1].limits[0]-groups[i+1].limits[1]<lowerLimit){\n\t                lowerLimit = groups[i+1].limits[0]-groups[i+1].limits[1];\n\t            }\n\t            //console.log(limits);\n\t            groups[i].limits = [(upperLimit+lowerLimit)/2,Math.abs(upperLimit-lowerLimit)/2];\n\t\n\t            groups.splice(i+1,1);\n\t        }\n\t    }\n\t    return groups;\n\t}\n\t/**\n\t * This function try to join the peaks that seems to belong to a broad signal in a single broad peak.\n\t * @param peakList\n\t * @param options\n\t */\n\tfunction joinBroadPeaks(peakList, options){\n\t    var width = options.width;\n\t    var broadLines=[];\n\t    //Optimize the possible broad lines\n\t    var max=0, maxI=0,count=1;\n\t    var isPartOf = false;\n\t    for(var i=peakList.length-1;i>=0;i--){\n\t        if(peakList[i].soft){\n\t            broadLines.push(peakList.splice(i,1)[0]);\n\t        }\n\t    }\n\t    //Push a feak peak\n\t    broadLines.push({x:Number.MAX_VALUE});\n\t\n\t    var candidates = [[broadLines[0].x,\n\t                        broadLines[0].y]];\n\t    var indexes = [0];\n\t\n\t    for(var i=1;i<broadLines.length;i++){\n\t        //console.log(broadLines[i-1].x+\" \"+broadLines[i].x);\n\t        if(Math.abs(broadLines[i-1].x-broadLines[i].x)<width){\n\t            candidates.push([broadLines[i].x,broadLines[i].y]);\n\t            if(broadLines[i].y>max){\n\t                max = broadLines[i].y;\n\t                maxI = i;\n\t            }\n\t            indexes.push(i);\n\t            count++;\n\t        }\n\t        else{\n\t            if(count>2){\n\t                var fitted =  Opt.optimizeSingleLorentzian(candidates,\n\t                    {x: broadLines[maxI].x, y:max, width: Math.abs(candidates[0][0]-candidates[candidates.length-1][0])});\n\t                peakList.push({x:fitted[0][0],y:fitted[1][0],width:fitted[2][0],soft:false});\n\t\n\t            }\n\t            else{\n\t                //Put back the candidates to the signals list\n\t                indexes.map(function(index){peakList.push(broadLines[index])});\n\t            }\n\t            candidates = [[broadLines[i].x,broadLines[i].y]];\n\t            indexes = [i];\n\t            max = broadLines[i].y;\n\t            maxI = i;\n\t            count = 1;\n\t        }\n\t    }\n\t\n\t    peakList.sort(function (a, b) {\n\t        return a.x - b.x;\n\t    });\n\t\n\t    return peakList;\n\t\n\t}\n\t\n\t/*if(options.broadRatio>0){\n\t var broadLines=[[Number.MAX_VALUE,0,0]];\n\t //Optimize the possible broad lines\n\t var max=0, maxI=0,count=0;\n\t var candidates = [],broadLinesS=[];\n\t var isPartOf = false;\n\t\n\t for(var i=broadLines.length-1;i>0;i--){\n\t //console.log(broadLines[i][0]+\" \"+rangeX+\" \"+Math.abs(broadLines[i-1][0]-broadLines[i][0]));\n\t if(Math.abs(broadLines[i-1][0]-broadLines[i][0])<rangeX){\n\t\n\t candidates.push(broadLines[i]);\n\t if(broadLines[i][1]>max){\n\t max = broadLines[i][1];\n\t maxI = i;\n\t }\n\t count++;\n\t }\n\t else{\n\t isPartOf = true;\n\t if(count>30){ // TODO, an options ?\n\t isPartOf = false;\n\t //for(var j=0;j<signals.length;j++){\n\t //    if(Math.abs(broadLines[maxI][0]-signals[j][0])<rangeX)\n\t //       isPartOf = true;\n\t //    }\n\t //console.log(\"Was part of \"+isPartOf);\n\t }\n\t if(isPartOf){\n\t for(var j=0;j<candidates.length;j++){\n\t signals.push([candidates[j][0], candidates[j][1], dx]);\n\t }\n\t }\n\t else{\n\t var fitted =  Opt.optimizeSingleLorentzian(candidates,{x:candidates[maxI][0],\n\t width:Math.abs(candidates[0][0]-candidates[candidates.length-1][0])},\n\t []);\n\t //console.log(fitted);\n\t signals.push([fitted[0][0],fitted[0][1],fitted[0][2]]);\n\t }\n\t candidates = [];\n\t max = 0;\n\t maxI = 0;\n\t count = 0;\n\t }\n\t }\n\t }*/\n\t\n\tmodule.exports={optimizePeaks:optimizePeaks,joinBroadPeaks:joinBroadPeaks};\n\t\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar LM = __webpack_require__(3);\n\tvar math = LM.Matrix.algebra;\n\tvar Matrix = __webpack_require__(5);\n\t\n\t/**\n\t * This function calculates the spectrum as a sum of lorentzian functions. The Lorentzian\n\t * parameters are divided in 3 batches. 1st: centers; 2nd: heights; 3th: widths;\n\t * @param t Ordinate values\n\t * @param p Lorentzian parameters\n\t * @param c Constant parameters(Not used)\n\t * @returns {*}\n\t */\n\tfunction sumOfLorentzians(t,p,c){\n\t    var nL = p.length/3,factor,i, j,p2, cols = t.rows;\n\t    var result = Matrix.zeros(t.length,1);\n\t\n\t    for(i=0;i<nL;i++){\n\t        p2 = Math.pow(p[i+nL*2][0]/2,2);\n\t        factor = p[i+nL][0]*p2;\n\t        for(j=0;j<cols;j++){\n\t            result[j][0]+=factor/(Math.pow(t[j][0]-p[i][0],2)+p2);\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\t/**\n\t * This function calculates the spectrum as a sum of gaussian functions. The Gaussian\n\t * parameters are divided in 3 batches. 1st: centers; 2nd: height; 3th: std's;\n\t * @param t Ordinate values\n\t * @param p Gaussian parameters\n\t * @param c Constant parameters(Not used)\n\t * @returns {*}\n\t */\n\tfunction sumOfGaussians(t,p,c){\n\t    var nL = p.length/3,factor,i, j, cols = t.rows;\n\t    var result = Matrix.zeros(t.length,1);\n\t\n\t    for(i=0;i<nL;i++){\n\t        factor = p[i+nL*2][0]*p[i+nL*2][0]/2;\n\t        for(j=0;j<cols;j++){\n\t            result[j][0]+=p[i+nL][0]*Math.exp(-(t[i][0]-p[i][0])*(t[i][0]-p[i][0])/factor);\n\t        }\n\t    }\n\t    return result;\n\t}\n\t/**\n\t * Single 4 parameter lorentzian function\n\t * @param t Ordinate values\n\t * @param p Lorentzian parameters\n\t * @param c Constant parameters(Not used)\n\t * @returns {*}\n\t */\n\tfunction singleLorentzian(t,p,c){\n\t    var factor = p[1][0]*Math.pow(p[2][0]/2,2);\n\t    var rows = t.rows;\n\t    var result = new Matrix(t.rows, t.columns);\n\t    for(var i=0;i<rows;i++){\n\t        result[i][0]=factor/(Math.pow(t[i][0]-p[0][0],2)+Math.pow(p[2][0]/2,2));\n\t    }\n\t    return result;\n\t}\n\t\n\t/**\n\t * Single 3 parameter gaussian function\n\t * @param t Ordinate values\n\t * @param p Gaussian parameters [mean, height, std]\n\t * @param c Constant parameters(Not used)\n\t * @returns {*}\n\t */\n\tfunction singleGaussian(t,p,c){\n\t    var factor2 = p[2][0]*p[2][0]/2;\n\t    var rows = t.rows;\n\t    var result = new Matrix(t.rows, t.columns);\n\t    for(var i=0;i<rows;i++){\n\t        result[i][0]=p[1][0]*Math.exp(-(t[i][0]-p[0][0])*(t[i][0]-p[0][0])/factor2);\n\t    }\n\t    return result;\n\t}\n\t\n\t/**\n\t * * Fits a set of points to a Lorentzian function. Returns the center of the peak, the width at half height, and the height of the signal.\n\t * @param data,[y]\n\t * @returns {*[]}\n\t */\n\tfunction optimizeSingleLorentzian(xy, peak, opts) {\n\t    opts = opts || {};\n\t    var xy2 = parseData(xy, opts.percentage||0);\n\t\n\t    if(xy2===null||xy2[0].rows<3){\n\t        return null; //Cannot run an optimization with less than 3 points\n\t    }\n\t\n\t    var t = xy2[0];\n\t    var y_data = xy2[1];\n\t    var maxY = xy2[2];\n\t    var nbPoints = t.rows, i;\n\t\n\t    var weight = [nbPoints / Math.sqrt(y_data.dot(y_data))];\n\t\n\t    var opts=Object.create(opts.LMOptions || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ]);\n\t    //var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];\n\t    var consts = [ ];\n\t    var dt = Math.abs(t[0][0]-t[1][0]);// optional vector of constants\n\t    var dx = new Matrix([[-dt/10000],[-1e-3],[-dt/10000]]);//-Math.abs(t[0][0]-t[1][0])/100;\n\t    var p_init = new Matrix([[peak.x],[1],[peak.width]]);\n\t    var p_min = new Matrix([[peak.x-dt],[0.75],[peak.width/4]]);\n\t    var p_max = new Matrix([[peak.x+dt],[1.25],[peak.width*4]]);\n\t\n\t    var p_fit = LM.optimize(singleLorentzian,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n\t\n\t\n\t    p_fit = p_fit.p;\n\t    return [p_fit[0],[p_fit[1][0]*maxY],p_fit[2]];\n\t\n\t}\n\t\n\t/**\n\t * Fits a set of points to a gaussian bell. Returns the mean of the peak, the std and the height of the signal.\n\t * @param data,[y]\n\t * @returns {*[]}\n\t */\n\tfunction optimizeSingleGaussian(xy, peak, opts) {\n\t    opts = opts || {};\n\t    var xy2 = parseData(xy, opts.percentage||0);\n\t\n\t    if(xy2===null||xy2[0].rows<3){\n\t        return null; //Cannot run an optimization with less than 3 points\n\t    }\n\t\n\t    var t = xy2[0];\n\t    var y_data = xy2[1];\n\t    var maxY = xy2[2];\n\t\n\t    var nbPoints = t.rows, i;\n\t\n\t\n\t\n\t    var weight = [nbPoints / Math.sqrt(y_data.dot(y_data))];\n\t\n\t    var opts=Object.create(opts.LMOptions || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ]);\n\t    //var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];\n\t    var consts = [ ];                         // optional vector of constants\n\t    var dt = Math.abs(t[0][0]-t[1][0]);\n\t    var dx = new Matrix([[-dt/10000],[-1e-3],[-dt/10000]]);//-Math.abs(t[0][0]-t[1][0])/100;\n\t\n\t    var dx = new Matrix([[-Math.abs(t[0][0]-t[1][0])/1000],[-1e-3],[-peak.width/1000]]);\n\t    var p_init = new Matrix([[peak.x],[1],[peak.width]]);\n\t    var p_min = new Matrix([[peak.x-dt],[0.75],[peak.width/4]]);\n\t    var p_max = new Matrix([[peak.x+dt],[1.25],[peak.width*4]]);\n\t    //var p_min = new Matrix([[peak.x-peak.width/4],[0.75],[peak.width/3]]);\n\t    //var p_max = new Matrix([[peak.x+peak.width/4],[1.25],[peak.width*3]]);\n\t\n\t    var p_fit = LM.optimize(singleGaussian,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n\t    p_fit = p_fit.p;\n\t    return [p_fit[0],[p_fit[1][0]*maxY],p_fit[2]];\n\t}\n\t\n\t/*\n\t peaks on group should sorted\n\t */\n\tfunction optimizeLorentzianTrain(xy, group, opts){\n\t    var xy2 = parseData(xy);\n\t    //console.log(xy2[0].rows);\n\t    if(xy2===null||xy2[0].rows<3){\n\t        return null; //Cannot run an optimization with less than 3 points\n\t    }\n\t\n\t    var t = xy2[0];\n\t    var y_data = xy2[1];\n\t    var maxY = xy2[2];\n\t    var currentIndex = 0;\n\t    var nbPoints = t.length;\n\t    var nextX;\n\t    var tI, yI, maxY;\n\t    var result=[], current;\n\t    for(var i=0; i<group.length;i++){\n\t        nextX = group[i].x-group[i].width*4;\n\t        //console.log(group[i]);\n\t        while(t[currentIndex++]<nextX&&currentIndex<nbPoints);\n\t        nextX = group[i].x+group[i].width*4;\n\t        tI = [];\n\t        yI = [];\n\t        while(t[currentIndex]<=nextX&&currentIndex<nbPoints){\n\t            tI.push(t[currentIndex][0]);\n\t            yI.push(y_data[currentIndex][0]*maxY);\n\t            currentIndex++;\n\t        }\n\t\n\t        current=optimizeSingleLorentzian([tI, yI], group[i], opts);\n\t        if(current){\n\t            result.push({\"x\":current[0][0],\"y\":current[1][0],\"width\":current[2][0],\"opt\":true});\n\t        }\n\t        else{\n\t            result.push({\"x\":group[i].x,\"y\":group[i].y,\"width\":group[i].width,\"opt\":false});\n\t        }\n\t    }\n\t\n\t    return result;\n\t\n\t}\n\t\n\tfunction optimizeGaussianTrain(xy, group, opts){\n\t    var xy2 = parseData(xy);\n\t    //console.log(xy2[0].rows);\n\t    if(xy2===null||xy2[0].rows<3){\n\t        return null; //Cannot run an optimization with less than 3 points\n\t    }\n\t\n\t    var t = xy2[0];\n\t    var y_data = xy2[1];\n\t    var maxY = xy2[2];\n\t    var currentIndex = 0;\n\t    var nbPoints = t.length;\n\t    var nextX;\n\t    var tI, yI, maxY;\n\t    var result=[], current;\n\t    for(var i=0; i<group.length;i++){\n\t        nextX = group[i].x-group[i].width*4;\n\t        //console.log(group[i]);\n\t        while(t[currentIndex++]<nextX&&currentIndex<nbPoints);\n\t        nextX = group[i].x+group[i].width*4;\n\t        tI = [];\n\t        yI = [];\n\t        while(t[currentIndex]<=nextX&&currentIndex<nbPoints){\n\t            tI.push(t[currentIndex][0]);\n\t            yI.push(y_data[currentIndex][0]*maxY);\n\t            currentIndex++;\n\t        }\n\t\n\t        current=optimizeSingleGaussian([tI, yI], group[i], opts);\n\t        if(current){\n\t            result.push({\"x\":current[0][0],\"y\":current[1][0],\"width\":current[2][0],\"opt\":true});\n\t        }\n\t        else{\n\t            result.push({\"x\":group[i].x,\"y\":group[i].y,\"width\":group[i].width,\"opt\":false});\n\t        }\n\t    }\n\t\n\t    return result;\n\t}\n\t\n\t\n\t\n\t/**\n\t *\n\t * @param xy A two column matrix containing the x and y data to be fitted\n\t * @param group A set of initial lorentzian parameters to be optimized [center, heigth, half_width_at_half_height]\n\t * @returns {Array} A set of final lorentzian parameters [center, heigth, hwhh*2]\n\t */\n\tfunction optimizeLorentzianSum(xy, group, opts){\n\t    var xy2 = parseData(xy);\n\t\n\t    if(xy2===null||xy2[0].rows<3){\n\t        return null; //Cannot run an optimization with less than 3 points\n\t    }\n\t\n\t    var t = xy2[0];\n\t    var y_data = xy2[1];\n\t    var maxY = xy2[2];\n\t    var nbPoints = t.rows, i;\n\t\n\t    var weight = [nbPoints / math.sqrt(y_data.dot(y_data))];\n\t    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2, 11, 9, 1 ]);\n\t    var consts = [ ];// optional vector of constants\n\t\n\t    var nL = group.length;\n\t    var p_init = new Matrix(nL*3,1);\n\t    var p_min =  new Matrix(nL*3,1);\n\t    var p_max =  new Matrix(nL*3,1);\n\t    var dx = new Matrix(nL*3,1);\n\t    var dt = Math.abs(t[0][0]-t[1][0]);\n\t    for( i=0;i<nL;i++){\n\t        p_init[i][0] = group[i].x;\n\t        p_init[i+nL][0] = 1;\n\t        p_init[i+2*nL][0] = group[i].width;\n\t\n\t        p_min[i][0] = group[i].x-dt;//-group[i].width/4;\n\t        p_min[i+nL][0] = 0;\n\t        p_min[i+2*nL][0] = group[i].width/4;\n\t\n\t        p_max[i][0] = group[i].x+dt;//+group[i].width/4;\n\t        p_max[i+nL][0] = 1.5;\n\t        p_max[i+2*nL][0] = group[i].width*4;\n\t\n\t        dx[i][0] = -dt/1000;\n\t        dx[i+nL][0] = -1e-3;\n\t        dx[i+2*nL][0] = -dt/1000;\n\t    }\n\t\n\t    var dx = -Math.abs(t[0][0]-t[1][0])/10000;\n\t    var p_fit = LM.optimize(sumOfLorentzians, p_init, t, y_data, weight, dx, p_min, p_max, consts, opts);\n\t    p_fit=p_fit.p;\n\t    //Put back the result in the correct format\n\t    var result = new Array(nL);\n\t    for( i=0;i<nL;i++){\n\t        result[i]=[p_fit[i],[p_fit[i+nL][0]*maxY],p_fit[i+2*nL]];\n\t    }\n\t\n\t    return result;\n\t\n\t}\n\t\n\t/**\n\t *\n\t * @param xy A two column matrix containing the x and y data to be fitted\n\t * @param group A set of initial lorentzian parameters to be optimized [center, heigth, half_width_at_half_height]\n\t * @returns {Array} A set of final lorentzian parameters [center, heigth, hwhh*2]\n\t */\n\tfunction optimizeGaussianSum(xy, group, opts){\n\t    var xy2 = parseData(xy);\n\t\n\t    if(xy2===null||xy2[0].rows<3){\n\t        return null; //Cannot run an optimization with less than 3 points\n\t    }\n\t\n\t    var t = xy2[0];\n\t    var y_data = xy2[1];\n\t    var maxY = xy2[2];\n\t    var nbPoints = t.rows,i;\n\t\n\t    var weight = new Matrix(nbPoints,1);//[nbPoints / math.sqrt(y_data.dot(y_data))];\n\t    var k = nbPoints / math.sqrt(y_data.dot(y_data));\n\t    for(i=0;i<nbPoints;i++){\n\t        weight[i][0]=k;///(y_data[i][0]);\n\t        //weight[i][0]=k*(2-y_data[i][0]);\n\t    }\n\t\n\t    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        2 ]);\n\t    //var opts=[  3,    100, 1e-5, 1e-6, 1e-6, 1e-6, 1e-6,    11,    9,        1 ];\n\t    var consts = [ ];// optional vector of constants\n\t\n\t    var nL = group.length;\n\t    var p_init = new Matrix(nL*3,1);\n\t    var p_min =  new Matrix(nL*3,1);\n\t    var p_max =  new Matrix(nL*3,1);\n\t    var dx = new Matrix(nL*3,1);\n\t    var dt = Math.abs(t[0][0]-t[1][0]);\n\t    for( i=0;i<nL;i++){\n\t        p_init[i][0] = group[i].x;\n\t        p_init[i+nL][0] = group[i].y/maxY;\n\t        p_init[i+2*nL][0] = group[i].width;\n\t\n\t        p_min[i][0] = group[i].x-dt;\n\t        p_min[i+nL][0] = group[i].y*0.8/maxY;\n\t        p_min[i+2*nL][0] = group[i].width/2;\n\t\n\t        p_max[i][0] = group[i].x+dt;\n\t        p_max[i+nL][0] = group[i].y*1.2/maxY;\n\t        p_max[i+2*nL][0] = group[i].width*2;\n\t\n\t        dx[i][0] = -dt/1000;\n\t        dx[i+nL][0] = -1e-3;\n\t        dx[i+2*nL][0] = -dt/1000;\n\t    }\n\t    //console.log(t);\n\t    var p_fit = LM.optimize(sumOfLorentzians,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n\t    p_fit = p_fit.p;\n\t    //Put back the result in the correct format\n\t    var result = new Array(nL);\n\t    for( i=0;i<nL;i++){\n\t        result[i]=[p_fit[i],[p_fit[i+nL][0]*maxY],p_fit[i+2*nL]];\n\t    }\n\t\n\t    return result;\n\t\n\t}\n\t/**\n\t *\n\t * Converts the given input to the required x, y column matrices. y data is normalized to max(y)=1\n\t * @param xy\n\t * @returns {*[]}\n\t */\n\tfunction parseData(xy, threshold){\n\t    var nbSeries = xy.length;\n\t    var t = null;\n\t    var y_data = null, x,y;\n\t    var maxY = 0, i,j;\n\t\n\t    if(nbSeries==2){\n\t        //Looks like row wise matrix [x,y]\n\t        var nbPoints = xy[0].length;\n\t        //if(nbPoints<3)\n\t        //    throw new Exception(nbPoints);\n\t        //else{\n\t        t = new Array(nbPoints);//new Matrix(nbPoints,1);\n\t        y_data = new Array(nbPoints);//new Matrix(nbPoints,1);\n\t        x = xy[0];\n\t        y = xy[1];\n\t        if(typeof x[0] === \"number\"){\n\t            for(i=0;i<nbPoints;i++){\n\t                t[i]=x[i];\n\t                y_data[i]=y[i];\n\t                if(y[i]>maxY)\n\t                    maxY = y[i];\n\t            }\n\t        }\n\t        else{\n\t            //It is a colum matrix\n\t            if(typeof x[0] === \"object\"){\n\t                for(i=0;i<nbPoints;i++){\n\t                    t[i]=x[i][0];\n\t                    y_data[i]=y[i][0];\n\t                    if(y[i][0]>maxY)\n\t                        maxY = y[i][0];\n\t                }\n\t            }\n\t\n\t        }\n\t\n\t        //}\n\t    }\n\t    else{\n\t        //Looks like a column wise matrix [[x],[y]]\n\t        var nbPoints = nbSeries;\n\t        //if(nbPoints<3)\n\t        //    throw new SizeException(nbPoints);\n\t        //else {\n\t        t = new Array(nbPoints);//new Matrix(nbPoints, 1);\n\t        y_data = new Array(nbPoints);//new Matrix(nbPoints, 1);\n\t        for (i = 0; i < nbPoints; i++) {\n\t            t[i] = xy[i][0];\n\t            y_data[i] = xy[i][1];\n\t            if(y_data[i]>maxY)\n\t                maxY = y_data[i];\n\t        }\n\t        //}\n\t    }\n\t    for (i = 0; i < nbPoints; i++) {\n\t        y_data[i]/=maxY;\n\t    }\n\t    if(threshold){\n\t        for (i = nbPoints-1; i >=0; i--) {\n\t            if(y_data[i]<threshold) {\n\t                y_data.splice(i,1);\n\t                t.splice(i,1);\n\t            }\n\t        }\n\t    }\n\t    if(t.length>0)\n\t        return [(new Matrix([t])).transpose(),(new Matrix([y_data])).transpose(),maxY];\n\t    return null;\n\t}\n\t\n\tfunction sizeException(nbPoints) {\n\t    return new RangeError(\"Not enough points to perform the optimization: \"+nbPoints +\"< 3\");\n\t}\n\t\n\tmodule.exports.optimizeSingleLorentzian = optimizeSingleLorentzian;\n\tmodule.exports.optimizeLorentzianSum = optimizeLorentzianSum;\n\tmodule.exports.optimizeSingleGaussian = optimizeSingleGaussian;\n\tmodule.exports.optimizeGaussianSum = optimizeGaussianSum;\n\tmodule.exports.singleGaussian = singleGaussian;\n\tmodule.exports.singleLorentzian = singleLorentzian;\n\tmodule.exports.optimizeGaussianTrain = optimizeGaussianTrain;\n\tmodule.exports.optimizeLorentzianTrain = optimizeLorentzianTrain;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(4);\n\tmodule.exports.Matrix = __webpack_require__(5);\n\tmodule.exports.Matrix.algebra = __webpack_require__(14);\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Created by acastillo on 8/5/15.\n\t */\n\tvar Matrix = __webpack_require__(5);\n\tvar math = __webpack_require__(14);\n\t\n\tvar DEBUG = false;\n\t/** Levenberg Marquardt curve-fitting: minimize sum of weighted squared residuals\n\t ----------  INPUT  VARIABLES  -----------\n\t func   = function of n independent variables, 't', and m parameters, 'p',\n\t returning the simulated model: y_hat = func(t,p,c)\n\t p      = n-vector of initial guess of parameter values\n\t t      = m-vectors or matrix of independent variables (used as arg to func)\n\t y_dat  = m-vectors or matrix of data to be fit by func(t,p)\n\t weight = weighting vector for least squares fit ( weight >= 0 ) ...\n\t inverse of the standard measurement errors\n\t Default:  sqrt(d.o.f. / ( y_dat' * y_dat ))\n\t dp     = fractional increment of 'p' for numerical derivatives\n\t dp(j)>0 central differences calculated\n\t dp(j)<0 one sided 'backwards' differences calculated\n\t dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n\t Default:  0.001;\n\t p_min  = n-vector of lower bounds for parameter values\n\t p_max  = n-vector of upper bounds for parameter values\n\t c      = an optional matrix of values passed to func(t,p,c)\n\t opts   = vector of algorithmic parameters\n\t parameter    defaults    meaning\n\t opts(1)  =  prnt            3        >1 intermediate results; >2 plots\n\t opts(2)  =  MaxIter      10*Npar     maximum number of iterations\n\t opts(3)  =  epsilon_1       1e-3     convergence tolerance for gradient\n\t opts(4)  =  epsilon_2       1e-3     convergence tolerance for parameters\n\t opts(5)  =  epsilon_3       1e-3     convergence tolerance for Chi-square\n\t opts(6)  =  epsilon_4       1e-2     determines acceptance of a L-M step\n\t opts(7)  =  lambda_0        1e-2     initial value of L-M paramter\n\t opts(8)  =  lambda_UP_fac   11       factor for increasing lambda\n\t opts(9)  =  lambda_DN_fac    9       factor for decreasing lambda\n\t opts(10) =  Update_Type      1       1: Levenberg-Marquardt lambda update\n\t 2: Quadratic update\n\t 3: Nielsen's lambda update equations\n\t\n\t ----------  OUTPUT  VARIABLES  -----------\n\t p       = least-squares optimal estimate of the parameter values\n\t X2      = Chi squared criteria\n\t sigma_p = asymptotic standard error of the parameters\n\t sigma_y = asymptotic standard error of the curve-fit\n\t corr    = correlation matrix of the parameters\n\t R_sq    = R-squared cofficient of multiple determination\n\t cvg_hst = convergence history\n\t\n\t Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. 22 Sep 2013\n\t modified from: http://octave.sourceforge.net/optim/function/leasqr.html\n\t using references by\n\t Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\t Sam Roweis       http://www.cs.toronto.edu/~roweis/notes/lm.pdf\n\t Manolis Lourakis http://www.ics.forth.gr/~lourakis/levmar/levmar.pdf\n\t Hans Nielson     http://www2.imm.dtu.dk/~hbn/publ/TR9905.ps\n\t Mathworks        optimization toolbox reference manual\n\t K. Madsen, H.B., Nielsen, and O. Tingleff\n\t http://www2.imm.dtu.dk/pubdb/views/edoc_download.php/3215/pdf/imm3215.pdf\n\t */\n\tvar LM = {\n\t\n\t    optimize: function(func,p,t,y_dat,weight,dp,p_min,p_max,c,opts){\n\t\n\t        var tensor_parameter = 0;\t\t\t// set to 1 of parameter is a tensor\n\t\n\t        var iteration  = 0;\t\t\t// iteration counter\n\t        //func_calls = 0;\t\t\t// running count of function evaluations\n\t\n\t        if((typeof p[0])!=\"object\"){\n\t            for(var i=0;i< p.length;i++){\n\t                p[i]=[p[i]];\n\t            }\n\t\n\t        }\n\t        //p = p(:); y_dat = y_dat(:);\t\t// make column vectors\n\t        var i,k;\n\t        var eps = 2^-52;\n\t        var Npar   = p.length;//length(p); \t\t\t// number of parameters\n\t        var Npnt   = y_dat.length;//length(y_dat);\t\t// number of data points\n\t        var p_old  = Matrix.zeros(Npar,1);\t\t// previous set of parameters\n\t        var y_old  = Matrix.zeros(Npnt,1);\t\t// previous model, y_old = y_hat(t;p_old)\n\t        var X2     = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n\t        var X2_old = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n\t        var J =  Matrix.zeros(Npnt,Npar);\n\t\n\t\n\t        if (t.length != y_dat.length) {\n\t            console.log('lm.m error: the length of t must equal the length of y_dat');\n\t\n\t            length_t = t.length;\n\t            length_y_dat = y_dat.length;\n\t            var X2 = 0, corr = 0, sigma_p = 0, sigma_y = 0, R_sq = 0, cvg_hist = 0;\n\t            if (!tensor_parameter) {\n\t                return;\n\t            }\n\t        }\n\t\n\t        weight = weight||Math.sqrt((Npnt-Npar+1)/(math.multiply(math.transpose(y_dat),y_dat)));\n\t        dp = dp || 0.001;\n\t        p_min   = p_min || math.multiply(Math.abs(p),-100);\n\t        p_max   = p_max || math.multiply(Math.abs(p),100);\n\t        c = c || 1;\n\t        // Algorithmic Paramters\n\t        //prnt MaxIter  eps1  eps2  epx3  eps4  lam0  lamUP lamDN UpdateType\n\t        opts = opts ||[  3,10*Npar, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2, 11, 9, 1 ];\n\t\n\t        var prnt          = opts[0];\t// >1 intermediate results; >2 plots\n\t        var MaxIter       = opts[1];\t// maximum number of iterations\n\t        var epsilon_1     = opts[2];\t// convergence tolerance for gradient\n\t        var epsilon_2     = opts[3];\t// convergence tolerance for parameter\n\t        var epsilon_3     = opts[4];\t// convergence tolerance for Chi-square\n\t        var epsilon_4     = opts[5];\t// determines acceptance of a L-M step\n\t        var lambda_0      = opts[6];\t// initial value of damping paramter, lambda\n\t        var lambda_UP_fac = opts[7];\t// factor for increasing lambda\n\t        var lambda_DN_fac = opts[8];\t// factor for decreasing lambda\n\t        var Update_Type   = opts[9];\t// 1: Levenberg-Marquardt lambda update\n\t        // 2: Quadratic update\n\t        // 3: Nielsen's lambda update equations\n\t\n\t        if ( tensor_parameter && prnt == 3 ) prnt = 2;\n\t\n\t\n\t        if(!dp.length || dp.length == 1){\n\t            var dp_array = new Array(Npar);\n\t            for(var i=0;i<Npar;i++)\n\t                dp_array[i]=[dp];\n\t            dp=dp_array;\n\t        }\n\t\n\t        // indices of the parameters to be fit\n\t        var idx   = [];\n\t        for(i=0;i<dp.length;i++){\n\t            if(dp[i][0]!=0){\n\t                idx.push(i);\n\t            }\n\t        }\n\t\n\t        var Nfit = idx.length;\t\t\t// number of parameters to fit\n\t        var stop = false;\t\t\t\t// termination flag\n\t\n\t        var weight_sq = null;\n\t        //console.log(weight);\n\t        if ( !weight.length || weight.length < Npnt )\t{\n\t            // squared weighting vector\n\t            //weight_sq = ( weight(1)*ones(Npnt,1) ).^2;\n\t            //console.log(\"weight[0] \"+typeof weight[0]);\n\t            var tmp = math.multiply(Matrix.ones(Npnt,1),weight[0]);\n\t            weight_sq = math.dotMultiply(tmp,tmp);\n\t        }\n\t        else{\n\t            //weight_sq = (weight(:)).^2;\n\t            weight_sq = math.dotMultiply(weight,weight);\n\t        }\n\t\n\t\n\t        // initialize Jacobian with finite difference calculation\n\t        //console.log(\"J \"+weight_sq);\n\t        var result = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n\t        var JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\t        //[JtWJ,JtWdy,X2,y_hat,J] = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n\t        //console.log(JtWJ);\n\t\n\t        if ( Math.max(Math.abs(JtWdy)) < epsilon_1 ){\n\t            console.log(' *** Your Initial Guess is Extremely Close to Optimal ***')\n\t            console.log(' *** epsilon_1 = ', epsilon_1);\n\t            stop = true;\n\t        }\n\t\n\t\n\t        switch(Update_Type){\n\t            case 1: // Marquardt: init'l lambda\n\t                lambda  = lambda_0;\n\t                break;\n\t            default:    // Quadratic and Nielsen\n\t                lambda  = lambda_0 * Math.max(math.diag(JtWJ));\n\t                nu=2;\n\t        }\n\t        //console.log(X2);\n\t        X2_old = X2; // previous value of X2\n\t        //console.log(MaxIter+\" \"+Npar);\n\t        //var cvg_hst = Matrix.ones(MaxIter,Npar+3);\t\t// initialize convergence history\n\t        var h = null;\n\t        while ( !stop && iteration <= MaxIter ) {\t\t// --- Main Loop\n\t            iteration = iteration + 1;\n\t            // incremental change in parameters\n\t            switch(Update_Type){\n\t                case 1:\t\t\t\t\t// Marquardt\n\t                    //h = ( JtWJ + lambda * math.diag(math.diag(JtWJ)) ) \\ JtWdy;\n\t                    //h = math.multiply(math.inv(JtWdy),math.add(JtWJ,math.multiply(lambda,math.diag(math.diag(Npar)))));\n\t                    h = math.solve(math.add(JtWJ,math.multiply(math.diag(math.diag(JtWJ)),lambda)),JtWdy);\n\t                    break;\n\t                default:\t\t\t\t\t// Quadratic and Nielsen\n\t                    //h = ( JtWJ + lambda * math.eye(Npar) ) \\ JtWdy;\n\t\n\t                    h = math.solve(math.add(JtWJ,math.multiply( Matrix.eye(Npar),lambda)),JtWdy);\n\t            }\n\t\n\t            /*for(var k=0;k< h.length;k++){\n\t             h[k]=[h[k]];\n\t             }*/\n\t            //console.log(\"h \"+h);\n\t            //h=math.matrix(h);\n\t            //  big = max(abs(h./p)) > 2;\n\t            //this is a big step\n\t            // --- Are parameters [p+h] much better than [p] ?\n\t            var hidx = new Array(idx.length);\n\t            for(k=0;k<idx.length;k++){\n\t                hidx[k]=h[idx[k]];\n\t            }\n\t            var p_try = math.add(p, hidx);// update the [idx] elements\n\t\n\t            for(k=0;k<p_try.length;k++){\n\t                p_try[k][0]=Math.min(Math.max(p_min[k][0],p_try[k][0]),p_max[k][0]);\n\t            }\n\t            // p_try = Math.min(Math.max(p_min,p_try),p_max);           // apply constraints\n\t\n\t            var delta_y = math.subtract(y_dat, func(t,p_try,c));       // residual error using p_try\n\t            //func_calls = func_calls + 1;\n\t            //X2_try = delta_y' * ( delta_y .* weight_sq );  // Chi-squared error criteria\n\t\n\t            var X2_try = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n\t\n\t            if ( Update_Type == 2 ){  \t\t\t  // Quadratic\n\t                //    One step of quadratic line update in the h direction for minimum X2\n\t                //var alpha =  JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n\t                var JtWdy_th = math.multiply(math.transpose(JtWdy),h);\n\t                var alpha =  math.multiply(JtWdy_th,math.inv(math.add(math.multiply(math.subtract(X2_try - X2),1/2)),math.multiply(JtWdy_th,2)));//JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n\t\n\t                h = math.multiply(alpha, h);\n\t                for(var k=0;k<idx.length;k++){\n\t                    hidx[k]=h[idx[k]];\n\t                }\n\t\n\t                p_try = math.add(p ,hidx);                     // update only [idx] elements\n\t                p_try = math.min(math.max(p_min,p_try),p_max);          // apply constraints\n\t\n\t                delta_y = math.subtract(y_dat, func(t,p_try,c));      // residual error using p_try\n\t                // func_calls = func_calls + 1;\n\t                //X2_try = delta_y' * ( delta_y .* weight_sq ); // Chi-squared error criteria\n\t                X2_try = math.multiply(math.transpose(delta_y), mat.dotMultiply(delta_y, weight_sq));\n\t            }\n\t\n\t            //rho = (X2 - X2_try) / ( 2*h' * (lambda * h + JtWdy) ); // Nielsen\n\t            var rho = (X2-X2_try)/math.multiply(math.multiply(math.transpose(h),2),math.add(math.multiply(lambda, h),JtWdy));\n\t            //console.log(\"rho \"+rho);\n\t            if ( rho > epsilon_4 ) {\t\t// it IS significantly better\n\t                //console.log(\"Here\");\n\t                dX2 = X2 - X2_old;\n\t                X2_old = X2;\n\t                p_old = p;\n\t                y_old = y_hat;\n\t                p = p_try;\t\t\t// accept p_try\n\t\n\t                result = this.lm_matx(func, t, p_old, y_old, dX2, J, p, y_dat, weight_sq, dp, c);\n\t                JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\t                // decrease lambda ==> Gauss-Newton method\n\t\n\t                switch (Update_Type) {\n\t                    case 1:\t\t\t\t\t\t\t// Levenberg\n\t                        lambda = Math.max(lambda / lambda_DN_fac, 1.e-7);\n\t                        break;\n\t                    case 2:\t\t\t\t\t\t\t// Quadratic\n\t                        lambda = Math.max(lambda / (1 + alpha), 1.e-7);\n\t                        break;\n\t                    case 3:\t\t\t\t\t\t\t// Nielsen\n\t                        lambda = math.multiply(Math.max(1 / 3, 1 - (2 * rho - 1) ^ 3),lambda);\n\t                        nu = 2;\n\t                        break;\n\t                }\n\t            }\n\t            else {\t\t\t\t\t// it IS NOT better\n\t                X2 = X2_old;\t\t\t// do not accept p_try\n\t                if (iteration%(2 * Npar)==0) {\t// rank-1 update of Jacobian\n\t                    result = this.lm_matx(func, t, p_old, y_old, -1, J, p, y_dat, weight_sq, dp, c);\n\t                    JtWJ = result.JtWJ,JtWdy=result.JtWdy,dX2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\t                }\n\t\n\t                // increase lambda  ==> gradient descent method\n\t                switch (Update_Type) {\n\t                    case 1:\t\t\t\t\t\t\t// Levenberg\n\t                        lambda = Math.min(lambda * lambda_UP_fac, 1.e7);\n\t                        break;\n\t                    case 2:\t\t\t\t\t\t\t// Quadratic\n\t                        lambda = lambda + Math.abs((X2_try - X2) / 2 / alpha);\n\t                        break;\n\t                    case 3:\t\t\t\t\t\t// Nielsen\n\t                        lambda = lambda * nu;\n\t                        nu = 2 * nu;\n\t                        break;\n\t                }\n\t            }\n\t        }// --- End of Main Loop\n\t\n\t        // --- convergence achieved, find covariance and confidence intervals\n\t\n\t        // equal weights for paramter error analysis\n\t        weight_sq = math.multiply(math.multiply(math.transpose(delta_y),delta_y), Matrix.ones(Npnt,1));\n\t\n\t        weight_sq.apply(function(i,j){\n\t            weight_sq[i][j] = (Npnt-Nfit+1)/weight_sq[i][j];\n\t        });\n\t        //console.log(weight_sq);\n\t        result = this.lm_matx(func,t,p_old,y_old,-1,J,p,y_dat,weight_sq,dp,c);\n\t        JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\t\n\t        /*if nargout > 2\t\t\t\t// standard error of parameters\n\t         covar = inv(JtWJ);\n\t         sigma_p = sqrt(diag(covar));\n\t         end\n\t\n\t         if nargout > 3\t\t\t\t// standard error of the fit\n\t         //  sigma_y = sqrt(diag(J * covar * J'));\t// slower version of below\n\t         sigma_y = zeros(Npnt,1);\n\t         for i=1:Npnt\n\t         sigma_y(i) = J(i,:) * covar * J(i,:)';\n\t         end\n\t         sigma_y = sqrt(sigma_y);\n\t         end\n\t\n\t         if nargout > 4\t\t\t\t// parameter correlation matrix\n\t         corr = covar ./ [sigma_p*sigma_p'];\n\t         end\n\t\n\t         if nargout > 5\t\t\t\t// coefficient of multiple determination\n\t         R_sq = corrcoef([y_dat y_hat]);\n\t         R_sq = R_sq(1,2).^2;\n\t         end\n\t\n\t         if nargout > 6\t\t\t\t// convergence history\n\t         cvg_hst = cvg_hst(1:iteration,:);\n\t         end*/\n\t\n\t        // endfunction  # ---------------------------------------------------------- LM\n\t\n\t        return { p:p, X2:X2};\n\t    },\n\t\n\t    lm_FD_J:function(func,t,p,y,dp,c) {\n\t        // J = lm_FD_J(func,t,p,y,{dp},{c})\n\t        //\n\t        // partial derivatives (Jacobian) dy/dp for use with lm.m\n\t        // computed via Finite Differences\n\t        // Requires n or 2n function evaluations, n = number of nonzero values of dp\n\t        // -------- INPUT VARIABLES ---------\n\t        // func = function of independent variables, 't', and parameters, 'p',\n\t        //        returning the simulated model: y_hat = func(t,p,c)\n\t        // t  = m-vector of independent variables (used as arg to func)\n\t        // p  = n-vector of current parameter values\n\t        // y  = func(t,p,c) n-vector initialised by user before each call to lm_FD_J\n\t        // dp = fractional increment of p for numerical derivatives\n\t        //      dp(j)>0 central differences calculated\n\t        //      dp(j)<0 one sided differences calculated\n\t        //      dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n\t        //      Default:  0.001;\n\t        // c  = optional vector of constants passed to y_hat = func(t,p,c)\n\t        //---------- OUTPUT VARIABLES -------\n\t        // J  = Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n\t\n\t        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n\t        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n\t        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\t\n\t        var m = y.length;\t\t\t// number of data points\n\t        var n = p.length;\t\t\t// number of parameters\n\t\n\t        dp = dp || math.multiply( Matrix.ones(n, 1), 0.001);\n\t\n\t        var ps = p.clone();//JSON.parse(JSON.stringify(p));\n\t        //var ps = $.extend(true, [], p);\n\t        var J = new Matrix(m,n), del =new Array(n);         // initialize Jacobian to Zero\n\t\n\t        for (var j = 0;j < n; j++) {\n\t            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n\t            del[j] = dp[j]*(1+Math.abs(p[j][0]));  // parameter perturbation\n\t            p[j] = [ps[j][0]+del[j]];\t      // perturb parameter p(j)\n\t            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n\t\n\t            if (del[j] != 0){\n\t                y1 = func(t, p, c);\n\t                //func_calls = func_calls + 1;\n\t                if (dp[j][0] < 0) {\t\t// backwards difference\n\t                    //J(:,j) = math.dotDivide(math.subtract(y1, y),del[j]);//. / del[j];\n\t                    //console.log(del[j]);\n\t                    //console.log(y);\n\t                    var column = math.dotDivide(math.subtract(y1, y),del[j]);\n\t                    for(var k=0;k< m;k++){\n\t                        J[k][j]=column[k][0];\n\t                    }\n\t                    //console.log(column);\n\t                }\n\t                else{\n\t                    p[j][0] = ps[j][0] - del[j];\n\t                    //J(:,j) = (y1 - feval(func, t, p, c)). / (2. * del[j]);\n\t                    var column = math.dotDivide(math.subtract(y1,func(t,p,c)),2*del[j]);\n\t                    for(var k=0;k< m;k++){\n\t                        J[k][j]=column[k][0];\n\t                    }\n\t\n\t                }\t\t\t// central difference, additional func call\n\t            }\n\t\n\t            p[j] = ps[j];\t\t// restore p(j)\n\t\n\t        }\n\t        //console.log(\"lm_FD_J: \"+ JSON.stringify(J));\n\t        return J;\n\t\n\t    },\n\t\n\t    // endfunction # -------------------------------------------------- LM_FD_J\n\t    lm_Broyden_J: function(p_old,y_old,J,p,y){\n\t        // J = lm_Broyden_J(p_old,y_old,J,p,y)\n\t        // carry out a rank-1 update to the Jacobian matrix using Broyden's equation\n\t        //---------- INPUT VARIABLES -------\n\t        // p_old = previous set of parameters\n\t        // y_old = model evaluation at previous set of parameters, y_hat(t;p_old)\n\t        // J  = current version of the Jacobian matrix\n\t        // p     = current  set of parameters\n\t        // y     = model evaluation at current  set of parameters, y_hat(t;p)\n\t        //---------- OUTPUT VARIABLES -------\n\t        // J = rank-1 update to Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n\t        //console.log(p+\" X \"+ p_old)\n\t        var h  = math.subtract(p, p_old);\n\t\n\t        //console.log(\"hhh \"+h);\n\t        var h_t = math.transpose(h);\n\t        h_t.div(math.multiply(h_t,h));\n\t\n\t        //console.log(h_t);\n\t        //J = J + ( y - y_old - J*h )*h' / (h'*h);\t// Broyden rank-1 update eq'n\n\t        J = math.add(J, math.multiply(math.subtract(y, math.add(y_old,math.multiply(J,h))),h_t));\n\t        return J;\n\t        // endfunction # ---------------------------------------------- LM_Broyden_J\n\t    },\n\t\n\t    lm_matx : function (func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,dp,c,iteration){\n\t        // [JtWJ,JtWdy,Chi_sq,y_hat,J] = this.lm_matx(func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,{da},{c})\n\t        //\n\t        // Evaluate the linearized fitting matrix, JtWJ, and vector JtWdy,\n\t        // and calculate the Chi-squared error function, Chi_sq\n\t        // Used by Levenberg-Marquard algorithm, lm.m\n\t        // -------- INPUT VARIABLES ---------\n\t        // func   = function ofpn independent variables, p, and m parameters, p,\n\t        //         returning the simulated model: y_hat = func(t,p,c)\n\t        // t      = m-vectors or matrix of independent variables (used as arg to func)\n\t        // p_old  = n-vector of previous parameter values\n\t        // y_old  = m-vector of previous model ... y_old = y_hat(t;p_old);\n\t        // dX2    = previous change in Chi-squared criteria\n\t        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n\t        // p      = n-vector of current  parameter values\n\t        // y_dat  = n-vector of data to be fit by func(t,p,c)\n\t        // weight_sq = square of the weighting vector for least squares fit ...\n\t        //\t    inverse of the standard measurement errors\n\t        // dp     = fractional increment of 'p' for numerical derivatives\n\t        //          dp(j)>0 central differences calculated\n\t        //          dp(j)<0 one sided differences calculated\n\t        //          dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n\t        //          Default:  0.001;\n\t        // c      = optional vector of constants passed to y_hat = func(t,p,c)\n\t        //---------- OUTPUT VARIABLES -------\n\t        // JtWJ\t = linearized Hessian matrix (inverse of covariance matrix)\n\t        // JtWdy   = linearized fitting vector\n\t        // Chi_sq = Chi-squared criteria: weighted sum of the squared residuals WSSR\n\t        // y_hat  = model evaluated with parameters 'p'\n\t        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n\t\n\t        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n\t        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n\t        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\t\n\t\n\t        var Npnt = y_dat.length;\t\t// number of data points\n\t        var Npar = p.length;\t\t// number of parameters\n\t\n\t        dp = dp || 0.001;\n\t\n\t\n\t        //var JtWJ = new Matrix.zeros(Npar);\n\t        //var JtWdy  = new Matrix.zeros(Npar,1);\n\t\n\t        var y_hat = func(t,p,c);\t// evaluate model using parameters 'p'\n\t        //func_calls = func_calls + 1;\n\t        //console.log(J);\n\t        if ( (iteration%(2*Npar))==0 || dX2 > 0 ) {\n\t            //console.log(\"Par\");\n\t            J = this.lm_FD_J(func, t, p, y_hat, dp, c);\t\t// finite difference\n\t        }\n\t        else{\n\t            //console.log(\"ImPar\");\n\t            J = this.lm_Broyden_J(p_old, y_old, J, p, y_hat); // rank-1 update\n\t        }\n\t        var delta_y = math.subtract(y_dat, y_hat);\t// residual error between model and data\n\t        //console.log(delta_y[0][0]);\n\t        //console.log(delta_y.rows+\" \"+delta_y.columns+\" \"+JSON.stringify(weight_sq));\n\t        //var Chi_sq = delta_y' * ( delta_y .* weight_sq ); \t// Chi-squared error criteria\n\t        var Chi_sq = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n\t        //JtWJ  = J' * ( J .* ( weight_sq * ones(1,Npar) ) );\n\t        var Jt = math.transpose(J);\n\t\n\t        //console.log(weight_sq);\n\t\n\t        var JtWJ = math.multiply(Jt, math.dotMultiply(J,math.multiply(weight_sq, Matrix.ones(1,Npar))));\n\t\n\t        //JtWdy = J' * ( weight_sq .* delta_y );\n\t        var JtWdy = math.multiply(Jt, math.dotMultiply(weight_sq,delta_y));\n\t\n\t\n\t        return {JtWJ:JtWJ,JtWdy:JtWdy,Chi_sq:Chi_sq,y_hat:y_hat,J:J};\n\t        // endfunction  # ------------------------------------------------------ LM_MATX\n\t    }\n\t\n\t\n\t\n\t};\n\t\n\tmodule.exports = LM;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(6);\n\tmodule.exports.Decompositions = module.exports.DC = __webpack_require__(7);\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar Asplice = Array.prototype.splice,\n\t    Aconcat = Array.prototype.concat;\n\t\n\t// For performance : http://jsperf.com/clone-array-slice-vs-while-vs-for\n\tfunction slice(arr) {\n\t    var i = 0,\n\t        ii = arr.length,\n\t        result = new Array(ii);\n\t    for (; i < ii; i++) {\n\t        result[i] = arr[i];\n\t    }\n\t    return result;\n\t}\n\t\n\t/**\n\t * Real matrix.\n\t * @constructor\n\t * @param {number|Array} nRows - Number of rows of the new matrix or a 2D array containing the data.\n\t * @param {number|boolean} [nColumns] - Number of columns of the new matrix or a boolean specifying if the input array should be cloned\n\t */\n\tfunction Matrix(nRows, nColumns) {\n\t    var i = 0, rows, columns, matrix, newInstance;\n\t    if (Array.isArray(nRows)) {\n\t        newInstance = nColumns;\n\t        matrix = newInstance ? slice(nRows) : nRows;\n\t        nRows = matrix.length;\n\t        nColumns = matrix[0].length;\n\t        if (typeof nColumns === 'undefined') {\n\t            throw new TypeError('Data must be a 2D array');\n\t        }\n\t        if (nRows > 0 && nColumns > 0) {\n\t            for (; i < nRows; i++) {\n\t                if (matrix[i].length !== nColumns) {\n\t                    throw new RangeError('Inconsistent array dimensions');\n\t                } else if (newInstance) {\n\t                    matrix[i] = slice(matrix[i]);\n\t                }\n\t            }\n\t        } else {\n\t            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n\t        }\n\t    } else if (typeof nRows === 'number') { // Create empty matrix\n\t        if (nRows > 0 && nColumns > 0) {\n\t            matrix = new Array(nRows);\n\t            for (; i < nRows; i++) {\n\t                matrix[i] = new Array(nColumns);\n\t            }\n\t        } else {\n\t            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n\t        }\n\t    } else {\n\t        throw new TypeError('Invalid arguments');\n\t    }\n\t\n\t    Object.defineProperty(matrix, 'rows', {writable: true, value: nRows});\n\t    Object.defineProperty(matrix, 'columns', {writable: true, value: nColumns});\n\t\n\t    matrix.__proto__ = Matrix.prototype;\n\t\n\t    return matrix;\n\t}\n\t\n\t/**\n\t * Constructs a Matrix with the chosen dimensions from a 1D array.\n\t * @param {number} newRows - Number of rows\n\t * @param {number} newColumns - Number of columns\n\t * @param {Array} newData - A 1D array containing data for the matrix\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.from1DArray = function from1DArray(newRows, newColumns, newData) {\n\t    var length, data, i = 0;\n\t\n\t    length = newRows * newColumns;\n\t    if (length !== newData.length)\n\t        throw new RangeError('Data length does not match given dimensions');\n\t\n\t    data = new Array(newRows);\n\t    for (; i < newRows; i++) {\n\t        data[i] = newData.slice(i * newColumns, (i + 1) * newColumns);\n\t    }\n\t    return new Matrix(data);\n\t};\n\t\n\t/**\n\t * Creates a row vector, a matrix with only one row.\n\t * @param {Array} newData - A 1D array containing data for the vector\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.rowVector = function rowVector(newData) {\n\t    return new Matrix([newData]);\n\t};\n\t\n\t/**\n\t * Creates a column vector, a matrix with only one column.\n\t * @param {Array} newData - A 1D array containing data for the vector\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.columnVector = function columnVector(newData) {\n\t    var l = newData.length, vector = new Array(l);\n\t    for (var i = 0; i < l; i++)\n\t        vector[i] = [newData[i]];\n\t    return new Matrix(vector);\n\t};\n\t\n\t/**\n\t * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.empty = function empty(rows, columns) {\n\t    return new Matrix(rows, columns);\n\t};\n\t\n\t/**\n\t * Creates a matrix with the given dimensions. Values will be set to zero.\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.zeros = function zeros(rows, columns) {\n\t    return Matrix.empty(rows, columns).fill(0);\n\t};\n\t\n\t/**\n\t * Creates a matrix with the given dimensions. Values will be set to one.\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.ones = function ones(rows, columns) {\n\t    return Matrix.empty(rows, columns).fill(1);\n\t};\n\t\n\t/**\n\t * Creates a matrix with the given dimensions. Values will be randomly set using Math.random().\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} The new matrix\n\t */\n\tMatrix.rand = function rand(rows, columns) {\n\t    var matrix = Matrix.empty(rows, columns);\n\t    for (var i = 0, ii = matrix.rows; i < ii; i++) {\n\t        for (var j = 0, jj = matrix.columns; j < jj; j++) {\n\t            matrix[i][j] = Math.random();\n\t        }\n\t    }\n\t    return matrix;\n\t};\n\t\n\t/**\n\t * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and other will be 0.\n\t * @param {number} n - Number of rows and columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.eye = function eye(n) {\n\t    var matrix = Matrix.zeros(n, n), l = matrix.rows;\n\t    for (var i = 0; i < l; i++) {\n\t        matrix[i][i] = 1;\n\t    }\n\t    return matrix;\n\t};\n\t\n\t/**\n\t * Creates a diagonal matrix based on the given array.\n\t * @param {Array} data - Array containing the data for the diagonal\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.diag = function diag(data) {\n\t    var l = data.length, matrix = Matrix.zeros(l, l);\n\t    for (var i = 0; i < l; i++) {\n\t        matrix[i][i] = data[i];\n\t    }\n\t    return matrix;\n\t};\n\t\n\t/**\n\t * Creates an array of indices between two values\n\t * @param {number} from\n\t * @param {number} to\n\t * @returns {Array}\n\t */\n\tMatrix.indices = function indices(from, to) {\n\t    var vector = new Array(to - from);\n\t    for (var i = 0; i < vector.length; i++)\n\t        vector[i] = from++;\n\t    return vector;\n\t};\n\t\n\t// TODO DOC\n\tMatrix.stack = function stack(arg1) {\n\t    var i, j, k;\n\t    if (Matrix.isMatrix(arg1)) {\n\t        var rows = 0,\n\t            cols = 0;\n\t        for (i = 0; i < arguments.length; i++) {\n\t            rows += arguments[i].rows;\n\t            if (arguments[i].columns > cols)\n\t                cols = arguments[i].columns;\n\t        }\n\t\n\t        var r = Matrix.zeros(rows, cols);\n\t        var c = 0;\n\t        for (i = 0; i < arguments.length; i++) {\n\t            var current = arguments[i];\n\t            for (j = 0; j < current.rows; j++) {\n\t                for (k = 0; k < current.columns; k++)\n\t                    r[c][k] = current[j][k];\n\t                c++;\n\t            }\n\t        }\n\t        return r;\n\t    }\n\t    else if (Array.isArray(arg1)) {\n\t        var matrix = Matrix.empty(arguments.length, arg1.length);\n\t        for (i = 0; i < arguments.length; i++)\n\t            matrix.setRow(i, arguments[i]);\n\t        return matrix;\n\t    }\n\t};\n\t\n\t// TODO DOC\n\tMatrix.expand = function expand(base, count) {\n\t    var expansion = [];\n\t    for (var i = 0; i < count.length; i++)\n\t        for (var j = 0; j < count[i]; j++)\n\t            expansion.push(base[i]);\n\t    return new Matrix(expansion);\n\t};\n\t\n\t/**\n\t * Check that the provided value is a Matrix and tries to instantiate one if not\n\t * @param value - The value to check\n\t * @returns {Matrix}\n\t * @throws {TypeError}\n\t */\n\tMatrix.checkMatrix = function checkMatrix(value) {\n\t    if (!value) {\n\t        throw new TypeError('Argument has to be a matrix');\n\t    }\n\t    if (value.klass !== 'Matrix') {\n\t        value = new Matrix(value);\n\t    }\n\t    return value;\n\t};\n\t\n\t/**\n\t * Returns true if the argument is a Matrix, false otherwise\n\t * @param value - The value to check\n\t * @returns {boolean}\n\t */\n\tMatrix.isMatrix = function isMatrix(value) {\n\t    return value ? value.klass === 'Matrix' : false;\n\t};\n\t\n\t/**\n\t * @property {string} - The name of this class.\n\t */\n\tObject.defineProperty(Matrix.prototype, 'klass', {\n\t    get: function klass() {\n\t        return 'Matrix';\n\t    }\n\t});\n\t\n\t/**\n\t * @property {number} - The number of elements in the matrix.\n\t */\n\tObject.defineProperty(Matrix.prototype, 'size', {\n\t    get: function size() {\n\t        return this.rows * this.columns;\n\t    }\n\t});\n\t\n\t/**\n\t * @private\n\t * Internal check that a row index is not out of bounds\n\t * @param {number} index\n\t */\n\tMatrix.prototype.checkRowIndex = function checkRowIndex(index) {\n\t    if (index < 0 || index > this.rows - 1)\n\t        throw new RangeError('Row index out of range.');\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that a column index is not out of bounds\n\t * @param {number} index\n\t */\n\tMatrix.prototype.checkColumnIndex = function checkColumnIndex(index) {\n\t    if (index < 0 || index > this.columns - 1)\n\t        throw new RangeError('Column index out of range.');\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that two matrices have the same dimensions\n\t * @param {Matrix} otherMatrix\n\t */\n\tMatrix.prototype.checkDimensions = function checkDimensions(otherMatrix) {\n\t    if ((this.rows !== otherMatrix.rows) || (this.columns !== otherMatrix.columns))\n\t        throw new RangeError('Matrices dimensions must be equal.');\n\t};\n\t\n\t/**\n\t * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.\n\t * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.apply = function apply(callback) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            callback.call(this, i, j);\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Creates an exact and independent copy of the matrix\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.clone = function clone() {\n\t    return new Matrix(this.to2DArray());\n\t};\n\t\n\t/**\n\t * Returns a new 1D array filled row by row with the matrix values\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.to1DArray = function to1DArray() {\n\t    return Aconcat.apply([], this);\n\t};\n\t\n\t/**\n\t * Returns a 2D array containing a copy of the data\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.to2DArray = function to2DArray() {\n\t    var l = this.rows, copy = new Array(l);\n\t    for (var i = 0; i < l; i++) {\n\t        copy[i] = slice(this[i]);\n\t    }\n\t    return copy;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has one row\n\t */\n\tMatrix.prototype.isRowVector = function isRowVector() {\n\t    return this.rows === 1;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has one column\n\t */\n\tMatrix.prototype.isColumnVector = function isColumnVector() {\n\t    return this.columns === 1;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has one row or one column\n\t */\n\tMatrix.prototype.isVector = function isVector() {\n\t    return (this.rows === 1) || (this.columns === 1);\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has the same number of rows and columns\n\t */\n\tMatrix.prototype.isSquare = function isSquare() {\n\t    return this.rows === this.columns;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix is square and has the same values on both sides of the diagonal\n\t */\n\tMatrix.prototype.isSymmetric = function isSymmetric() {\n\t    if (this.isSquare()) {\n\t        var l = this.rows;\n\t        for (var i = 0; i < l; i++) {\n\t            for (var j = 0; j <= i; j++) {\n\t                if (this[i][j] !== this[j][i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t};\n\t\n\t/**\n\t * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1\n\t * @param {number} rowIndex - Index of the row\n\t * @param {number} columnIndex - Index of the column\n\t * @param {number} value - The new value for the element\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.set = function set(rowIndex, columnIndex, value) {\n\t    this[rowIndex][columnIndex] = value;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]\n\t * @param {number} rowIndex - Index of the row\n\t * @param {number} columnIndex - Index of the column\n\t * @returns {number}\n\t */\n\tMatrix.prototype.get = function get(rowIndex, columnIndex) {\n\t    return this[rowIndex][columnIndex];\n\t};\n\t\n\t/**\n\t * Fills the matrix with a given value. All elements will be set to this value.\n\t * @param {number} value - New value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.fill = function fill(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] = value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Negates the matrix. All elements will be multiplied by (-1)\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.neg = function neg() {\n\t    return this.mulS(-1);\n\t};\n\t\n\t/**\n\t * Adds a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.add = function add(value) {\n\t    if (typeof value === 'number')\n\t        return this.addS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.addM(value);\n\t};\n\t\n\t/**\n\t * Adds a scalar to each element of the matrix\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addS = function addS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds the value of each element of matrix to the corresponding element of this\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addM = function addM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.sub = function sub(value) {\n\t    if (typeof value === 'number')\n\t        return this.subS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.subM(value);\n\t};\n\t\n\t/**\n\t * Subtracts a scalar from each element of the matrix\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subS = function subS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts the value of each element of matrix from the corresponding element of this\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subM = function subM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mul = function mul(value) {\n\t    if (typeof value === 'number')\n\t        return this.mulS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.mulM(value);\n\t};\n\t\n\t/**\n\t * Multiplies a scalar with each element of the matrix\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulS = function mulS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the value of each element of matrix with the corresponding element of this\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulM = function mulM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides by a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.div = function div(value) {\n\t    if (typeof value === 'number')\n\t        return this.divS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.divM(value);\n\t};\n\t\n\t/**\n\t * Divides each element of the matrix by a scalar\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divS = function divS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides each element of this by the corresponding element of matrix\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divM = function divM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Returns a new array from the given row index\n\t * @param {number} index - Row index\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.getRow = function getRow(index) {\n\t    this.checkRowIndex(index);\n\t    return slice(this[index]);\n\t};\n\t\n\t/**\n\t * Returns a new row vector from the given row index\n\t * @param {number} index - Row index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.getRowVector = function getRowVector(index) {\n\t    return Matrix.rowVector(this.getRow(index));\n\t};\n\t\n\t/**\n\t * Sets a row at the given index\n\t * @param {number} index - Row index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.setRow = function setRow(index, array) {\n\t    this.checkRowIndex(index);\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    if (array.length !== this.columns)\n\t        throw new RangeError('Invalid row size');\n\t    this[index] = slice(array);\n\t    return this;\n\t};\n\t\n\t/**\n\t * Removes a row from the given index\n\t * @param {number} index - Row index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.removeRow = function removeRow(index) {\n\t    this.checkRowIndex(index);\n\t    if (this.rows === 1)\n\t        throw new RangeError('A matrix cannot have less than one row');\n\t    Asplice.call(this, index, 1);\n\t    this.rows -= 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds a row at the given index\n\t * @param {number} [index = this.rows] - Row index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addRow = function addRow(index, array) {\n\t    if (typeof array === 'undefined') {\n\t        array = index;\n\t        index = this.rows;\n\t    }\n\t    if (index < 0 || index > this.rows)\n\t        throw new RangeError('Row index out of range.');\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    if (array.length !== this.columns)\n\t        throw new RangeError('Invalid row size');\n\t    Asplice.call(this, index, 0, slice(array));\n\t    this.rows += 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Swaps two rows\n\t * @param {number} row1 - First row index\n\t * @param {number} row2 - Second row index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.swapRows = function swapRows(row1, row2) {\n\t    this.checkRowIndex(row1);\n\t    this.checkRowIndex(row2);\n\t    var temp = this[row1];\n\t    this[row1] = this[row2];\n\t    this[row2] = temp;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Returns a new array from the given column index\n\t * @param {number} index - Column index\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.getColumn = function getColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    var l = this.rows, column = new Array(l);\n\t    for (var i = 0; i < l; i++) {\n\t        column[i] = this[i][index];\n\t    }\n\t    return column;\n\t};\n\t\n\t/**\n\t * Returns a new column vector from the given column index\n\t * @param {number} index - Column index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.getColumnVector = function getColumnVector(index) {\n\t    return Matrix.columnVector(this.getColumn(index));\n\t};\n\t\n\t/**\n\t * Sets a column at the given index\n\t * @param {number} index - Column index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.setColumn = function setColumn(index, array) {\n\t    this.checkColumnIndex(index);\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    var l = this.rows;\n\t    if (array.length !== l)\n\t        throw new RangeError('Invalid column size');\n\t    for (var i = 0; i < l; i++) {\n\t        this[i][index] = array[i];\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Removes a column from the given index\n\t * @param {number} index - Column index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.removeColumn = function removeColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    if (this.columns === 1)\n\t        throw new RangeError('A matrix cannot have less than one column');\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        this[i].splice(index, 1);\n\t    }\n\t    this.columns -= 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds a column at the given index\n\t * @param {number} [index = this.columns] - Column index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addColumn = function addColumn(index, array) {\n\t    if (typeof array === 'undefined') {\n\t        array = index;\n\t        index = this.columns;\n\t    }\n\t    if (index < 0 || index > this.columns)\n\t        throw new RangeError('Column index out of range.');\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    var l = this.rows;\n\t    if (array.length !== l)\n\t        throw new RangeError('Invalid column size');\n\t    for (var i = 0; i < l; i++) {\n\t        this[i].splice(index, 0, array[i]);\n\t    }\n\t    this.columns += 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Swaps two columns\n\t * @param {number} column1 - First column index\n\t * @param {number} column2 - Second column index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.swapColumns = function swapColumns(column1, column2) {\n\t    this.checkRowIndex(column1);\n\t    this.checkRowIndex(column2);\n\t    var l = this.rows, temp, row;\n\t    for (var i = 0; i < l; i++) {\n\t        row = this[i];\n\t        temp = row[column1];\n\t        row[column1] = row[column2];\n\t        row[column2] = temp;\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that the provided vector is an array with the right length\n\t * @param {Array|Matrix} vector\n\t * @returns {Array}\n\t * @throws {RangeError}\n\t */\n\tMatrix.prototype.checkRowVector = function checkRowVector(vector) {\n\t    if (Matrix.isMatrix(vector))\n\t        vector = vector.to1DArray();\n\t    if (vector.length !== this.columns)\n\t        throw new RangeError('vector size must be the same as the number of columns');\n\t    return vector;\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that the provided vector is an array with the right length\n\t * @param {Array|Matrix} vector\n\t * @returns {Array}\n\t * @throws {RangeError}\n\t */\n\tMatrix.prototype.checkColumnVector = function checkColumnVector(vector) {\n\t    if (Matrix.isMatrix(vector))\n\t        vector = vector.to1DArray();\n\t    if (vector.length !== this.rows)\n\t        throw new RangeError('vector size must be the same as the number of rows');\n\t    return vector;\n\t};\n\t\n\t/**\n\t * Adds the values of a vector to each row\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addRowVector = function addRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts the values of a vector from each row\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subRowVector = function subRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a vector with each row\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulRowVector = function mulRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides the values of each row by those of a vector\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divRowVector = function divRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds the values of a vector to each column\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addColumnVector = function addColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts the values of a vector from each column\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subColumnVector = function subColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a vector with each column\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulColumnVector = function mulColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides the values of each column by those of a vector\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divColumnVector = function divColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a row with a scalar\n\t * @param {number} index - Row index\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulRow = function mulRow(index, value) {\n\t    this.checkRowIndex(index);\n\t    var i = 0, l = this.columns;\n\t    for (; i < l; i++) {\n\t        this[index][i] *= value;\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a column with a scalar\n\t * @param {number} index - Column index\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulColumn = function mulColumn(index, value) {\n\t    this.checkColumnIndex(index);\n\t    var i = 0, l = this.rows;\n\t    for (; i < l; i++) {\n\t        this[i][index] *= value;\n\t    }\n\t};\n\t\n\t/**\n\t * A matrix index\n\t * @typedef {Object} MatrixIndex\n\t * @property {number} row\n\t * @property {number} column\n\t */\n\t\n\t/**\n\t * Returns the maximum value of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.max = function max() {\n\t    var v = -Infinity;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] > v) {\n\t                v = this[i][j];\n\t            }\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.maxIndex = function maxIndex() {\n\t    var v = -Infinity;\n\t    var idx = {};\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] > v) {\n\t                v = this[i][j];\n\t                idx.row = i;\n\t                idx.column = j;\n\t            }\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the minimum value of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.min = function min() {\n\t    var v = Infinity;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] < v) {\n\t                v = this[i][j];\n\t            }\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the minimum value\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.minIndex = function minIndex() {\n\t    var v = Infinity;\n\t    var idx = {};\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] < v) {\n\t                v = this[i][j];\n\t                idx.row = i;\n\t                idx.column = j;\n\t            }\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the maximum value of one row\n\t * @param {number} index - Row index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.maxRow = function maxRow(index) {\n\t    this.checkRowIndex(index);\n\t    var v = -Infinity;\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] > v) {\n\t            v = this[index][i];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value of one row\n\t * @param {number} index - Row index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.maxRowIndex = function maxRowIndex(index) {\n\t    this.checkRowIndex(index);\n\t    var v = -Infinity;\n\t    var idx = {\n\t            row: index\n\t        };\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] > v) {\n\t            v = this[index][i];\n\t            idx.column = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the minimum value of one row\n\t * @param {number} index - Row index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.minRow = function minRow(index) {\n\t    this.checkRowIndex(index);\n\t    var v = Infinity;\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] < v) {\n\t            v = this[index][i];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value of one row\n\t * @param {number} index - Row index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.minRowIndex = function minRowIndex(index) {\n\t    this.checkRowIndex(index);\n\t    var v = Infinity;\n\t    var idx = {\n\t        row: index,\n\t        column: 0\n\t    };\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] < v) {\n\t            v = this[index][i];\n\t            idx.column = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the maximum value of one column\n\t * @param {number} index - Column index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.maxColumn = function maxColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = -Infinity;\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] > v) {\n\t            v = this[i][index];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value of one column\n\t * @param {number} index - Column index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.maxColumnIndex = function maxColumnIndex(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = -Infinity;\n\t    var idx = {\n\t        row: 0,\n\t        column: index\n\t    };\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] > v) {\n\t            v = this[i][index];\n\t            idx.row = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the minimum value of one column\n\t * @param {number} index - Column index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.minColumn = function minColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = Infinity;\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] < v) {\n\t            v = this[i][index];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the minimum value of one column\n\t * @param {number} index - Column index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.minColumnIndex = function minColumnIndex(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = Infinity;\n\t    var idx = {\n\t        row: 0,\n\t        column: index\n\t    };\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] < v) {\n\t            v = this[i][index];\n\t            idx.row = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns an array containing the diagonal values of the matrix\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.diag = function diag() {\n\t    if (!this.isSquare())\n\t        throw new TypeError('Only square matrices have a diagonal.');\n\t    var diag = new Array(this.rows);\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        diag[i] = this[i][i];\n\t    }\n\t    return diag;\n\t};\n\t\n\t/**\n\t * Returns the sum of all elements of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.sum = function sum() {\n\t    var v = 0;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            v += this[i][j];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the mean of all elements of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.mean = function mean() {\n\t    return this.sum() / this.size;\n\t};\n\t\n\t/**\n\t * Returns the product of all elements of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.prod = function prod() {\n\t    var prod = 1;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            prod *= this[i][j];\n\t        }\n\t    }\n\t    return prod;\n\t};\n\t\n\t/**\n\t * Computes the cumulative sum of the matrix elements (in place, row by row)\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.cumulativeSum = function cumulativeSum() {\n\t    var sum = 0;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            sum += this[i][j];\n\t            this[i][j] = sum;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Computes the dot (scalar) product between the matrix and another\n\t * @param {Matrix} other vector\n\t * @returns {number}\n\t */\n\tMatrix.prototype.dot = function dot(other) {\n\t    if (this.size !== other.size)\n\t        throw new RangeError('vectors do not have the same size');\n\t    var vector1 = this.to1DArray();\n\t    var vector2 = other.to1DArray();\n\t    var dot = 0, l = vector1.length;\n\t    for (var i = 0; i < l; i++) {\n\t        dot += vector1[i] * vector2[i];\n\t    }\n\t    return dot;\n\t};\n\t\n\t/**\n\t * Returns the matrix product between this and other\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.mmul = function mmul(other) {\n\t    if (!Matrix.isMatrix(other))\n\t        throw new TypeError('parameter \"other\" must be a matrix');\n\t    if (this.columns !== other.rows)\n\t        console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');\n\t\n\t    var m = this.rows, n = this.columns, p = other.columns;\n\t    var result = new Matrix(m, p);\n\t\n\t    var Bcolj = new Array(n);\n\t    var i, j, k;\n\t    for (j = 0; j < p; j++) {\n\t        for (k = 0; k < n; k++)\n\t            Bcolj[k] = other[k][j];\n\t\n\t        for (i = 0; i < m; i++) {\n\t            var Arowi = this[i];\n\t\n\t            var s = 0;\n\t            for (k = 0; k < n; k++)\n\t                s += Arowi[k] * Bcolj[k];\n\t\n\t            result[i][j] = s;\n\t        }\n\t    }\n\t    return result;\n\t};\n\t\n\t/**\n\t * Sorts the rows (in place)\n\t * @param {function} compareFunction - usual Array.prototype.sort comparison function\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.sortRows = function sortRows(compareFunction) {\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        this[i].sort(compareFunction);\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Sorts the columns (in place)\n\t * @param {function} compareFunction - usual Array.prototype.sort comparison function\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.sortColumns = function sortColumns(compareFunction) {\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        this.setColumn(i, this.getColumn(i).sort(compareFunction));\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Transposes the matrix and returns a new one containing the result\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.transpose = function transpose() {\n\t    var result = new Matrix(this.columns, this.rows);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[j][i] = this[i][j];\n\t        }\n\t    }\n\t    return result;\n\t};\n\t\n\t/**\n\t * Returns a subset of the matrix\n\t * @param {number} startRow - First row index\n\t * @param {number} endRow - Last row index\n\t * @param {number} startColumn - First column index\n\t * @param {number} endColumn - Last column index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.subMatrix = function subMatrix(startRow, endRow, startColumn, endColumn) {\n\t    if ((startRow > endRow) || (startColumn > endColumn) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n\t        throw new RangeError('Argument out of range');\n\t    var newMatrix = new Matrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\t    for (var i = startRow; i <= endRow; i++) {\n\t        for (var j = startColumn; j <= endColumn; j++) {\n\t            newMatrix[i - startRow][j - startColumn] = this[i][j];\n\t        }\n\t    }\n\t    return newMatrix;\n\t};\n\t\n\t/**\n\t * Returns a subset of the matrix based on an array of row indices\n\t * @param {Array} indices - Array containing the row indices\n\t * @param {number} [startColumn = 0] - First column index\n\t * @param {number} [endColumn = this.columns-1] - Last column index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.subMatrixRow = function subMatrixRow(indices, startColumn, endColumn) {\n\t    if (typeof startColumn === 'undefined') {\n\t        startColumn = 0;\n\t        endColumn = this.columns - 1;\n\t    } else if (typeof endColumn === 'undefined') {\n\t        endColumn = this.columns - 1;\n\t    }\n\t    if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n\t        throw new RangeError('Argument out of range.');\n\t    var l = indices.length, rows = this.rows,\n\t        X = new Matrix(l, endColumn - startColumn + 1);\n\t    for (var i = 0; i < l; i++) {\n\t        for (var j = startColumn; j <= endColumn; j++) {\n\t            if ((indices[i] < 0) || (indices[i] >= rows))\n\t                throw new RangeError('Argument out of range.');\n\t            X[i][j - startColumn] = this[indices[i]][j];\n\t        }\n\t    }\n\t    return X;\n\t};\n\t\n\t/**\n\t * Returns a subset of the matrix based on an array of column indices\n\t * @param {Array} indices - Array containing the column indices\n\t * @param {number} [startRow = 0] - First row index\n\t * @param {number} [endRow = this.rows-1] - Last row index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.subMatrixColumn = function subMatrixColumn(indices, startRow, endRow) {\n\t    if (typeof startRow === 'undefined') {\n\t        startRow = 0;\n\t        endRow = this.rows - 1;\n\t    } else if (typeof endRow === 'undefined') {\n\t        endRow = this.rows - 1;\n\t    }\n\t    if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows))\n\t        throw new RangeError('Argument out of range.');\n\t    var l = indices.length, columns = this.columns,\n\t        X = new Matrix(endRow - startRow + 1, l);\n\t    for (var i = 0; i < l; i++) {\n\t        for (var j = startRow; j <= endRow; j++) {\n\t            if ((indices[i] < 0) || (indices[i] >= columns))\n\t                throw new RangeError('Argument out of range.');\n\t            X[j - startRow][i] = this[j][indices[i]];\n\t        }\n\t    }\n\t    return X;\n\t};\n\t\n\t/**\n\t * Returns the trace of the matrix (sum of the diagonal elements)\n\t * @returns {number}\n\t */\n\tMatrix.prototype.trace = function trace() {\n\t    if (!this.isSquare())\n\t        throw new TypeError('The matrix is not square');\n\t    var trace = 0, i = 0, l = this.rows;\n\t    for (; i < l; i++) {\n\t        trace += this[i][i];\n\t    }\n\t    return trace;\n\t};\n\t\n\t/**\n\t * Sets each element of the matrix to its absolute value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.abs = function abs() {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] = Math.abs(this[i][j]);\n\t        }\n\t    }\n\t};\n\t\n\tmodule.exports = Matrix;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(6);\n\t\n\tvar SingularValueDecomposition = __webpack_require__(8);\n\tvar EigenvalueDecomposition = __webpack_require__(10);\n\tvar LuDecomposition = __webpack_require__(11);\n\tvar QrDecomposition = __webpack_require__(12);\n\tvar CholeskyDecomposition = __webpack_require__(13);\n\t\n\tfunction inverse(matrix) {\n\t    return solve(matrix, Matrix.eye(matrix.rows));\n\t}\n\t\n\tMatrix.prototype.inverse = function () {\n\t    return inverse(this);\n\t};\n\t\n\tfunction solve(leftHandSide, rightHandSide) {\n\t    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);\n\t}\n\t\n\tMatrix.prototype.solve = function (other) {\n\t    return solve(this, other);\n\t};\n\t\n\tmodule.exports = {\n\t    SingularValueDecomposition: SingularValueDecomposition,\n\t    SVD: SingularValueDecomposition,\n\t    EigenvalueDecomposition: EigenvalueDecomposition,\n\t    EVD: EigenvalueDecomposition,\n\t    LuDecomposition: LuDecomposition,\n\t    LU: LuDecomposition,\n\t    QrDecomposition: QrDecomposition,\n\t    QR: QrDecomposition,\n\t    CholeskyDecomposition: CholeskyDecomposition,\n\t    CHO: CholeskyDecomposition,\n\t    inverse: inverse,\n\t    solve: solve\n\t};\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(6);\n\tvar hypotenuse = __webpack_require__(9).hypotenuse;\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/SingularValueDecomposition.cs\n\tfunction SingularValueDecomposition(value, options) {\n\t    if (!(this instanceof SingularValueDecomposition)) {\n\t        return new SingularValueDecomposition(value, options);\n\t    }\n\t    value = Matrix.checkMatrix(value);\n\t\n\t    options = options || {};\n\t\n\t    var a = value.clone(),\n\t        m = value.rows,\n\t        n = value.columns,\n\t        nu = Math.min(m, n);\n\t\n\t    var wantu = true, wantv = true;\n\t    if (options.computeLeftSingularVectors === false)\n\t        wantu = false;\n\t    if (options.computeRightSingularVectors === false)\n\t        wantv = false;\n\t    var autoTranspose = options.autoTranspose === true;\n\t\n\t    var swapped = false;\n\t    if (m < n) {\n\t        if (!autoTranspose) {\n\t            console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose');\n\t        } else {\n\t            a = a.transpose();\n\t            m = a.rows;\n\t            n = a.columns;\n\t            swapped = true;\n\t            var aux = wantu;\n\t            wantu = wantv;\n\t            wantv = aux;\n\t        }\n\t    }\n\t\n\t    var s = new Array(Math.min(m + 1, n)),\n\t        U = Matrix.zeros(m, nu),\n\t        V = Matrix.zeros(n, n),\n\t        e = new Array(n),\n\t        work = new Array(m);\n\t\n\t    var nct = Math.min(m - 1, n);\n\t    var nrt = Math.max(0, Math.min(n - 2, m));\n\t\n\t    var i, j, k, p, t, ks, f, cs, sn, max, kase,\n\t        scale, sp, spm1, epm1, sk, ek, b, c, shift, g;\n\t\n\t    for (k = 0, max = Math.max(nct, nrt); k < max; k++) {\n\t        if (k < nct) {\n\t            s[k] = 0;\n\t            for (i = k; i < m; i++) {\n\t                s[k] = hypotenuse(s[k], a[i][k]);\n\t            }\n\t            if (s[k] !== 0) {\n\t                if (a[k][k] < 0) {\n\t                    s[k] = -s[k];\n\t                }\n\t                for (i = k; i < m; i++) {\n\t                    a[i][k] /= s[k];\n\t                }\n\t                a[k][k] += 1;\n\t            }\n\t            s[k] = -s[k];\n\t        }\n\t\n\t        for (j = k + 1; j < n; j++) {\n\t            if ((k < nct) && (s[k] !== 0)) {\n\t                t = 0;\n\t                for (i = k; i < m; i++) {\n\t                    t += a[i][k] * a[i][j];\n\t                }\n\t                t = -t / a[k][k];\n\t                for (i = k; i < m; i++) {\n\t                    a[i][j] += t * a[i][k];\n\t                }\n\t            }\n\t            e[j] = a[k][j];\n\t        }\n\t\n\t        if (wantu && (k < nct)) {\n\t            for (i = k; i < m; i++) {\n\t                U[i][k] = a[i][k];\n\t            }\n\t        }\n\t\n\t        if (k < nrt) {\n\t            e[k] = 0;\n\t            for (i = k + 1; i < n; i++) {\n\t                e[k] = hypotenuse(e[k], e[i]);\n\t            }\n\t            if (e[k] !== 0) {\n\t                if (e[k + 1] < 0)\n\t                    e[k] = -e[k];\n\t                for (i = k + 1; i < n; i++) {\n\t                    e[i] /= e[k];\n\t                }\n\t                e[k + 1] += 1;\n\t            }\n\t            e[k] = -e[k];\n\t            if ((k + 1 < m) && (e[k] !== 0)) {\n\t                for (i = k + 1; i < m; i++) {\n\t                    work[i] = 0;\n\t                }\n\t                for (j = k + 1; j < n; j++) {\n\t                    for (i = k + 1; i < m; i++) {\n\t                        work[i] += e[j] * a[i][j];\n\t                    }\n\t                }\n\t                for (j = k + 1; j < n; j++) {\n\t                    t = -e[j] / e[k + 1];\n\t                    for (i = k + 1; i < m; i++) {\n\t                        a[i][j] += t * work[i];\n\t                    }\n\t                }\n\t            }\n\t            if (wantv) {\n\t                for (i = k + 1; i < n; i++) {\n\t                    V[i][k] = e[i];\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    p = Math.min(n, m + 1);\n\t    if (nct < n) {\n\t        s[nct] = a[nct][nct];\n\t    }\n\t    if (m < p) {\n\t        s[p - 1] = 0;\n\t    }\n\t    if (nrt + 1 < p) {\n\t        e[nrt] = a[nrt][p - 1];\n\t    }\n\t    e[p - 1] = 0;\n\t\n\t    if (wantu) {\n\t        for (j = nct; j < nu; j++) {\n\t            for (i = 0; i < m; i++) {\n\t                U[i][j] = 0;\n\t            }\n\t            U[j][j] = 1;\n\t        }\n\t        for (k = nct - 1; k >= 0; k--) {\n\t            if (s[k] !== 0) {\n\t                for (j = k + 1; j < nu; j++) {\n\t                    t = 0;\n\t                    for (i = k; i < m; i++) {\n\t                        t += U[i][k] * U[i][j];\n\t                    }\n\t                    t = -t / U[k][k];\n\t                    for (i = k; i < m; i++) {\n\t                        U[i][j] += t * U[i][k];\n\t                    }\n\t                }\n\t                for (i = k; i < m; i++) {\n\t                    U[i][k] = -U[i][k];\n\t                }\n\t                U[k][k] = 1 + U[k][k];\n\t                for (i = 0; i < k - 1; i++) {\n\t                    U[i][k] = 0;\n\t                }\n\t            } else {\n\t                for (i = 0; i < m; i++) {\n\t                    U[i][k] = 0;\n\t                }\n\t                U[k][k] = 1;\n\t            }\n\t        }\n\t    }\n\t\n\t    if (wantv) {\n\t        for (k = n - 1; k >= 0; k--) {\n\t            if ((k < nrt) && (e[k] !== 0)) {\n\t                for (j = k + 1; j < n; j++) {\n\t                    t = 0;\n\t                    for (i = k + 1; i < n; i++) {\n\t                        t += V[i][k] * V[i][j];\n\t                    }\n\t                    t = -t / V[k + 1][k];\n\t                    for (i = k + 1; i < n; i++) {\n\t                        V[i][j] += t * V[i][k];\n\t                    }\n\t                }\n\t            }\n\t            for (i = 0; i < n; i++) {\n\t                V[i][k] = 0;\n\t            }\n\t            V[k][k] = 1;\n\t        }\n\t    }\n\t\n\t    var pp = p - 1,\n\t        iter = 0,\n\t        eps = Math.pow(2, -52);\n\t    while (p > 0) {\n\t        for (k = p - 2; k >= -1; k--) {\n\t            if (k === -1) {\n\t                break;\n\t            }\n\t            if (Math.abs(e[k]) <= eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {\n\t                e[k] = 0;\n\t                break;\n\t            }\n\t        }\n\t        if (k === p - 2) {\n\t            kase = 4;\n\t        } else {\n\t            for (ks = p - 1; ks >= k; ks--) {\n\t                if (ks === k) {\n\t                    break;\n\t                }\n\t                t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\n\t                if (Math.abs(s[ks]) <= eps * t) {\n\t                    s[ks] = 0;\n\t                    break;\n\t                }\n\t            }\n\t            if (ks === k) {\n\t                kase = 3;\n\t            } else if (ks === p - 1) {\n\t                kase = 1;\n\t            } else {\n\t                kase = 2;\n\t                k = ks;\n\t            }\n\t        }\n\t\n\t        k++;\n\t\n\t        switch (kase) {\n\t            case 1: {\n\t                f = e[p - 2];\n\t                e[p - 2] = 0;\n\t                for (j = p - 2; j >= k; j--) {\n\t                    t = hypotenuse(s[j], f);\n\t                    cs = s[j] / t;\n\t                    sn = f / t;\n\t                    s[j] = t;\n\t                    if (j !== k) {\n\t                        f = -sn * e[j - 1];\n\t                        e[j - 1] = cs * e[j - 1];\n\t                    }\n\t                    if (wantv) {\n\t                        for (i = 0; i < n; i++) {\n\t                            t = cs * V[i][j] + sn * V[i][p - 1];\n\t                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n\t                            V[i][j] = t;\n\t                        }\n\t                    }\n\t                }\n\t                break;\n\t            }\n\t            case 2 : {\n\t                f = e[k - 1];\n\t                e[k - 1] = 0;\n\t                for (j = k; j < p; j++) {\n\t                    t = hypotenuse(s[j], f);\n\t                    cs = s[j] / t;\n\t                    sn = f / t;\n\t                    s[j] = t;\n\t                    f = -sn * e[j];\n\t                    e[j] = cs * e[j];\n\t                    if (wantu) {\n\t                        for (i = 0; i < m; i++) {\n\t                            t = cs * U[i][j] + sn * U[i][k - 1];\n\t                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n\t                            U[i][j] = t;\n\t                        }\n\t                    }\n\t                }\n\t                break;\n\t            }\n\t            case 3 : {\n\t                scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));\n\t                sp = s[p - 1] / scale;\n\t                spm1 = s[p - 2] / scale;\n\t                epm1 = e[p - 2] / scale;\n\t                sk = s[k] / scale;\n\t                ek = e[k] / scale;\n\t                b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n\t                c = (sp * epm1) * (sp * epm1);\n\t                shift = 0;\n\t                if ((b !== 0) || (c !== 0)) {\n\t                    shift = Math.sqrt(b * b + c);\n\t                    if (b < 0) {\n\t                        shift = -shift;\n\t                    }\n\t                    shift = c / (b + shift);\n\t                }\n\t                f = (sk + sp) * (sk - sp) + shift;\n\t                g = sk * ek;\n\t                for (j = k; j < p - 1; j++) {\n\t                    t = hypotenuse(f, g);\n\t                    cs = f / t;\n\t                    sn = g / t;\n\t                    if (j !== k) {\n\t                        e[j - 1] = t;\n\t                    }\n\t                    f = cs * s[j] + sn * e[j];\n\t                    e[j] = cs * e[j] - sn * s[j];\n\t                    g = sn * s[j + 1];\n\t                    s[j + 1] = cs * s[j + 1];\n\t                    if (wantv) {\n\t                        for (i = 0; i < n; i++) {\n\t                            t = cs * V[i][j] + sn * V[i][j + 1];\n\t                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n\t                            V[i][j] = t;\n\t                        }\n\t                    }\n\t                    t = hypotenuse(f, g);\n\t                    cs = f / t;\n\t                    sn = g / t;\n\t                    s[j] = t;\n\t                    f = cs * e[j] + sn * s[j + 1];\n\t                    s[j + 1] = -sn * e[j] + cs * s[j + 1];\n\t                    g = sn * e[j + 1];\n\t                    e[j + 1] = cs * e[j + 1];\n\t                    if (wantu && (j < m - 1)) {\n\t                        for (i = 0; i < m; i++) {\n\t                            t = cs * U[i][j] + sn * U[i][j + 1];\n\t                            U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n\t                            U[i][j] = t;\n\t                        }\n\t                    }\n\t                }\n\t                e[p - 2] = f;\n\t                iter = iter + 1;\n\t                break;\n\t            }\n\t            case 4: {\n\t                if (s[k] <= 0) {\n\t                    s[k] = (s[k] < 0 ? -s[k] : 0);\n\t                    if (wantv) {\n\t                        for (i = 0; i <= pp; i++) {\n\t                            V[i][k] = -V[i][k];\n\t                        }\n\t                    }\n\t                }\n\t                while (k < pp) {\n\t                    if (s[k] >= s[k + 1]) {\n\t                        break;\n\t                    }\n\t                    t = s[k];\n\t                    s[k] = s[k + 1];\n\t                    s[k + 1] = t;\n\t                    if (wantv && (k < n - 1)) {\n\t                        for (i = 0; i < n; i++) {\n\t                            t = V[i][k + 1];\n\t                            V[i][k + 1] = V[i][k];\n\t                            V[i][k] = t;\n\t                        }\n\t                    }\n\t                    if (wantu && (k < m - 1)) {\n\t                        for (i = 0; i < m; i++) {\n\t                            t = U[i][k + 1];\n\t                            U[i][k + 1] = U[i][k];\n\t                            U[i][k] = t;\n\t                        }\n\t                    }\n\t                    k++;\n\t                }\n\t                iter = 0;\n\t                p--;\n\t                break;\n\t            }\n\t        }\n\t    }\n\t\n\t    if (swapped) {\n\t        var tmp = V;\n\t        V = U;\n\t        U = tmp;\n\t    }\n\t\n\t    this.m = m;\n\t    this.n = n;\n\t    this.s = s;\n\t    this.U = U;\n\t    this.V = V;\n\t}\n\t\n\tSingularValueDecomposition.prototype = {\n\t    get condition() {\n\t        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n\t    },\n\t    get norm2() {\n\t        return this.s[0];\n\t    },\n\t    get rank() {\n\t        var eps = Math.pow(2, -52),\n\t            tol = Math.max(this.m, this.n) * this.s[0] * eps,\n\t            r = 0,\n\t            s = this.s;\n\t        for (var i = 0, ii = s.length; i < ii; i++) {\n\t            if (s[i] > tol) {\n\t                r++;\n\t            }\n\t        }\n\t        return r;\n\t    },\n\t    get diagonal() {\n\t        return this.s;\n\t    },\n\t    // https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs\n\t    get threshold() {\n\t        return (Math.pow(2, -52) / 2) * Math.max(this.m, this.n) * this.s[0];\n\t    },\n\t    get leftSingularVectors() {\n\t        return this.U;\n\t    },\n\t    get rightSingularVectors() {\n\t        return this.V;\n\t    },\n\t    get diagonalMatrix() {\n\t        return Matrix.diag(this.s);\n\t    },\n\t    solve: function (value) {\n\t\n\t        var Y = value,\n\t            e = this.threshold,\n\t            scols = this.s.length,\n\t            Ls = Matrix.zeros(scols, scols),\n\t            i;\n\t\n\t        for (i = 0; i < scols; i++) {\n\t            if (Math.abs(this.s[i]) <= e) {\n\t                Ls[i][i] = 0;\n\t            } else {\n\t                Ls[i][i] = 1 / this.s[i];\n\t            }\n\t        }\n\t\n\t\n\t        var VL = this.V.mmul(Ls),\n\t            vrows = this.V.rows,\n\t            urows = this.U.rows,\n\t            VLU = Matrix.zeros(vrows, urows),\n\t            j, k, sum;\n\t\n\t        for (i = 0; i < vrows; i++) {\n\t            for (j = 0; j < urows; j++) {\n\t                sum = 0;\n\t                for (k = 0; k < scols; k++) {\n\t                    sum += VL[i][k] * this.U[j][k];\n\t                }\n\t                VLU[i][j] = sum;\n\t            }\n\t        }\n\t\n\t        return VLU.mmul(Y);\n\t    },\n\t    solveForDiagonal: function (value) {\n\t        return this.solve(Matrix.diag(value));\n\t    },\n\t    inverse: function () {\n\t        var e = this.threshold,\n\t            vrows = this.V.rows,\n\t            vcols = this.V.columns,\n\t            X = new Matrix(vrows, this.s.length),\n\t            i, j;\n\t\n\t        for (i = 0; i < vrows; i++) {\n\t            for (j = 0; j < vcols; j++) {\n\t                if (Math.abs(this.s[j]) > e) {\n\t                    X[i][j] = this.V[i][j] / this.s[j];\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t\n\t        var urows = this.U.rows,\n\t            ucols = this.U.columns,\n\t            Y = new Matrix(vrows, urows),\n\t            k, sum;\n\t\n\t        for (i = 0; i < vrows; i++) {\n\t            for (j = 0; j < urows; j++) {\n\t                sum = 0;\n\t                for (k = 0; k < ucols; k++) {\n\t                    sum += X[i][k] * this.U[j][k];\n\t                }\n\t                Y[i][j] = sum;\n\t            }\n\t        }\n\t\n\t        return Y;\n\t    }\n\t};\n\t\n\tmodule.exports = SingularValueDecomposition;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.hypotenuse = function hypotenuse(a, b) {\n\t    var r;\n\t    if (Math.abs(a) > Math.abs(b)) {\n\t        r = b / a;\n\t        return Math.abs(a) * Math.sqrt(1 + r * r);\n\t    }\n\t    if (b !== 0) {\n\t        r = a / b;\n\t        return Math.abs(b) * Math.sqrt(1 + r * r);\n\t    }\n\t    return 0;\n\t};\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(6);\n\tvar hypotenuse = __webpack_require__(9).hypotenuse;\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs\n\tfunction EigenvalueDecomposition(matrix) {\n\t    if (!(this instanceof EigenvalueDecomposition)) {\n\t        return new EigenvalueDecomposition(matrix);\n\t    }\n\t    matrix = Matrix.checkMatrix(matrix);\n\t    if (!matrix.isSquare()) {\n\t        throw new Error('Matrix is not a square matrix');\n\t    }\n\t\n\t    var n = matrix.columns,\n\t        V = Matrix.zeros(n, n),\n\t        d = new Array(n),\n\t        e = new Array(n),\n\t        value = matrix,\n\t        i, j;\n\t\n\t    if (matrix.isSymmetric()) {\n\t        for (i = 0; i < n; i++) {\n\t            for (j = 0; j < n; j++) {\n\t                V[i][j] = value[i][j];\n\t            }\n\t        }\n\t        tred2(n, e, d, V);\n\t        tql2(n, e, d, V);\n\t    }\n\t    else {\n\t        var H = Matrix.zeros(n, n),\n\t            ort = new Array(n);\n\t        for (j = 0; j < n; j++) {\n\t            for (i = 0; i < n; i++) {\n\t                H[i][j] = value[i][j];\n\t            }\n\t        }\n\t        orthes(n, H, ort, V);\n\t        hqr2(n, e, d, V, H);\n\t    }\n\t\n\t    this.n = n;\n\t    this.e = e;\n\t    this.d = d;\n\t    this.V = V;\n\t}\n\t\n\tEigenvalueDecomposition.prototype = {\n\t    get realEigenvalues() {\n\t        return this.d;\n\t    },\n\t    get imaginaryEigenvalues() {\n\t        return this.e;\n\t    },\n\t    get eigenvectorMatrix() {\n\t        return this.V;\n\t    },\n\t    get diagonalMatrix() {\n\t        var n = this.n,\n\t            e = this.e,\n\t            d = this.d,\n\t            X = new Matrix(n, n),\n\t            i, j;\n\t        for (i = 0; i < n; i++) {\n\t            for (j = 0; j < n; j++) {\n\t                X[i][j] = 0;\n\t            }\n\t            X[i][i] = d[i];\n\t            if (e[i] > 0) {\n\t                X[i][i + 1] = e[i];\n\t            }\n\t            else if (e[i] < 0) {\n\t                X[i][i - 1] = e[i];\n\t            }\n\t        }\n\t        return X;\n\t    }\n\t};\n\t\n\tfunction tred2(n, e, d, V) {\n\t\n\t    var f, g, h, i, j, k,\n\t        hh, scale;\n\t\n\t    for (j = 0; j < n; j++) {\n\t        d[j] = V[n - 1][j];\n\t    }\n\t\n\t    for (i = n - 1; i > 0; i--) {\n\t        scale = 0;\n\t        h = 0;\n\t        for (k = 0; k < i; k++) {\n\t            scale = scale + Math.abs(d[k]);\n\t        }\n\t\n\t        if (scale === 0) {\n\t            e[i] = d[i - 1];\n\t            for (j = 0; j < i; j++) {\n\t                d[j] = V[i - 1][j];\n\t                V[i][j] = 0;\n\t                V[j][i] = 0;\n\t            }\n\t        } else {\n\t            for (k = 0; k < i; k++) {\n\t                d[k] /= scale;\n\t                h += d[k] * d[k];\n\t            }\n\t\n\t            f = d[i - 1];\n\t            g = Math.sqrt(h);\n\t            if (f > 0) {\n\t                g = -g;\n\t            }\n\t\n\t            e[i] = scale * g;\n\t            h = h - f * g;\n\t            d[i - 1] = f - g;\n\t            for (j = 0; j < i; j++) {\n\t                e[j] = 0;\n\t            }\n\t\n\t            for (j = 0; j < i; j++) {\n\t                f = d[j];\n\t                V[j][i] = f;\n\t                g = e[j] + V[j][j] * f;\n\t                for (k = j + 1; k <= i - 1; k++) {\n\t                    g += V[k][j] * d[k];\n\t                    e[k] += V[k][j] * f;\n\t                }\n\t                e[j] = g;\n\t            }\n\t\n\t            f = 0;\n\t            for (j = 0; j < i; j++) {\n\t                e[j] /= h;\n\t                f += e[j] * d[j];\n\t            }\n\t\n\t            hh = f / (h + h);\n\t            for (j = 0; j < i; j++) {\n\t                e[j] -= hh * d[j];\n\t            }\n\t\n\t            for (j = 0; j < i; j++) {\n\t                f = d[j];\n\t                g = e[j];\n\t                for (k = j; k <= i - 1; k++) {\n\t                    V[k][j] -= (f * e[k] + g * d[k]);\n\t                }\n\t                d[j] = V[i - 1][j];\n\t                V[i][j] = 0;\n\t            }\n\t        }\n\t        d[i] = h;\n\t    }\n\t\n\t    for (i = 0; i < n - 1; i++) {\n\t        V[n - 1][i] = V[i][i];\n\t        V[i][i] = 1;\n\t        h = d[i + 1];\n\t        if (h !== 0) {\n\t            for (k = 0; k <= i; k++) {\n\t                d[k] = V[k][i + 1] / h;\n\t            }\n\t\n\t            for (j = 0; j <= i; j++) {\n\t                g = 0;\n\t                for (k = 0; k <= i; k++) {\n\t                    g += V[k][i + 1] * V[k][j];\n\t                }\n\t                for (k = 0; k <= i; k++) {\n\t                    V[k][j] -= g * d[k];\n\t                }\n\t            }\n\t        }\n\t\n\t        for (k = 0; k <= i; k++) {\n\t            V[k][i + 1] = 0;\n\t        }\n\t    }\n\t\n\t    for (j = 0; j < n; j++) {\n\t        d[j] = V[n - 1][j];\n\t        V[n - 1][j] = 0;\n\t    }\n\t\n\t    V[n - 1][n - 1] = 1;\n\t    e[0] = 0;\n\t}\n\t\n\tfunction tql2(n, e, d, V) {\n\t\n\t    var g, h, i, j, k, l, m, p, r,\n\t        dl1, c, c2, c3, el1, s, s2,\n\t        iter;\n\t\n\t    for (i = 1; i < n; i++) {\n\t        e[i - 1] = e[i];\n\t    }\n\t\n\t    e[n - 1] = 0;\n\t\n\t    var f = 0,\n\t        tst1 = 0,\n\t        eps = Math.pow(2, -52);\n\t\n\t    for (l = 0; l < n; l++) {\n\t        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\n\t        m = l;\n\t        while (m < n) {\n\t            if (Math.abs(e[m]) <= eps * tst1) {\n\t                break;\n\t            }\n\t            m++;\n\t        }\n\t\n\t        if (m > l) {\n\t            iter = 0;\n\t            do {\n\t                iter = iter + 1;\n\t\n\t                g = d[l];\n\t                p = (d[l + 1] - g) / (2 * e[l]);\n\t                r = hypotenuse(p, 1);\n\t                if (p < 0) {\n\t                    r = -r;\n\t                }\n\t\n\t                d[l] = e[l] / (p + r);\n\t                d[l + 1] = e[l] * (p + r);\n\t                dl1 = d[l + 1];\n\t                h = g - d[l];\n\t                for (i = l + 2; i < n; i++) {\n\t                    d[i] -= h;\n\t                }\n\t\n\t                f = f + h;\n\t\n\t                p = d[m];\n\t                c = 1;\n\t                c2 = c;\n\t                c3 = c;\n\t                el1 = e[l + 1];\n\t                s = 0;\n\t                s2 = 0;\n\t                for (i = m - 1; i >= l; i--) {\n\t                    c3 = c2;\n\t                    c2 = c;\n\t                    s2 = s;\n\t                    g = c * e[i];\n\t                    h = c * p;\n\t                    r = hypotenuse(p, e[i]);\n\t                    e[i + 1] = s * r;\n\t                    s = e[i] / r;\n\t                    c = p / r;\n\t                    p = c * d[i] - s * g;\n\t                    d[i + 1] = h + s * (c * g + s * d[i]);\n\t\n\t                    for (k = 0; k < n; k++) {\n\t                        h = V[k][i + 1];\n\t                        V[k][i + 1] = s * V[k][i] + c * h;\n\t                        V[k][i] = c * V[k][i] - s * h;\n\t                    }\n\t                }\n\t\n\t                p = -s * s2 * c3 * el1 * e[l] / dl1;\n\t                e[l] = s * p;\n\t                d[l] = c * p;\n\t\n\t            }\n\t            while (Math.abs(e[l]) > eps * tst1);\n\t        }\n\t        d[l] = d[l] + f;\n\t        e[l] = 0;\n\t    }\n\t\n\t    for (i = 0; i < n - 1; i++) {\n\t        k = i;\n\t        p = d[i];\n\t        for (j = i + 1; j < n; j++) {\n\t            if (d[j] < p) {\n\t                k = j;\n\t                p = d[j];\n\t            }\n\t        }\n\t\n\t        if (k !== i) {\n\t            d[k] = d[i];\n\t            d[i] = p;\n\t            for (j = 0; j < n; j++) {\n\t                p = V[j][i];\n\t                V[j][i] = V[j][k];\n\t                V[j][k] = p;\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction orthes(n, H, ort, V) {\n\t\n\t    var low = 0,\n\t        high = n - 1,\n\t        f, g, h, i, j, m,\n\t        scale;\n\t\n\t    for (m = low + 1; m <= high - 1; m++) {\n\t        scale = 0;\n\t        for (i = m; i <= high; i++) {\n\t            scale = scale + Math.abs(H[i][m - 1]);\n\t        }\n\t\n\t        if (scale !== 0) {\n\t            h = 0;\n\t            for (i = high; i >= m; i--) {\n\t                ort[i] = H[i][m - 1] / scale;\n\t                h += ort[i] * ort[i];\n\t            }\n\t\n\t            g = Math.sqrt(h);\n\t            if (ort[m] > 0) {\n\t                g = -g;\n\t            }\n\t\n\t            h = h - ort[m] * g;\n\t            ort[m] = ort[m] - g;\n\t\n\t            for (j = m; j < n; j++) {\n\t                f = 0;\n\t                for (i = high; i >= m; i--) {\n\t                    f += ort[i] * H[i][j];\n\t                }\n\t\n\t                f = f / h;\n\t                for (i = m; i <= high; i++) {\n\t                    H[i][j] -= f * ort[i];\n\t                }\n\t            }\n\t\n\t            for (i = 0; i <= high; i++) {\n\t                f = 0;\n\t                for (j = high; j >= m; j--) {\n\t                    f += ort[j] * H[i][j];\n\t                }\n\t\n\t                f = f / h;\n\t                for (j = m; j <= high; j++) {\n\t                    H[i][j] -= f * ort[j];\n\t                }\n\t            }\n\t\n\t            ort[m] = scale * ort[m];\n\t            H[m][m - 1] = scale * g;\n\t        }\n\t    }\n\t\n\t    for (i = 0; i < n; i++) {\n\t        for (j = 0; j < n; j++) {\n\t            V[i][j] = (i === j ? 1 : 0);\n\t        }\n\t    }\n\t\n\t    for (m = high - 1; m >= low + 1; m--) {\n\t        if (H[m][m - 1] !== 0) {\n\t            for (i = m + 1; i <= high; i++) {\n\t                ort[i] = H[i][m - 1];\n\t            }\n\t\n\t            for (j = m; j <= high; j++) {\n\t                g = 0;\n\t                for (i = m; i <= high; i++) {\n\t                    g += ort[i] * V[i][j];\n\t                }\n\t\n\t                g = (g / ort[m]) / H[m][m - 1];\n\t                for (i = m; i <= high; i++) {\n\t                    V[i][j] += g * ort[i];\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction hqr2(nn, e, d, V, H) {\n\t    var n = nn - 1,\n\t        low = 0,\n\t        high = nn - 1,\n\t        eps = Math.pow(2, -52),\n\t        exshift = 0,\n\t        norm = 0,\n\t        p = 0,\n\t        q = 0,\n\t        r = 0,\n\t        s = 0,\n\t        z = 0,\n\t        iter = 0,\n\t        i, j, k, l, m, t, w, x, y,\n\t        ra, sa, vr, vi,\n\t        notlast, cdivres;\n\t\n\t    for (i = 0; i < nn; i++) {\n\t        if (i < low || i > high) {\n\t            d[i] = H[i][i];\n\t            e[i] = 0;\n\t        }\n\t\n\t        for (j = Math.max(i - 1, 0); j < nn; j++) {\n\t            norm = norm + Math.abs(H[i][j]);\n\t        }\n\t    }\n\t\n\t    while (n >= low) {\n\t        l = n;\n\t        while (l > low) {\n\t            s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);\n\t            if (s === 0) {\n\t                s = norm;\n\t            }\n\t            if (Math.abs(H[l][l - 1]) < eps * s) {\n\t                break;\n\t            }\n\t            l--;\n\t        }\n\t\n\t        if (l === n) {\n\t            H[n][n] = H[n][n] + exshift;\n\t            d[n] = H[n][n];\n\t            e[n] = 0;\n\t            n--;\n\t            iter = 0;\n\t        } else if (l === n - 1) {\n\t            w = H[n][n - 1] * H[n - 1][n];\n\t            p = (H[n - 1][n - 1] - H[n][n]) / 2;\n\t            q = p * p + w;\n\t            z = Math.sqrt(Math.abs(q));\n\t            H[n][n] = H[n][n] + exshift;\n\t            H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;\n\t            x = H[n][n];\n\t\n\t            if (q >= 0) {\n\t                z = (p >= 0) ? (p + z) : (p - z);\n\t                d[n - 1] = x + z;\n\t                d[n] = d[n - 1];\n\t                if (z !== 0) {\n\t                    d[n] = x - w / z;\n\t                }\n\t                e[n - 1] = 0;\n\t                e[n] = 0;\n\t                x = H[n][n - 1];\n\t                s = Math.abs(x) + Math.abs(z);\n\t                p = x / s;\n\t                q = z / s;\n\t                r = Math.sqrt(p * p + q * q);\n\t                p = p / r;\n\t                q = q / r;\n\t\n\t                for (j = n - 1; j < nn; j++) {\n\t                    z = H[n - 1][j];\n\t                    H[n - 1][j] = q * z + p * H[n][j];\n\t                    H[n][j] = q * H[n][j] - p * z;\n\t                }\n\t\n\t                for (i = 0; i <= n; i++) {\n\t                    z = H[i][n - 1];\n\t                    H[i][n - 1] = q * z + p * H[i][n];\n\t                    H[i][n] = q * H[i][n] - p * z;\n\t                }\n\t\n\t                for (i = low; i <= high; i++) {\n\t                    z = V[i][n - 1];\n\t                    V[i][n - 1] = q * z + p * V[i][n];\n\t                    V[i][n] = q * V[i][n] - p * z;\n\t                }\n\t            } else {\n\t                d[n - 1] = x + p;\n\t                d[n] = x + p;\n\t                e[n - 1] = z;\n\t                e[n] = -z;\n\t            }\n\t\n\t            n = n - 2;\n\t            iter = 0;\n\t        } else {\n\t            x = H[n][n];\n\t            y = 0;\n\t            w = 0;\n\t            if (l < n) {\n\t                y = H[n - 1][n - 1];\n\t                w = H[n][n - 1] * H[n - 1][n];\n\t            }\n\t\n\t            if (iter === 10) {\n\t                exshift += x;\n\t                for (i = low; i <= n; i++) {\n\t                    H[i][i] -= x;\n\t                }\n\t                s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);\n\t                x = y = 0.75 * s;\n\t                w = -0.4375 * s * s;\n\t            }\n\t\n\t            if (iter === 30) {\n\t                s = (y - x) / 2;\n\t                s = s * s + w;\n\t                if (s > 0) {\n\t                    s = Math.sqrt(s);\n\t                    if (y < x) {\n\t                        s = -s;\n\t                    }\n\t                    s = x - w / ((y - x) / 2 + s);\n\t                    for (i = low; i <= n; i++) {\n\t                        H[i][i] -= s;\n\t                    }\n\t                    exshift += s;\n\t                    x = y = w = 0.964;\n\t                }\n\t            }\n\t\n\t            iter = iter + 1;\n\t\n\t            m = n - 2;\n\t            while (m >= l) {\n\t                z = H[m][m];\n\t                r = x - z;\n\t                s = y - z;\n\t                p = (r * s - w) / H[m + 1][m] + H[m][m + 1];\n\t                q = H[m + 1][m + 1] - z - r - s;\n\t                r = H[m + 2][m + 1];\n\t                s = Math.abs(p) + Math.abs(q) + Math.abs(r);\n\t                p = p / s;\n\t                q = q / s;\n\t                r = r / s;\n\t                if (m === l) {\n\t                    break;\n\t                }\n\t                if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) + Math.abs(H[m + 1][m + 1])))) {\n\t                    break;\n\t                }\n\t                m--;\n\t            }\n\t\n\t            for (i = m + 2; i <= n; i++) {\n\t                H[i][i - 2] = 0;\n\t                if (i > m + 2) {\n\t                    H[i][i - 3] = 0;\n\t                }\n\t            }\n\t\n\t            for (k = m; k <= n - 1; k++) {\n\t                notlast = (k !== n - 1);\n\t                if (k !== m) {\n\t                    p = H[k][k - 1];\n\t                    q = H[k + 1][k - 1];\n\t                    r = (notlast ? H[k + 2][k - 1] : 0);\n\t                    x = Math.abs(p) + Math.abs(q) + Math.abs(r);\n\t                    if (x !== 0) {\n\t                        p = p / x;\n\t                        q = q / x;\n\t                        r = r / x;\n\t                    }\n\t                }\n\t\n\t                if (x === 0) {\n\t                    break;\n\t                }\n\t\n\t                s = Math.sqrt(p * p + q * q + r * r);\n\t                if (p < 0) {\n\t                    s = -s;\n\t                }\n\t\n\t                if (s !== 0) {\n\t                    if (k !== m) {\n\t                        H[k][k - 1] = -s * x;\n\t                    } else if (l !== m) {\n\t                        H[k][k - 1] = -H[k][k - 1];\n\t                    }\n\t\n\t                    p = p + s;\n\t                    x = p / s;\n\t                    y = q / s;\n\t                    z = r / s;\n\t                    q = q / p;\n\t                    r = r / p;\n\t\n\t                    for (j = k; j < nn; j++) {\n\t                        p = H[k][j] + q * H[k + 1][j];\n\t                        if (notlast) {\n\t                            p = p + r * H[k + 2][j];\n\t                            H[k + 2][j] = H[k + 2][j] - p * z;\n\t                        }\n\t\n\t                        H[k][j] = H[k][j] - p * x;\n\t                        H[k + 1][j] = H[k + 1][j] - p * y;\n\t                    }\n\t\n\t                    for (i = 0; i <= Math.min(n, k + 3); i++) {\n\t                        p = x * H[i][k] + y * H[i][k + 1];\n\t                        if (notlast) {\n\t                            p = p + z * H[i][k + 2];\n\t                            H[i][k + 2] = H[i][k + 2] - p * r;\n\t                        }\n\t\n\t                        H[i][k] = H[i][k] - p;\n\t                        H[i][k + 1] = H[i][k + 1] - p * q;\n\t                    }\n\t\n\t                    for (i = low; i <= high; i++) {\n\t                        p = x * V[i][k] + y * V[i][k + 1];\n\t                        if (notlast) {\n\t                            p = p + z * V[i][k + 2];\n\t                            V[i][k + 2] = V[i][k + 2] - p * r;\n\t                        }\n\t\n\t                        V[i][k] = V[i][k] - p;\n\t                        V[i][k + 1] = V[i][k + 1] - p * q;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    if (norm === 0) {\n\t        return;\n\t    }\n\t\n\t    for (n = nn - 1; n >= 0; n--) {\n\t        p = d[n];\n\t        q = e[n];\n\t\n\t        if (q === 0) {\n\t            l = n;\n\t            H[n][n] = 1;\n\t            for (i = n - 1; i >= 0; i--) {\n\t                w = H[i][i] - p;\n\t                r = 0;\n\t                for (j = l; j <= n; j++) {\n\t                    r = r + H[i][j] * H[j][n];\n\t                }\n\t\n\t                if (e[i] < 0) {\n\t                    z = w;\n\t                    s = r;\n\t                } else {\n\t                    l = i;\n\t                    if (e[i] === 0) {\n\t                        H[i][n] = (w !== 0) ? (-r / w) : (-r / (eps * norm));\n\t                    } else {\n\t                        x = H[i][i + 1];\n\t                        y = H[i + 1][i];\n\t                        q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\n\t                        t = (x * s - z * r) / q;\n\t                        H[i][n] = t;\n\t                        H[i + 1][n] = (Math.abs(x) > Math.abs(z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);\n\t                    }\n\t\n\t                    t = Math.abs(H[i][n]);\n\t                    if ((eps * t) * t > 1) {\n\t                        for (j = i; j <= n; j++) {\n\t                            H[j][n] = H[j][n] / t;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        } else if (q < 0) {\n\t            l = n - 1;\n\t\n\t            if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {\n\t                H[n - 1][n - 1] = q / H[n][n - 1];\n\t                H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];\n\t            } else {\n\t                cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);\n\t                H[n - 1][n - 1] = cdivres[0];\n\t                H[n - 1][n] = cdivres[1];\n\t            }\n\t\n\t            H[n][n - 1] = 0;\n\t            H[n][n] = 1;\n\t            for (i = n - 2; i >= 0; i--) {\n\t                ra = 0;\n\t                sa = 0;\n\t                for (j = l; j <= n; j++) {\n\t                    ra = ra + H[i][j] * H[j][n - 1];\n\t                    sa = sa + H[i][j] * H[j][n];\n\t                }\n\t\n\t                w = H[i][i] - p;\n\t\n\t                if (e[i] < 0) {\n\t                    z = w;\n\t                    r = ra;\n\t                    s = sa;\n\t                } else {\n\t                    l = i;\n\t                    if (e[i] === 0) {\n\t                        cdivres = cdiv(-ra, -sa, w, q);\n\t                        H[i][n - 1] = cdivres[0];\n\t                        H[i][n] = cdivres[1];\n\t                    } else {\n\t                        x = H[i][i + 1];\n\t                        y = H[i + 1][i];\n\t                        vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\n\t                        vi = (d[i] - p) * 2 * q;\n\t                        if (vr === 0 && vi === 0) {\n\t                            vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));\n\t                        }\n\t                        cdivres = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);\n\t                        H[i][n - 1] = cdivres[0];\n\t                        H[i][n] = cdivres[1];\n\t                        if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {\n\t                            H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;\n\t                            H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;\n\t                        } else {\n\t                            cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);\n\t                            H[i + 1][n - 1] = cdivres[0];\n\t                            H[i + 1][n] = cdivres[1];\n\t                        }\n\t                    }\n\t\n\t                    t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));\n\t                    if ((eps * t) * t > 1) {\n\t                        for (j = i; j <= n; j++) {\n\t                            H[j][n - 1] = H[j][n - 1] / t;\n\t                            H[j][n] = H[j][n] / t;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    for (i = 0; i < nn; i++) {\n\t        if (i < low || i > high) {\n\t            for (j = i; j < nn; j++) {\n\t                V[i][j] = H[i][j];\n\t            }\n\t        }\n\t    }\n\t\n\t    for (j = nn - 1; j >= low; j--) {\n\t        for (i = low; i <= high; i++) {\n\t            z = 0;\n\t            for (k = low; k <= Math.min(j, high); k++) {\n\t                z = z + V[i][k] * H[k][j];\n\t            }\n\t            V[i][j] = z;\n\t        }\n\t    }\n\t}\n\t\n\tfunction cdiv(xr, xi, yr, yi) {\n\t    var r, d;\n\t    if (Math.abs(yr) > Math.abs(yi)) {\n\t        r = yi / yr;\n\t        d = yr + r * yi;\n\t        return [(xr + r * xi) / d, (xi - r * xr) / d];\n\t    }\n\t    else {\n\t        r = yr / yi;\n\t        d = yi + r * yr;\n\t        return [(r * xr + xi) / d, (r * xi - xr) / d];\n\t    }\n\t}\n\t\n\tmodule.exports = EigenvalueDecomposition;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(6);\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs\n\tfunction LuDecomposition(matrix) {\n\t    if (!(this instanceof LuDecomposition)) {\n\t        return new LuDecomposition(matrix);\n\t    }\n\t    matrix = Matrix.checkMatrix(matrix);\n\t\n\t    var lu = matrix.clone(),\n\t        rows = lu.rows,\n\t        columns = lu.columns,\n\t        pivotVector = new Array(rows),\n\t        pivotSign = 1,\n\t        i, j, k, p, s, t, v,\n\t        LUrowi, LUcolj, kmax;\n\t\n\t    for (i = 0; i < rows; i++) {\n\t        pivotVector[i] = i;\n\t    }\n\t\n\t    LUcolj = new Array(rows);\n\t\n\t    for (j = 0; j < columns; j++) {\n\t\n\t        for (i = 0; i < rows; i++) {\n\t            LUcolj[i] = lu[i][j];\n\t        }\n\t\n\t        for (i = 0; i < rows; i++) {\n\t            LUrowi = lu[i];\n\t            kmax = Math.min(i, j);\n\t            s = 0;\n\t            for (k = 0; k < kmax; k++) {\n\t                s += LUrowi[k] * LUcolj[k];\n\t            }\n\t            LUrowi[j] = LUcolj[i] -= s;\n\t        }\n\t\n\t        p = j;\n\t        for (i = j + 1; i < rows; i++) {\n\t            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n\t                p = i;\n\t            }\n\t        }\n\t\n\t        if (p !== j) {\n\t            for (k = 0; k < columns; k++) {\n\t                t = lu[p][k];\n\t                lu[p][k] = lu[j][k];\n\t                lu[j][k] = t;\n\t            }\n\t\n\t            v = pivotVector[p];\n\t            pivotVector[p] = pivotVector[j];\n\t            pivotVector[j] = v;\n\t\n\t            pivotSign = -pivotSign;\n\t        }\n\t\n\t        if (j < rows && lu[j][j] !== 0) {\n\t            for (i = j + 1; i < rows; i++) {\n\t                lu[i][j] /= lu[j][j];\n\t            }\n\t        }\n\t    }\n\t\n\t    this.LU = lu;\n\t    this.pivotVector = pivotVector;\n\t    this.pivotSign = pivotSign;\n\t}\n\t\n\tLuDecomposition.prototype = {\n\t    isSingular: function () {\n\t        var data = this.LU,\n\t            col = data.columns;\n\t        for (var j = 0; j < col; j++) {\n\t            if (data[j][j] === 0) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t    get determinant() {\n\t        var data = this.LU;\n\t        if (!data.isSquare())\n\t            throw new Error('Matrix must be square');\n\t        var determinant = this.pivotSign, col = data.columns;\n\t        for (var j = 0; j < col; j++)\n\t            determinant *= data[j][j];\n\t        return determinant;\n\t    },\n\t    get lowerTriangularFactor() {\n\t        var data = this.LU,\n\t            rows = data.rows,\n\t            columns = data.columns,\n\t            X = new Matrix(rows, columns);\n\t        for (var i = 0; i < rows; i++) {\n\t            for (var j = 0; j < columns; j++) {\n\t                if (i > j) {\n\t                    X[i][j] = data[i][j];\n\t                } else if (i === j) {\n\t                    X[i][j] = 1;\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    },\n\t    get upperTriangularFactor() {\n\t        var data = this.LU,\n\t            rows = data.rows,\n\t            columns = data.columns,\n\t            X = new Matrix(rows, columns);\n\t        for (var i = 0; i < rows; i++) {\n\t            for (var j = 0; j < columns; j++) {\n\t                if (i <= j) {\n\t                    X[i][j] = data[i][j];\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    },\n\t    get pivotPermutationVector() {\n\t        return this.pivotVector.slice();\n\t    },\n\t    solve: function (value) {\n\t        value = Matrix.checkMatrix(value);\n\t\n\t        var lu = this.LU,\n\t            rows = lu.rows;\n\t\n\t        if (rows !== value.rows)\n\t            throw new Error('Invalid matrix dimensions');\n\t        if (this.isSingular())\n\t            throw new Error('LU matrix is singular');\n\t\n\t        var count = value.columns,\n\t            X = value.subMatrixRow(this.pivotVector, 0, count - 1),\n\t            columns = lu.columns,\n\t            i, j, k;\n\t\n\t        for (k = 0; k < columns; k++) {\n\t            for (i = k + 1; i < columns; i++) {\n\t                for (j = 0; j < count; j++) {\n\t                    X[i][j] -= X[k][j] * lu[i][k];\n\t                }\n\t            }\n\t        }\n\t        for (k = columns - 1; k >= 0; k--) {\n\t            for (j = 0; j < count; j++) {\n\t                X[k][j] /= lu[k][k];\n\t            }\n\t            for (i = 0; i < k; i++) {\n\t                for (j = 0; j < count; j++) {\n\t                    X[i][j] -= X[k][j] * lu[i][k];\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    }\n\t};\n\t\n\tmodule.exports = LuDecomposition;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(6);\n\tvar hypotenuse = __webpack_require__(9).hypotenuse;\n\t\n\t//https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs\n\tfunction QrDecomposition(value) {\n\t    if (!(this instanceof QrDecomposition)) {\n\t        return new QrDecomposition(value);\n\t    }\n\t    value = Matrix.checkMatrix(value);\n\t\n\t    var qr = value.clone(),\n\t        m = value.rows,\n\t        n = value.columns,\n\t        rdiag = new Array(n),\n\t        i, j, k, s;\n\t\n\t    for (k = 0; k < n; k++) {\n\t        var nrm = 0;\n\t        for (i = k; i < m; i++) {\n\t            nrm = hypotenuse(nrm, qr[i][k]);\n\t        }\n\t        if (nrm !== 0) {\n\t            if (qr[k][k] < 0) {\n\t                nrm = -nrm;\n\t            }\n\t            for (i = k; i < m; i++) {\n\t                qr[i][k] /= nrm;\n\t            }\n\t            qr[k][k] += 1;\n\t            for (j = k + 1; j < n; j++) {\n\t                s = 0;\n\t                for (i = k; i < m; i++) {\n\t                    s += qr[i][k] * qr[i][j];\n\t                }\n\t                s = -s / qr[k][k];\n\t                for (i = k; i < m; i++) {\n\t                    qr[i][j] += s * qr[i][k];\n\t                }\n\t            }\n\t        }\n\t        rdiag[k] = -nrm;\n\t    }\n\t\n\t    this.QR = qr;\n\t    this.Rdiag = rdiag;\n\t}\n\t\n\tQrDecomposition.prototype = {\n\t    solve: function (value) {\n\t        value = Matrix.checkMatrix(value);\n\t\n\t        var qr = this.QR,\n\t            m = qr.rows;\n\t\n\t        if (value.rows !== m)\n\t            throw new Error('Matrix row dimensions must agree');\n\t        if (!this.isFullRank())\n\t            throw new Error('Matrix is rank deficient');\n\t\n\t        var count = value.columns,\n\t            X = value.clone(),\n\t            n = qr.columns,\n\t            i, j, k, s;\n\t\n\t        for (k = 0; k < n; k++) {\n\t            for (j = 0; j < count; j++) {\n\t                s = 0;\n\t                for (i = k; i < m; i++) {\n\t                    s += qr[i][k] * X[i][j];\n\t                }\n\t                s = -s / qr[k][k];\n\t                for (i = k; i < m; i++) {\n\t                    X[i][j] += s * qr[i][k];\n\t                }\n\t            }\n\t        }\n\t        for (k = n - 1; k >= 0; k--) {\n\t            for (j = 0; j < count; j++) {\n\t                X[k][j] /= this.Rdiag[k];\n\t            }\n\t            for (i = 0; i < k; i++) {\n\t                for (j = 0; j < count; j++) {\n\t                    X[i][j] -= X[k][j] * qr[i][k];\n\t                }\n\t            }\n\t        }\n\t\n\t        return X.subMatrix(0, n - 1, 0, count - 1);\n\t    },\n\t    isFullRank: function () {\n\t        var columns = this.QR.columns;\n\t        for (var i = 0; i < columns; i++) {\n\t            if (this.Rdiag[i] === 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    },\n\t    get upperTriangularFactor() {\n\t        var qr = this.QR,\n\t            n = qr.columns,\n\t            X = new Matrix(n, n),\n\t            i, j;\n\t        for (i = 0; i < n; i++) {\n\t            for (j = 0; j < n; j++) {\n\t                if (i < j) {\n\t                    X[i][j] = qr[i][j];\n\t                } else if (i === j) {\n\t                    X[i][j] = this.Rdiag[i];\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    },\n\t    get orthogonalFactor() {\n\t        var qr = this.QR,\n\t            rows = qr.rows,\n\t            columns = qr.columns,\n\t            X = new Matrix(rows, columns),\n\t            i, j, k, s;\n\t\n\t        for (k = columns - 1; k >= 0; k--) {\n\t            for (i = 0; i < rows; i++) {\n\t                X[i][k] = 0;\n\t            }\n\t            X[k][k] = 1;\n\t            for (j = k; j < columns; j++) {\n\t                if (qr[k][k] !== 0) {\n\t                    s = 0;\n\t                    for (i = k; i < rows; i++) {\n\t                        s += qr[i][k] * X[i][j];\n\t                    }\n\t\n\t                    s = -s / qr[k][k];\n\t\n\t                    for (i = k; i < rows; i++) {\n\t                        X[i][j] += s * qr[i][k];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    }\n\t};\n\t\n\tmodule.exports = QrDecomposition;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(6);\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs\n\tfunction CholeskyDecomposition(value) {\n\t    if (!(this instanceof CholeskyDecomposition)) {\n\t        return new CholeskyDecomposition(value);\n\t    }\n\t    value = Matrix.checkMatrix(value);\n\t    if (!value.isSymmetric())\n\t        throw new Error('Matrix is not symmetric');\n\t\n\t    var a = value,\n\t        dimension = a.rows,\n\t        l = new Matrix(dimension, dimension),\n\t        positiveDefinite = true,\n\t        i, j, k;\n\t\n\t    for (j = 0; j < dimension; j++) {\n\t        var Lrowj = l[j];\n\t        var d = 0;\n\t        for (k = 0; k < j; k++) {\n\t            var Lrowk = l[k];\n\t            var s = 0;\n\t            for (i = 0; i < k; i++) {\n\t                s += Lrowk[i] * Lrowj[i];\n\t            }\n\t            Lrowj[k] = s = (a[j][k] - s) / l[k][k];\n\t            d = d + s * s;\n\t        }\n\t\n\t        d = a[j][j] - d;\n\t\n\t        positiveDefinite &= (d > 0);\n\t        l[j][j] = Math.sqrt(Math.max(d, 0));\n\t        for (k = j + 1; k < dimension; k++) {\n\t            l[j][k] = 0;\n\t        }\n\t    }\n\t\n\t    if (!positiveDefinite) {\n\t        throw new Error('Matrix is not positive definite');\n\t    }\n\t\n\t    this.L = l;\n\t}\n\t\n\tCholeskyDecomposition.prototype = {\n\t    get leftTriangularFactor() {\n\t        return this.L;\n\t    },\n\t    solve: function (value) {\n\t        value = Matrix.checkMatrix(value);\n\t\n\t        var l = this.L,\n\t            dimension = l.rows;\n\t\n\t        if (value.rows !== dimension) {\n\t            throw new Error('Matrix dimensions do not match');\n\t        }\n\t\n\t        var count = value.columns,\n\t            B = value.clone(),\n\t            i, j, k;\n\t\n\t        for (k = 0; k < dimension; k++) {\n\t            for (j = 0; j < count; j++) {\n\t                for (i = 0; i < k; i++) {\n\t                    B[k][j] -= B[i][j] * l[k][i];\n\t                }\n\t                B[k][j] /= l[k][k];\n\t            }\n\t        }\n\t\n\t        for (k = dimension - 1; k >= 0; k--) {\n\t            for (j = 0; j < count; j++) {\n\t                for (i = k + 1; i < dimension; i++) {\n\t                    B[k][j] -= B[i][j] * l[i][k];\n\t                }\n\t                B[k][j] /= l[k][k];\n\t            }\n\t        }\n\t\n\t        return B;\n\t    }\n\t};\n\t\n\tmodule.exports = CholeskyDecomposition;\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Created by acastillo on 8/24/15.\n\t */\n\t/**\n\t * Non in-place function definitions, compatible with mathjs code *\n\t */\n\t\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(5);\n\t\n\tfunction matrix(A,B){\n\t    return new Matrix(A,B);\n\t}\n\t\n\tfunction ones(rows, cols){\n\t    return Matrix.ones(rows,cols);\n\t}\n\t\n\tfunction eye(rows, cols){\n\t    return Matrix.eye(rows, cols);\n\t}\n\t\n\tfunction zeros(rows, cols){\n\t    return Matrix.zeros(rows, cols);\n\t}\n\t\n\tfunction random(rows, cols){\n\t    return Matrix.rand(rows,cols);\n\t}\n\t\n\tfunction transpose(A){\n\t    if(typeof A == 'number')\n\t        return A;\n\t    var result = A.clone();\n\t    return result.transpose();\n\t}\n\t\n\tfunction add(A, B){\n\t    if(typeof A == 'number'&&typeof B === 'number')\n\t        return A+B;\n\t    if(typeof A == 'number')\n\t        return this.add(B,A);\n\t\n\t    var result = A.clone();\n\t    return result.add(B);\n\t\n\t}\n\t\n\tfunction subtract(A, B){\n\t    if(typeof A == 'number'&&typeof B === 'number')\n\t        return A-B;\n\t    if(typeof A == 'number')\n\t        return this.subtract(B,A);\n\t    var result = A.clone();\n\t    return result.sub(B);\n\t}\n\t\n\tfunction multiply(A, B){\n\t    if(typeof A == 'number'&&typeof B === 'number')\n\t        return A*B;\n\t    if(typeof A == 'number')\n\t        return this.multiply(B,A);\n\t\n\t    var result = A.clone();\n\t\n\t    if(typeof B === 'number')\n\t        result.mul(B);\n\t    else\n\t        result = result.mmul(B);\n\t\n\t    if(result.rows==1&&result.columns==1)\n\t        return result[0][0];\n\t    else\n\t        return result;\n\t\n\t}\n\t\n\tfunction dotMultiply(A, B){\n\t    var result = A.clone();\n\t    return result.mul(B);\n\t}\n\t\n\tfunction dotDivide(A, B){\n\t    var result = A.clone();\n\t    return result.div(B);\n\t}\n\t\n\tfunction diag(A){\n\t    var diag = null;\n\t    var rows = A.rows, cols = A.columns, j, r;\n\t    //It is an array\n\t    if(typeof cols === \"undefined\" && (typeof A)=='object'){\n\t        if(A[0]&&A[0].length){\n\t            rows = A.length;\n\t            cols = A[0].length;\n\t            r = Math.min(rows,cols);\n\t            diag = Matrix.zeros(cols, cols);\n\t            for (j = 0; j < cols; j++) {\n\t                diag[j][j]=A[j][j];\n\t            }\n\t        }\n\t        else{\n\t            cols = A.length;\n\t            diag = Matrix.zeros(cols, cols);\n\t            for (j = 0; j < cols; j++) {\n\t                diag[j][j]=A[j];\n\t            }\n\t        }\n\t\n\t    }\n\t    if(rows == 1){\n\t        diag = Matrix.zeros(cols, cols);\n\t        for (j = 0; j < cols; j++) {\n\t            diag[j][j]=A[0][j];\n\t        }\n\t    }\n\t    else{\n\t        if(rows>0 && cols > 0){\n\t            r = Math.min(rows,cols);\n\t            diag = new Array(r);\n\t            for (j = 0; j < r; j++) {\n\t                diag[j] = A[j][j];\n\t            }\n\t        }\n\t    }\n\t    return diag;\n\t}\n\t\n\tfunction min(A, B){\n\t    if(typeof A==='number' && typeof B ==='number')\n\t        return Math.min(A,B);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (A[i][j] < B[i][j]) {\n\t                result[i][j] = A[i][j];\n\t            }\n\t            else{\n\t                result[i][j] = B[i][j];\n\t            }\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction max(A, B){\n\t    if(typeof A==='number' && typeof B ==='number')\n\t        return Math.max(A,B);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (A[i][j] > B[i][j]) {\n\t                result[i][j] = A[i][j];\n\t            }\n\t            else{\n\t                result[i][j] = B[i][j];\n\t            }\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction sqrt(A){\n\t    if(typeof A==='number' )\n\t        return Math.sqrt(A);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[i][j] = Math.sqrt(A[i][j]);\n\t\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction abs(A){\n\t    if(typeof A==='number' )\n\t        return Math.abs(A);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[i][j] = Math.abs(A[i][j]);\n\t\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction exp(A){\n\t    if(typeof A==='number' )\n\t        return Math.sqrt(A);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[i][j] = Math.exp(A[i][j]);\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction dotPow(A, b){\n\t    if(typeof A==='number' )\n\t        return Math.pow(A,b);\n\t    //console.log(A);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[i][j] = Math.pow(A[i][j],b);\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction solve(A, B){\n\t    return A.solve(B);\n\t}\n\t\n\tfunction inv(A){\n\t    if(typeof A ===\"number\")\n\t        return 1/A;\n\t    return A.inverse();\n\t}\n\t\n\tmodule.exports = {\n\t    transpose:transpose,\n\t    add:add,\n\t    subtract:subtract,\n\t    multiply:multiply,\n\t    dotMultiply:dotMultiply,\n\t    dotDivide:dotDivide,\n\t    diag:diag,\n\t    min:min,\n\t    max:max,\n\t    solve:solve,\n\t    inv:inv,\n\t    sqrt:sqrt,\n\t    exp:exp,\n\t    dotPow:dotPow,\n\t    abs:abs,\n\t    matrix:matrix,\n\t    ones:ones,\n\t    zeros:zeros,\n\t    random:random,\n\t    eye:eye\n\t};\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Opt = __webpack_require__(2);\n\tvar stats = __webpack_require__(16);\n\tvar extend = __webpack_require__(19);\n\tvar SG = __webpack_require__(20);\n\t\n\tvar sgDefOptions = {\n\t    windowSize: 9,\n\t    polynomial: 3\n\t};\n\t\n\t\n\tfunction gsd(x, y, options){\n\t    //options = extend({}, defaultOptions, options);\n\t    var options=Object.create(options || {});\n\t    if (options.minMaxRatio===undefined) options.minMaxRatio=0.00025;\n\t    if (options.broadRatio===undefined) options.broadRatio=0.00;\n\t    if (options.noiseLevel===undefined) options.noiseLevel=undefined;\n\t    if (options.noiseFactor===undefined) options.noiseFactor=3;\n\t    if (options.maxCriteria===undefined) options.maxCriteria=true;\n\t    if (options.smoothY===undefined) options.smoothY=true;\n\t    if (options.realTopDetection===undefined) options.realTopDetection=false;\n\t\n\t    var sgOptions = extend({}, sgDefOptions, options.sgOptions);\n\t\n\t    //console.log(JSON.stringify(stats.array.minMax(y)));\n\t    if(options.noiseLevel===undefined){\n\t        //We have to know if x is equally spaced\n\t        var maxDx=0, minDx=Number.MAX_VALUE,tmp;\n\t        for(var i=0;i< x.length-1;i++){\n\t            var tmp = Math.abs(x[i+1]-x[i]);\n\t            if(tmp<minDx){\n\t                minDx = tmp;\n\t            }\n\t            if(tmp>maxDx){\n\t                maxDx = tmp;\n\t            }\n\t        }\n\t\n\t        if((maxDx-minDx)/maxDx<0.05){\n\t\n\t            options.noiseLevel = getNoiseLevel(y);\n\t            //console.log(options.noiseLevel+\" \"+stats.array.median(y));\n\t        }\n\t        else{\n\t            options.noiseLevel = 0;\n\t        }\n\t    }\n\t    //console.log(\"options.noiseLevel \"+options.noiseLevel);\n\t    y=[].concat(y);\n\t    var yCorrection = {m:1, b:options.noiseLevel};\n\t    if(!options.maxCriteria){\n\t        yCorrection.m =-1;\n\t        yCorrection.b*=-1;\n\t    }\n\t\n\t    for (var i=0; i<y.length; i++){\n\t        y[i]=yCorrection.m*y[i]-yCorrection.b;\n\t    }\n\t\n\t    for (var i=0; i<y.length; i++) {\n\t        if (y[i] < 0) {\n\t            y[i] = 0;\n\t        }\n\t    }\n\t\n\t    //If the max difference between delta x is less than 5%, then, we can assume it to be equally spaced variable\n\t    var Y = y;\n\t    if((maxDx-minDx)/maxDx<0.05){\n\t        if(options.smoothY)\n\t            Y = SG(y, x[1]-x[0], {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:0});\n\t        var dY = SG(y, x[1]-x[0], {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:1});\n\t        var ddY = SG(y, x[1]-x[0], {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:2});\n\t    }\n\t    else{\n\t        if(options.smoothY)\n\t            Y = SG(y, x, {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:0});\n\t        var dY = SG(y, x, {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:1});\n\t        var ddY = SG(y, x, {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:2});\n\t    }\n\t\n\t    var X = x;\n\t    var dx = x[1]-x[0];\n\t    var maxDdy=0;\n\t    var maxY = 0;\n\t    //console.log(Y.length);\n\t    for (var i = 0; i < Y.length ; i++){\n\t        if(Math.abs(ddY[i])>maxDdy){\n\t            maxDdy = Math.abs(ddY[i]);\n\t        }\n\t        if(Math.abs(Y[i])>maxY){\n\t            maxY = Math.abs(Y[i]);\n\t        }\n\t    }\n\t    //console.log(maxY+\"x\"+maxDy+\"x\"+maxDdy);\n\t\n\t    var minddY = [];\n\t    var intervalL = [];\n\t    var intervalR = [];\n\t    var lastMax = null;\n\t    var lastMin = null;\n\t    var broadMask = new Array();\n\t    //console.log(dx);\n\t    //By the intermediate value theorem We cannot find 2 consecutive maxima or minima\n\t    for (var i = 1; i < Y.length -1 ; i++){\n\t        //console.log(dY[i]);\n\t        if ((dY[i] < dY[i-1]) && (dY[i] <= dY[i+1])||\n\t            (dY[i] <= dY[i-1]) && (dY[i] < dY[i+1])) {\n\t            lastMin = X[i];\n\t            //console.log(\"min \"+lastMin);\n\t            if(dx>0&&lastMax!=null){\n\t                intervalL.push(lastMax);\n\t                intervalR.push(lastMin);\n\t\n\t            }\n\t        }\n\t\n\t        if ((dY[i] >= dY[i-1]) && (dY[i] > dY[i+1])||\n\t            (dY[i] > dY[i-1]) && (dY[i] >= dY[i+1])) {\n\t            lastMax = X[i];\n\t            //console.log(\"max \"+lastMax);\n\t            if(dx<0&&lastMin!=null){\n\t                intervalL.push(lastMax);\n\t                intervalR.push(lastMin);\n\t            }\n\t        }\n\t        if ((ddY[i] < ddY[i-1]) && (ddY[i] < ddY[i+1])) {\n\t            minddY.push(i);//( [X[i], Y[i], i] );  // TODO should we change this to have 3 arrays ? Huge overhead creating arrays\n\t            if(Math.abs(ddY[i])>options.broadRatio*maxDdy){ // TODO should this be a parameter =\n\t                broadMask.push(false);\n\t            }\n\t            else{\n\t                broadMask.push(true);\n\t            }\n\t        }\n\t    }\n\t    //\n\t    //console.log(intervalL.length+\" \"+minddY.length+\" \"+broadMask.length);\n\t    var signals = [];\n\t    var lastK = 0,possible, k, f,frequency, distanceJ, minDistance, gettingCloser;\n\t    for (var j = 0; j < minddY.length; j++){\n\t        frequency = X[minddY[j]];//minddY[j][0];\n\t        possible = -1;\n\t        k=lastK+1;\n\t        minDistance = Number.MAX_VALUE;\n\t        distanceJ = 0;\n\t        gettingCloser=true;\n\t        while(possible==-1&&k<intervalL.length&&gettingCloser){\n\t            distanceJ = Math.abs(frequency-(intervalL[k]+intervalR[k])/2);\n\t            //Still getting closer?\n\t            if(distanceJ<minDistance){\n\t                minDistance = distanceJ;\n\t            }\n\t            else{\n\t                gettingCloser = false;\n\t            }\n\t            if( distanceJ <Math.abs(intervalL[k]-intervalR[k])/2){\n\t                possible=k;\n\t                lastK = k;\n\t            }\n\t            k++;\n\t        }\n\t        //console.log(lastK+\" \"+intervalL.length+\" possible \"+k);\n\t        if (possible!=-1){\n\t            //console.log(height);\n\t            if (Math.abs(Y[minddY[j]]) > options.minMaxRatio*maxY) {\n\t                signals.push({\n\t                    i:minddY[j],\n\t                    x: frequency,\n\t                    y: (Y[minddY[j]]-yCorrection.b)/yCorrection.m,\n\t                    width:Math.abs(intervalR[possible] - intervalL[possible]),//widthCorrection\n\t                    soft:broadMask[j]\n\t                })\n\t            }\n\t        }\n\t    }\n\t\n\t\n\t    if(options.realTopDetection){\n\t        realTopDetection(signals,X,Y);\n\t    }\n\t\n\t    //Correct the values to fit the original spectra data\n\t    for(var j=0;j<signals.length;j++){\n\t        signals[j].base=options.noiseLevel;\n\t    }\n\t\n\t    signals.sort(function (a, b) {\n\t        return a.x - b.x;\n\t    });\n\t\n\t    return signals;\n\t\n\t}\n\t\n\tfunction getNoiseLevel(y){\n\t    var mean = 0,stddev=0;\n\t    var length = y.length,i=0;\n\t    for(i = 0; i < length; i++){\n\t        mean+=y[i];\n\t    }\n\t    mean/=length;\n\t    var averageDeviations = new Array(length);\n\t    for (i = 0; i < length; i++)\n\t        averageDeviations[i] = Math.abs(y[i] - mean);\n\t    averageDeviations.sort();\n\t    if (length % 2 == 1) {\n\t        stddev = averageDeviations[(length-1)/2] / 0.6745;\n\t    } else {\n\t        stddev = 0.5*(averageDeviations[length/2]+averageDeviations[length/2-1]) / 0.6745;\n\t    }\n\t\n\t    return stddev;\n\t}\n\t\n\tfunction realTopDetection(peakList, x, y){\n\t    //console.log(peakList);\n\t    //console.log(x);\n\t    //console.log(y);\n\t    var listP = [];\n\t    var alpha, beta, gamma, p,currentPoint;\n\t    for(var j=0;j<peakList.length;j++){\n\t        currentPoint = peakList[j].i;//peakList[j][2];\n\t        var tmp = currentPoint;\n\t        //The detected peak could be moved 1 or 2 unit to left or right.\n\t        if(y[currentPoint-1]>=y[currentPoint-2]\n\t            &&y[currentPoint-1]>=y[currentPoint]) {\n\t            currentPoint--;\n\t        }\n\t        else{\n\t            if(y[currentPoint+1]>=y[currentPoint]\n\t                &&y[currentPoint+1]>=y[currentPoint+2]) {\n\t                currentPoint++;\n\t            }\n\t            else{\n\t                if(y[currentPoint-2]>=y[currentPoint-3]\n\t                    &&y[currentPoint-2]>=y[currentPoint-1]) {\n\t                    currentPoint-=2;\n\t                }\n\t                else{\n\t                    if(y[currentPoint+2]>=y[currentPoint+1]\n\t                        &&y[currentPoint+2]>=y[currentPoint+3]) {\n\t                        currentPoint+=2;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if(y[currentPoint-1]>0&&y[currentPoint+1]>0\n\t            &&y[currentPoint]>=y[currentPoint-1]\n\t            &&y[currentPoint]>=y[currentPoint+1]) {\n\t            alpha = 20 * Math.log10(y[currentPoint - 1]);\n\t            beta = 20 * Math.log10(y[currentPoint]);\n\t            gamma = 20 * Math.log10(y[currentPoint + 1]);\n\t            p = 0.5 * (alpha - gamma) / (alpha - 2 * beta + gamma);\n\t            //console.log(\"p: \"+p);\n\t            //console.log(x[currentPoint]+\" \"+tmp+\" \"+currentPoint);\n\t            peakList[j].x = x[currentPoint] + (x[currentPoint]-x[currentPoint-1])*p;\n\t            peakList[j].y = y[currentPoint] - 0.25 * (y[currentPoint - 1]\n\t                - y[currentPoint + 1]) * p;//signal.peaks[j].intensity);\n\t            //console.log(y[tmp]+\" \"+peakList[j].y);\n\t        }\n\t    }\n\t}\n\t\n\tmodule.exports=gsd;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.array = __webpack_require__(17);\n\texports.matrix = __webpack_require__(18);\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction compareNumbers(a, b) {\n\t    return a - b;\n\t}\n\t\n\t/**\n\t * Computes the sum of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.sum = function sum(values) {\n\t    var sum = 0;\n\t    for (var i = 0; i < values.length; i++) {\n\t        sum += values[i];\n\t    }\n\t    return sum;\n\t};\n\t\n\t/**\n\t * Computes the maximum of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.max = function max(values) {\n\t    var max = -Infinity;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        if (values[i] > max) max = values[i];\n\t    }\n\t    return max;\n\t};\n\t\n\t/**\n\t * Computes the minimum of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.min = function min(values) {\n\t    var min = Infinity;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        if (values[i] < min) min = values[i];\n\t    }\n\t    return min;\n\t};\n\t\n\t/**\n\t * Computes the min and max of the given values\n\t * @param {Array} values\n\t * @returns {{min: number, max: number}}\n\t */\n\texports.minMax = function minMax(values) {\n\t    var min = Infinity;\n\t    var max = -Infinity;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        if (values[i] < min) min = values[i];\n\t        if (values[i] > max) max = values[i];\n\t    }\n\t    return {\n\t        min: min,\n\t        max: max\n\t    };\n\t};\n\t\n\t/**\n\t * Computes the arithmetic mean of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.arithmeticMean = function arithmeticMean(values) {\n\t    var sum = 0;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        sum += values[i];\n\t    }\n\t    return sum / l;\n\t};\n\t\n\t/**\n\t * {@link arithmeticMean}\n\t */\n\texports.mean = exports.arithmeticMean;\n\t\n\t/**\n\t * Computes the geometric mean of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.geometricMean = function geometricMean(values) {\n\t    var mul = 1;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        mul *= values[i];\n\t    }\n\t    return Math.pow(mul, 1 / l);\n\t};\n\t\n\t/**\n\t * Computes the mean of the log of the given values\n\t * If the return value is exponentiated, it gives the same result as the\n\t * geometric mean.\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.logMean = function logMean(values) {\n\t    var lnsum = 0;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        lnsum += Math.log(values[i]);\n\t    }\n\t    return lnsum / l;\n\t};\n\t\n\t/**\n\t * Computes the weighted grand mean for a list of means and sample sizes\n\t * @param {Array} means - Mean values for each set of samples\n\t * @param {Array} samples - Number of original values for each set of samples\n\t * @returns {number}\n\t */\n\texports.grandMean = function grandMean(means, samples) {\n\t    var sum = 0;\n\t    var n = 0;\n\t    var l = means.length;\n\t    for (var i = 0; i < l; i++) {\n\t        sum += samples[i] * means[i];\n\t        n += samples[i];\n\t    }\n\t    return sum / n;\n\t};\n\t\n\t/**\n\t * Computes the truncated mean of the given values using a given percentage\n\t * @param {Array} values\n\t * @param {number} percent - The percentage of values to keep (range: [0,1])\n\t * @param {boolean} [alreadySorted=false]\n\t * @returns {number}\n\t */\n\texports.truncatedMean = function truncatedMean(values, percent, alreadySorted) {\n\t    if (alreadySorted === undefined) alreadySorted = false;\n\t    if (!alreadySorted) {\n\t        values = values.slice().sort(compareNumbers);\n\t    }\n\t    var l = values.length;\n\t    var k = Math.floor(l * percent);\n\t    var sum = 0;\n\t    for (var i = k; i < (l - k); i++) {\n\t        sum += values[i];\n\t    }\n\t    return sum / (l - 2 * k);\n\t};\n\t\n\t/**\n\t * Computes the harmonic mean of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.harmonicMean = function harmonicMean(values) {\n\t    var sum = 0;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        if (values[i] === 0) {\n\t            throw new RangeError('value at index ' + i + 'is zero');\n\t        }\n\t        sum += 1 / values[i];\n\t    }\n\t    return l / sum;\n\t};\n\t\n\t/**\n\t * Computes the contraharmonic mean of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.contraHarmonicMean = function contraHarmonicMean(values) {\n\t    var r1 = 0;\n\t    var r2 = 0;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        r1 += values[i] * values[i];\n\t        r2 += values[i];\n\t    }\n\t    if (r2 < 0) {\n\t        throw new RangeError('sum of values is negative');\n\t    }\n\t    return r1 / r2;\n\t};\n\t\n\t/**\n\t * Computes the median of the given values\n\t * @param {Array} values\n\t * @param {boolean} [alreadySorted=false]\n\t * @returns {number}\n\t */\n\texports.median = function median(values, alreadySorted) {\n\t    if (alreadySorted === undefined) alreadySorted = false;\n\t    if (!alreadySorted) {\n\t        values = values.slice().sort(compareNumbers);\n\t    }\n\t    var l = values.length;\n\t    var half = Math.floor(l / 2);\n\t    if (l % 2 === 0) {\n\t        return (values[half - 1] + values[half]) * 0.5;\n\t    } else {\n\t        return values[half];\n\t    }\n\t};\n\t\n\t/**\n\t * Computes the variance of the given values\n\t * @param {Array} values\n\t * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n\t * @returns {number}\n\t */\n\texports.variance = function variance(values, unbiased) {\n\t    if (unbiased === undefined) unbiased = true;\n\t    var theMean = exports.mean(values);\n\t    var theVariance = 0;\n\t    var l = values.length;\n\t\n\t    for (var i = 0; i < l; i++) {\n\t        var x = values[i] - theMean;\n\t        theVariance += x * x;\n\t    }\n\t\n\t    if (unbiased) {\n\t        return theVariance / (l - 1);\n\t    } else {\n\t        return theVariance / l;\n\t    }\n\t};\n\t\n\t/**\n\t * Computes the standard deviation of the given values\n\t * @param {Array} values\n\t * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n\t * @returns {number}\n\t */\n\texports.standardDeviation = function standardDeviation(values, unbiased) {\n\t    return Math.sqrt(exports.variance(values, unbiased));\n\t};\n\t\n\texports.standardError = function standardError(values) {\n\t    return exports.standardDeviation(values) / Math.sqrt(values.length);\n\t};\n\t\n\texports.quartiles = function quartiles(values, alreadySorted) {\n\t    if (typeof(alreadySorted) === 'undefined') alreadySorted = false;\n\t    if (!alreadySorted) {\n\t        values = values.slice();\n\t        values.sort(compareNumbers);\n\t    }\n\t\n\t    var quart = values.length / 4;\n\t    var q1 = values[Math.ceil(quart) - 1];\n\t    var q2 = exports.median(values, true);\n\t    var q3 = values[Math.ceil(quart * 3) - 1];\n\t\n\t    return {q1: q1, q2: q2, q3: q3};\n\t};\n\t\n\texports.pooledStandardDeviation = function pooledStandardDeviation(samples, unbiased) {\n\t    return Math.sqrt(exports.pooledVariance(samples, unbiased));\n\t};\n\t\n\texports.pooledVariance = function pooledVariance(samples, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var sum = 0;\n\t    var length = 0, l = samples.length;\n\t    for (var i = 0; i < l; i++) {\n\t        var values = samples[i];\n\t        var vari = exports.variance(values);\n\t\n\t        sum += (values.length - 1) * vari;\n\t\n\t        if (unbiased)\n\t            length += values.length - 1;\n\t        else\n\t            length += values.length;\n\t    }\n\t    return sum / length;\n\t};\n\t\n\texports.mode = function mode(values) {\n\t    var l = values.length,\n\t        itemCount = new Array(l),\n\t        i;\n\t    for (i = 0; i < l; i++) {\n\t        itemCount[i] = 0;\n\t    }\n\t    var itemArray = new Array(l);\n\t    var count = 0;\n\t\n\t    for (i = 0; i < l; i++) {\n\t        var index = itemArray.indexOf(values[i]);\n\t        if (index >= 0)\n\t            itemCount[index]++;\n\t        else {\n\t            itemArray[count] = values[i];\n\t            itemCount[count] = 1;\n\t            count++;\n\t        }\n\t    }\n\t\n\t    var maxValue = 0, maxIndex = 0;\n\t    for (i = 0; i < count; i++) {\n\t        if (itemCount[i] > maxValue) {\n\t            maxValue = itemCount[i];\n\t            maxIndex = i;\n\t        }\n\t    }\n\t\n\t    return itemArray[maxIndex];\n\t};\n\t\n\texports.covariance = function covariance(vector1, vector2, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var mean1 = exports.mean(vector1);\n\t    var mean2 = exports.mean(vector2);\n\t\n\t    if (vector1.length !== vector2.length)\n\t        throw \"Vectors do not have the same dimensions\";\n\t\n\t    var cov = 0, l = vector1.length;\n\t    for (var i = 0; i < l; i++) {\n\t        var x = vector1[i] - mean1;\n\t        var y = vector2[i] - mean2;\n\t        cov += x * y;\n\t    }\n\t\n\t    if (unbiased)\n\t        return cov / (l - 1);\n\t    else\n\t        return cov / l;\n\t};\n\t\n\texports.skewness = function skewness(values, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var theMean = exports.mean(values);\n\t\n\t    var s2 = 0, s3 = 0, l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        var dev = values[i] - theMean;\n\t        s2 += dev * dev;\n\t        s3 += dev * dev * dev;\n\t    }\n\t    var m2 = s2 / l;\n\t    var m3 = s3 / l;\n\t\n\t    var g = m3 / (Math.pow(m2, 3 / 2.0));\n\t    if (unbiased) {\n\t        var a = Math.sqrt(l * (l - 1));\n\t        var b = l - 2;\n\t        return (a / b) * g;\n\t    }\n\t    else {\n\t        return g;\n\t    }\n\t};\n\t\n\texports.kurtosis = function kurtosis(values, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var theMean = exports.mean(values);\n\t    var n = values.length, s2 = 0, s4 = 0;\n\t\n\t    for (var i = 0; i < n; i++) {\n\t        var dev = values[i] - theMean;\n\t        s2 += dev * dev;\n\t        s4 += dev * dev * dev * dev;\n\t    }\n\t    var m2 = s2 / n;\n\t    var m4 = s4 / n;\n\t\n\t    if (unbiased) {\n\t        var v = s2 / (n - 1);\n\t        var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n\t        var b = s4 / (v * v);\n\t        var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n\t\n\t        return a * b - 3 * c;\n\t    }\n\t    else {\n\t        return m4 / (m2 * m2) - 3;\n\t    }\n\t};\n\t\n\texports.entropy = function entropy(values, eps) {\n\t    if (typeof(eps) === 'undefined') eps = 0;\n\t    var sum = 0, l = values.length;\n\t    for (var i = 0; i < l; i++)\n\t        sum += values[i] * Math.log(values[i] + eps);\n\t    return -sum;\n\t};\n\t\n\texports.weightedMean = function weightedMean(values, weights) {\n\t    var sum = 0, l = values.length;\n\t    for (var i = 0; i < l; i++)\n\t        sum += values[i] * weights[i];\n\t    return sum;\n\t};\n\t\n\texports.weightedStandardDeviation = function weightedStandardDeviation(values, weights) {\n\t    return Math.sqrt(exports.weightedVariance(values, weights));\n\t};\n\t\n\texports.weightedVariance = function weightedVariance(values, weights) {\n\t    var theMean = exports.weightedMean(values, weights);\n\t    var vari = 0, l = values.length;\n\t    var a = 0, b = 0;\n\t\n\t    for (var i = 0; i < l; i++) {\n\t        var z = values[i] - theMean;\n\t        var w = weights[i];\n\t\n\t        vari += w * (z * z);\n\t        b += w;\n\t        a += w * w;\n\t    }\n\t\n\t    return vari * (b / (b * b - a));\n\t};\n\t\n\texports.center = function center(values, inPlace) {\n\t    if (typeof(inPlace) === 'undefined') inPlace = false;\n\t\n\t    var result = values;\n\t    if (!inPlace)\n\t        result = values.slice();\n\t\n\t    var theMean = exports.mean(result), l = result.length;\n\t    for (var i = 0; i < l; i++)\n\t        result[i] -= theMean;\n\t};\n\t\n\texports.standardize = function standardize(values, standardDev, inPlace) {\n\t    if (typeof(standardDev) === 'undefined') standardDev = exports.standardDeviation(values);\n\t    if (typeof(inPlace) === 'undefined') inPlace = false;\n\t    var l = values.length;\n\t    var result = inPlace ? values : new Array(l);\n\t    for (var i = 0; i < l; i++)\n\t        result[i] = values[i] / standardDev;\n\t    return result;\n\t};\n\t\n\texports.cumulativeSum = function cumulativeSum(array) {\n\t    var l = array.length;\n\t    var result = new Array(l);\n\t    result[0] = array[0];\n\t    for (var i = 1; i < l; i++)\n\t        result[i] = result[i - 1] + array[i];\n\t    return result;\n\t};\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar arrayStat = __webpack_require__(17);\n\t\n\t// https://github.com/accord-net/framework/blob/development/Sources/Accord.Statistics/Tools.cs\n\t\n\tfunction entropy(matrix, eps) {\n\t    if (typeof(eps) === 'undefined') {\n\t        eps = 0;\n\t    }\n\t    var sum = 0,\n\t        l1 = matrix.length,\n\t        l2 = matrix[0].length;\n\t    for (var i = 0; i < l1; i++) {\n\t        for (var j = 0; j < l2; j++) {\n\t            sum += matrix[i][j] * Math.log(matrix[i][j] + eps);\n\t        }\n\t    }\n\t    return -sum;\n\t}\n\t\n\tfunction mean(matrix, dimension) {\n\t    if (typeof(dimension) === 'undefined') {\n\t        dimension = 0;\n\t    }\n\t    var rows = matrix.length,\n\t        cols = matrix[0].length,\n\t        theMean, N, i, j;\n\t\n\t    if (dimension === -1) {\n\t        theMean = [0];\n\t        N = rows * cols;\n\t        for (i = 0; i < rows; i++) {\n\t            for (j = 0; j < cols; j++) {\n\t                theMean[0] += matrix[i][j];\n\t            }\n\t        }\n\t        theMean[0] /= N;\n\t    } else if (dimension === 0) {\n\t        theMean = new Array(cols);\n\t        N = rows;\n\t        for (j = 0; j < cols; j++) {\n\t            theMean[j] = 0;\n\t            for (i = 0; i < rows; i++) {\n\t                theMean[j] += matrix[i][j];\n\t            }\n\t            theMean[j] /= N;\n\t        }\n\t    } else if (dimension === 1) {\n\t        theMean = new Array(rows);\n\t        N = cols;\n\t        for (j = 0; j < rows; j++) {\n\t            theMean[j] = 0;\n\t            for (i = 0; i < cols; i++) {\n\t                theMean[j] += matrix[j][i];\n\t            }\n\t            theMean[j] /= N;\n\t        }\n\t    } else {\n\t        throw new Error('Invalid dimension');\n\t    }\n\t    return theMean;\n\t}\n\t\n\tfunction standardDeviation(matrix, means, unbiased) {\n\t    var vari = variance(matrix, means, unbiased), l = vari.length;\n\t    for (var i = 0; i < l; i++) {\n\t        vari[i] = Math.sqrt(vari[i]);\n\t    }\n\t    return vari;\n\t}\n\t\n\tfunction variance(matrix, means, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') {\n\t        unbiased = true;\n\t    }\n\t    means = means || mean(matrix);\n\t    var rows = matrix.length;\n\t    if (rows === 0) return [];\n\t    var cols = matrix[0].length;\n\t    var vari = new Array(cols);\n\t\n\t    for (var j = 0; j < cols; j++) {\n\t        var sum1 = 0, sum2 = 0, x = 0;\n\t        for (var i = 0; i < rows; i++) {\n\t            x = matrix[i][j] - means[j];\n\t            sum1 += x;\n\t            sum2 += x * x;\n\t        }\n\t        if (unbiased) {\n\t            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / (rows - 1);\n\t        } else {\n\t            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / rows;\n\t        }\n\t    }\n\t    return vari;\n\t}\n\t\n\tfunction median(matrix) {\n\t    var rows = matrix.length, cols = matrix[0].length;\n\t    var medians = new Array(cols);\n\t\n\t    for (var i = 0; i < cols; i++) {\n\t        var data = new Array(rows);\n\t        for (var j = 0; j < rows; j++) {\n\t            data[j] = matrix[j][i];\n\t        }\n\t        data.sort();\n\t        var N = data.length;\n\t        if (N % 2 === 0) {\n\t            medians[i] = (data[N / 2] + data[(N / 2) - 1]) * 0.5;\n\t        } else {\n\t            medians[i] = data[Math.floor(N / 2)];\n\t        }\n\t    }\n\t    return medians;\n\t}\n\t\n\tfunction mode(matrix) {\n\t    var rows = matrix.length,\n\t        cols = matrix[0].length,\n\t        modes = new Array(cols),\n\t        i, j;\n\t    for (i = 0; i < cols; i++) {\n\t        var itemCount = new Array(rows);\n\t        for (var k = 0; k < rows; k++) {\n\t            itemCount[k] = 0;\n\t        }\n\t        var itemArray = new Array(rows);\n\t        var count = 0;\n\t\n\t        for (j = 0; j < rows; j++) {\n\t            var index = itemArray.indexOf(matrix[j][i]);\n\t            if (index >= 0) {\n\t                itemCount[index]++;\n\t            } else {\n\t                itemArray[count] = matrix[j][i];\n\t                itemCount[count] = 1;\n\t                count++;\n\t            }\n\t        }\n\t\n\t        var maxValue = 0, maxIndex = 0;\n\t        for (j = 0; j < count; j++) {\n\t            if (itemCount[j] > maxValue) {\n\t                maxValue = itemCount[j];\n\t                maxIndex = j;\n\t            }\n\t        }\n\t\n\t        modes[i] = itemArray[maxIndex];\n\t    }\n\t    return modes;\n\t}\n\t\n\tfunction skewness(matrix, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var means = mean(matrix);\n\t    var n = matrix.length, l = means.length;\n\t    var skew = new Array(l);\n\t\n\t    for (var j = 0; j < l; j++) {\n\t        var s2 = 0, s3 = 0;\n\t        for (var i = 0; i < n; i++) {\n\t            var dev = matrix[i][j] - means[j];\n\t            s2 += dev * dev;\n\t            s3 += dev * dev * dev;\n\t        }\n\t\n\t        var m2 = s2 / n;\n\t        var m3 = s3 / n;\n\t        var g = m3 / Math.pow(m2, 3 / 2);\n\t\n\t        if (unbiased) {\n\t            var a = Math.sqrt(n * (n - 1));\n\t            var b = n - 2;\n\t            skew[j] = (a / b) * g;\n\t        } else {\n\t            skew[j] = g;\n\t        }\n\t    }\n\t    return skew;\n\t}\n\t\n\tfunction kurtosis(matrix, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var means = mean(matrix);\n\t    var n = matrix.length, m = matrix[0].length;\n\t    var kurt = new Array(m);\n\t\n\t    for (var j = 0; j < m; j++) {\n\t        var s2 = 0, s4 = 0;\n\t        for (var i = 0; i < n; i++) {\n\t            var dev = matrix[i][j] - means[j];\n\t            s2 += dev * dev;\n\t            s4 += dev * dev * dev * dev;\n\t        }\n\t        var m2 = s2 / n;\n\t        var m4 = s4 / n;\n\t\n\t        if (unbiased) {\n\t            var v = s2 / (n - 1);\n\t            var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n\t            var b = s4 / (v * v);\n\t            var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n\t            kurt[j] = a * b - 3 * c;\n\t        } else {\n\t            kurt[j] = m4 / (m2 * m2) - 3;\n\t        }\n\t    }\n\t    return kurt;\n\t}\n\t\n\tfunction standardError(matrix) {\n\t    var samples = matrix.length;\n\t    var standardDeviations = standardDeviation(matrix), l = standardDeviations.length;\n\t    var standardErrors = new Array(l);\n\t    var sqrtN = Math.sqrt(samples);\n\t\n\t    for (var i = 0; i < l; i++) {\n\t        standardErrors[i] = standardDeviations[i] / sqrtN;\n\t    }\n\t    return standardErrors;\n\t}\n\t\n\tfunction covariance(matrix, dimension) {\n\t    return scatter(matrix, undefined, dimension);\n\t}\n\t\n\tfunction scatter(matrix, divisor, dimension) {\n\t    if (typeof(dimension) === 'undefined') {\n\t        dimension = 0;\n\t    }\n\t    if (typeof(divisor) === 'undefined') {\n\t        if (dimension === 0) {\n\t            divisor = matrix.length - 1;\n\t        } else if (dimension === 1) {\n\t            divisor = matrix[0].length - 1;\n\t        }\n\t    }\n\t    var means = mean(matrix, dimension),\n\t        rows = matrix.length;\n\t    if (rows === 0) {\n\t        return [[]];\n\t    }\n\t    var cols = matrix[0].length,\n\t        cov, i, j, s, k;\n\t\n\t    if (dimension === 0) {\n\t        cov = new Array(cols);\n\t        for (i = 0; i < cols; i++) {\n\t            cov[i] = new Array(cols);\n\t        }\n\t        for (i = 0; i < cols; i++) {\n\t            for (j = i; j < cols; j++) {\n\t                s = 0;\n\t                for (k = 0; k < rows; k++) {\n\t                    s += (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n\t                }\n\t                s /= divisor;\n\t                cov[i][j] = s;\n\t                cov[j][i] = s;\n\t            }\n\t        }\n\t    } else if (dimension === 1) {\n\t        cov = new Array(rows);\n\t        for (i = 0; i < rows; i++) {\n\t            cov[i] = new Array(rows);\n\t        }\n\t        for (i = 0; i < rows; i++) {\n\t            for (j = i; j < rows; j++) {\n\t                s = 0;\n\t                for (k = 0; k < cols; k++) {\n\t                    s += (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n\t                }\n\t                s /= divisor;\n\t                cov[i][j] = s;\n\t                cov[j][i] = s;\n\t            }\n\t        }\n\t    } else {\n\t        throw new Error('Invalid dimension');\n\t    }\n\t\n\t    return cov;\n\t}\n\t\n\tfunction correlation(matrix) {\n\t    var means = mean(matrix),\n\t        standardDeviations = standardDeviation(matrix, true, means),\n\t        scores = zScores(matrix, means, standardDeviations),\n\t        rows = matrix.length,\n\t        cols = matrix[0].length,\n\t        i, j;\n\t\n\t    var cor = new Array(cols);\n\t    for (i = 0; i < cols; i++) {\n\t        cor[i] = new Array(cols);\n\t    }\n\t    for (i = 0; i < cols; i++) {\n\t        for (j = i; j < cols; j++) {\n\t            var c = 0;\n\t            for (var k = 0, l = scores.length; k < l; k++) {\n\t                c += scores[k][j] * scores[k][i];\n\t            }\n\t            c /= rows - 1;\n\t            cor[i][j] = c;\n\t            cor[j][i] = c;\n\t        }\n\t    }\n\t    return cor;\n\t}\n\t\n\tfunction zScores(matrix, means, standardDeviations) {\n\t    means = means || mean(matrix);\n\t    if (typeof(standardDeviations) === 'undefined') standardDeviations = standardDeviation(matrix, true, means);\n\t    return standardize(center(matrix, means, false), standardDeviations, true);\n\t}\n\t\n\tfunction center(matrix, means, inPlace) {\n\t    means = means || mean(matrix);\n\t    var result = matrix,\n\t        l = matrix.length,\n\t        i, j, jj;\n\t\n\t    if (!inPlace) {\n\t        result = new Array(l);\n\t        for (i = 0; i < l; i++) {\n\t            result[i] = new Array(matrix[i].length);\n\t        }\n\t    }\n\t\n\t    for (i = 0; i < l; i++) {\n\t        var row = result[i];\n\t        for (j = 0, jj = row.length; j < jj; j++) {\n\t            row[j] = matrix[i][j] - means[j];\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction standardize(matrix, standardDeviations, inPlace) {\n\t    if (typeof(standardDeviations) === 'undefined') standardDeviations = standardDeviation(matrix);\n\t    var result = matrix,\n\t        l = matrix.length,\n\t        i, j, jj;\n\t\n\t    if (!inPlace) {\n\t        result = new Array(l);\n\t        for (i = 0; i < l; i++) {\n\t            result[i] = new Array(matrix[i].length);\n\t        }\n\t    }\n\t\n\t    for (i = 0; i < l; i++) {\n\t        var resultRow = result[i];\n\t        var sourceRow = matrix[i];\n\t        for (j = 0, jj = resultRow.length; j < jj; j++) {\n\t            if (standardDeviations[j] !== 0 && !isNaN(standardDeviations[j])) {\n\t                resultRow[j] = sourceRow[j] / standardDeviations[j];\n\t            }\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction weightedVariance(matrix, weights) {\n\t    var means = mean(matrix);\n\t    var rows = matrix.length;\n\t    if (rows === 0) return [];\n\t    var cols = matrix[0].length;\n\t    var vari = new Array(cols);\n\t\n\t    for (var j = 0; j < cols; j++) {\n\t        var sum = 0;\n\t        var a = 0, b = 0;\n\t\n\t        for (var i = 0; i < rows; i++) {\n\t            var z = matrix[i][j] - means[j];\n\t            var w = weights[i];\n\t\n\t            sum += w * (z * z);\n\t            b += w;\n\t            a += w * w;\n\t        }\n\t\n\t        vari[j] = sum * (b / (b * b - a));\n\t    }\n\t\n\t    return vari;\n\t}\n\t\n\tfunction weightedMean(matrix, weights, dimension) {\n\t    if (typeof(dimension) === 'undefined') {\n\t        dimension = 0;\n\t    }\n\t    var rows = matrix.length;\n\t    if (rows === 0) return [];\n\t    var cols = matrix[0].length,\n\t        means, i, ii, j, w, row;\n\t\n\t    if (dimension === 0) {\n\t        means = new Array(cols);\n\t        for (i = 0; i < cols; i++) {\n\t            means[i] = 0;\n\t        }\n\t        for (i = 0; i < rows; i++) {\n\t            row = matrix[i];\n\t            w = weights[i];\n\t            for (j = 0; j < cols; j++) {\n\t                means[j] += row[j] * w;\n\t            }\n\t        }\n\t    } else if (dimension === 1) {\n\t        means = new Array(rows);\n\t        for (i = 0; i < rows; i++) {\n\t            means[i] = 0;\n\t        }\n\t        for (j = 0; j < rows; j++) {\n\t            row = matrix[j];\n\t            w = weights[j];\n\t            for (i = 0; i < cols; i++) {\n\t                means[j] += row[i] * w;\n\t            }\n\t        }\n\t    } else {\n\t        throw new Error('Invalid dimension');\n\t    }\n\t\n\t    var weightSum = arrayStat.sum(weights);\n\t    if (weightSum !== 0) {\n\t        for (i = 0, ii = means.length; i < ii; i++) {\n\t            means[i] /= weightSum;\n\t        }\n\t    }\n\t    return means;\n\t}\n\t\n\tfunction weightedCovariance(matrix, weights, means, dimension) {\n\t    dimension = dimension || 0;\n\t    means = means || weightedMean(matrix, weights, dimension);\n\t    var s1 = 0, s2 = 0;\n\t    for (var i = 0, ii = weights.length; i < ii; i++) {\n\t        s1 += weights[i];\n\t        s2 += weights[i] * weights[i];\n\t    }\n\t    var factor = s1 / (s1 * s1 - s2);\n\t    return weightedScatter(matrix, weights, means, factor, dimension);\n\t}\n\t\n\tfunction weightedScatter(matrix, weights, means, factor, dimension) {\n\t    dimension = dimension || 0;\n\t    means = means || weightedMean(matrix, weights, dimension);\n\t    if (typeof(factor) === 'undefined') {\n\t        factor = 1;\n\t    }\n\t    var rows = matrix.length;\n\t    if (rows === 0) {\n\t        return [[]];\n\t    }\n\t    var cols = matrix[0].length,\n\t        cov, i, j, k, s;\n\t\n\t    if (dimension === 0) {\n\t        cov = new Array(cols);\n\t        for (i = 0; i < cols; i++) {\n\t            cov[i] = new Array(cols);\n\t        }\n\t        for (i = 0; i < cols; i++) {\n\t            for (j = i; j < cols; j++) {\n\t                s = 0;\n\t                for (k = 0; k < rows; k++) {\n\t                    s += weights[k] * (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n\t                }\n\t                cov[i][j] = s * factor;\n\t                cov[j][i] = s * factor;\n\t            }\n\t        }\n\t    } else if (dimension === 1) {\n\t        cov = new Array(rows);\n\t        for (i = 0; i < rows; i++) {\n\t            cov[i] = new Array(rows);\n\t        }\n\t        for (i = 0; i < rows; i++) {\n\t            for (j = i; j < rows; j++) {\n\t                s = 0;\n\t                for (k = 0; k < cols; k++) {\n\t                    s += weights[k] * (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n\t                }\n\t                cov[i][j] = s * factor;\n\t                cov[j][i] = s * factor;\n\t            }\n\t        }\n\t    } else {\n\t        throw new Error('Invalid dimension');\n\t    }\n\t\n\t    return cov;\n\t}\n\t\n\tmodule.exports = {\n\t    entropy: entropy,\n\t    mean: mean,\n\t    standardDeviation: standardDeviation,\n\t    variance: variance,\n\t    median: median,\n\t    mode: mode,\n\t    skewness: skewness,\n\t    kurtosis: kurtosis,\n\t    standardError: standardError,\n\t    covariance: covariance,\n\t    scatter: scatter,\n\t    correlation: correlation,\n\t    zScores: zScores,\n\t    center: center,\n\t    standardize: standardize,\n\t    weightedVariance: weightedVariance,\n\t    weightedMean: weightedMean,\n\t    weightedCovariance: weightedCovariance,\n\t    weightedScatter: weightedScatter\n\t};\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\t\n\tvar isArray = function isArray(arr) {\n\t\tif (typeof Array.isArray === 'function') {\n\t\t\treturn Array.isArray(arr);\n\t\t}\n\t\n\t\treturn toStr.call(arr) === '[object Array]';\n\t};\n\t\n\tvar isPlainObject = function isPlainObject(obj) {\n\t\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\t\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t\t// Not own constructor property must be Object\n\t\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t// if last one is own, then all properties are own.\n\t\tvar key;\n\t\tfor (key in obj) {/**/}\n\t\n\t\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n\t};\n\t\n\tmodule.exports = function extend() {\n\t\tvar options, name, src, copy, copyIsArray, clone,\n\t\t\ttarget = arguments[0],\n\t\t\ti = 1,\n\t\t\tlength = arguments.length,\n\t\t\tdeep = false;\n\t\n\t\t// Handle a deep copy situation\n\t\tif (typeof target === 'boolean') {\n\t\t\tdeep = target;\n\t\t\ttarget = arguments[1] || {};\n\t\t\t// skip the boolean and the target\n\t\t\ti = 2;\n\t\t} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {\n\t\t\ttarget = {};\n\t\t}\n\t\n\t\tfor (; i < length; ++i) {\n\t\t\toptions = arguments[i];\n\t\t\t// Only deal with non-null/undefined values\n\t\t\tif (options != null) {\n\t\t\t\t// Extend the base object\n\t\t\t\tfor (name in options) {\n\t\t\t\t\tsrc = target[name];\n\t\t\t\t\tcopy = options[name];\n\t\n\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\tif (target !== copy) {\n\t\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\t\n\t\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the modified object\n\t\treturn target;\n\t};\n\t\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//Code translate from Pascal source in http://pubs.acs.org/doi/pdf/10.1021/ac00205a007\n\tvar extend = __webpack_require__(19);\n\tvar stat = __webpack_require__(16);\n\t\n\tvar defaultOptions = {\n\t    windowSize: 9,\n\t    derivative: 0,\n\t    polynomial: 3,\n\t};\n\t\n\t\n\tfunction SavitzkyGolay(data, h, options) {\n\t    options = extend({}, defaultOptions, options);\n\t\n\t    if ((options.windowSize % 2 === 0) || (options.windowSize < 5) || !(Number.isInteger(options.windowSize)))\n\t            throw new RangeError('Invalid window size (should be odd and at least 5 integer number)')\n\t\n\t\n\t    if (options.windowSize>data.length)\n\t        throw new RangeError('Window size is higher than the data length '+options.windowSize+\">\"+data.length);\n\t    if ((options.derivative < 0) || !(Number.isInteger(options.derivative)))\n\t        throw new RangeError('Derivative should be a positive integer');\n\t    if ((options.polynomial < 1) || !(Number.isInteger(options.polynomial)))\n\t        throw new RangeError('Polynomial should be a positive integer');\n\t    if (options.polynomial >= 6)\n\t        console.warn('You should not use polynomial grade higher than 5 if you are' +\n\t            ' not sure that your data arises from such a model. Possible polynomial oscillation problems');\n\t\n\t    var windowSize = options.windowSize;\n\t\n\t    var half = Math.floor(windowSize/2);\n\t    var np = data.length;\n\t    var ans = new Array(np);\n\t    var weights = fullWeights(windowSize,options.polynomial,options.derivative);\n\t    var hs = 0;\n\t    var constantH = true;\n\t    if( Object.prototype.toString.call( h ) === '[object Array]' ) {\n\t        constantH = false;\n\t    }\n\t    else{\n\t        hs = Math.pow(h, options.derivative);\n\t    }\n\t    //console.log(\"Constant h: \"+constantH);\n\t    //For the borders\n\t    for(var i=0;i<half;i++){\n\t        var wg1=weights[half-i-1];\n\t        var wg2=weights[half+i+1];\n\t        var d1 = 0,d2=0;\n\t        for (var l = 0; l < windowSize; l++){\n\t            d1 += wg1[l] * data[l];\n\t            d2 += wg2[l] * data[np-windowSize+l-1];\n\t        }\n\t        if(constantH){\n\t            ans[half-i-1] = d1/hs;\n\t            ans[np-half+i] = d2/hs;\n\t        }\n\t        else{\n\t            hs = getHs(h,half-i-1,half, options.derivative);\n\t            ans[half-i-1] = d1/hs;\n\t            hs = getHs(h,np-half+i,half, options.derivative);\n\t            ans[np-half+i] = d2/hs;\n\t        }\n\t    }\n\t    //For the internal points\n\t    var wg = weights[half];\n\t    for(var i=windowSize;i<np+1;i++){\n\t        var d = 0;\n\t        for (var l = 0; l < windowSize; l++)\n\t            d += wg[l] * data[l+i-windowSize];\n\t        if(!constantH)\n\t            hs = getHs(h,i-half-1,half, options.derivative);\n\t        ans[i-half-1] = d/hs;\n\t    }\n\t    return ans;\n\t}\n\t\n\tfunction getHs(h,center,half,derivative){\n\t    var hs = 0;\n\t    var count = 0;\n\t    for(var i=center-half;i<center+half;i++){\n\t        if(i>=0 && i < h.length-1){\n\t            hs+= (h[i+1]-h[i]);\n\t            count++;\n\t        }\n\t    }\n\t    return Math.pow(hs/count,derivative);\n\t}\n\t\n\tfunction GramPoly(i,m,k,s){\n\t    var Grampoly = 0;\n\t    if(k>0){\n\t        Grampoly = (4*k-2)/(k*(2*m-k+1))*(i*GramPoly(i,m,k-1,s) +\n\t            s*GramPoly(i,m,k-1,s-1)) - ((k-1)*(2*m+k))/(k*(2*m-k+1))*GramPoly(i,m,k-2,s);\n\t    }\n\t    else{\n\t        if(k==0&&s==0){\n\t            Grampoly=1;\n\t        }\n\t        else{\n\t            Grampoly=0;\n\t        }\n\t    }\n\t    //console.log(Grampoly);\n\t    return Grampoly;\n\t}\n\t\n\tfunction GenFact(a,b){\n\t    var gf=1;\n\t    if(a>=b){\n\t        for(var j=a-b+1;j<=a;j++){\n\t            gf*=j;\n\t        }\n\t    }\n\t    return gf;\n\t}\n\t\n\tfunction Weight(i,t,m,n,s){\n\t    var sum=0;\n\t    for(var k=0;k<=n;k++){\n\t        //console.log(k);\n\t        sum+=(2*k+1)*(GenFact(2*m,k)/GenFact(2*m+k+1,k+1))*GramPoly(i,m,k,0)*GramPoly(t,m,k,s)\n\t    }\n\t    return sum;\n\t}\n\t\n\t/**\n\t *\n\t * @param m  Number of points\n\t * @param n  Polynomial grade\n\t * @param s  Derivative\n\t */\n\tfunction fullWeights(m,n,s){\n\t    var weights = new Array(m);\n\t    var np = Math.floor(m/2);\n\t    for(var t=-np;t<=np;t++){\n\t        weights[t+np] = new Array(m);\n\t        for(var j=-np;j<=np;j++){\n\t            weights[t+np][j+np]=Weight(j,t,np,n,s);\n\t        }\n\t    }\n\t    return weights;\n\t}\n\t\n\t/*function entropy(data,h,options){\n\t    var trend = SavitzkyGolay(data,h,trendOptions);\n\t    var copy = new Array(data.length);\n\t    var sum = 0;\n\t    var max = 0;\n\t    for(var i=0;i<data.length;i++){\n\t        copy[i] = data[i]-trend[i];\n\t    }\n\t\n\t    sum/=data.length;\n\t    console.log(sum+\" \"+max);\n\t    console.log(stat.array.standardDeviation(copy));\n\t    console.log(Math.abs(stat.array.mean(copy))/stat.array.standardDeviation(copy));\n\t    return sum;\n\t\n\t}\n\t\n\t\n\t\n\tfunction guessWindowSize(data, h){\n\t    console.log(\"entropy \"+entropy(data,h,trendOptions));\n\t    return 5;\n\t}\n\t*/\n\tmodule.exports = SavitzkyGolay;\n\t \n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** ml-gsd.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 37f777454acc770acd3c\n **/","\nmodule.exports.post = require(\"../src/optimize\");\nmodule.exports.gsd = require(\"../src/gsd\");\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","/**\n * Created by acastillo on 9/6/15.\n */\nvar Opt = require(\"ml-optimize-lorentzian\");\n\nfunction sampleFunction(from, to, x, y, lastIndex){\n    var nbPoints = x.length;\n    var sampleX = [];\n    var sampleY = [];\n    var direction = Math.sign(x[1]-x[0]);//Direction of the derivative\n    if(direction==-1){\n        lastIndex[0]= x.length-1;\n    }\n\n    var delta = Math.abs(to-from)/2;\n    var mid = (from+to)/2;\n    var stop = false;\n    var index = lastIndex[0];\n    while(!stop&&index<nbPoints&&index>=0){\n        if(Math.abs(x[index]-mid)<=delta){\n            sampleX.push(x[index]);\n            sampleY.push(y[index]);\n            index+=direction;\n        }\n        //It is outside the range.\n        else{\n\n            if(Math.sign(mid-x[index])==1){\n                //We'll reach the mid going in the current direction\n                index+=direction;\n            }\n            else{\n                //There is not more peaks in the current range\n                stop=true;\n            }\n        }\n        //console.log(sampleX);\n    }\n    lastIndex[0]=index;\n    return [sampleX, sampleY];\n}\n\nfunction optimizePeaks(peakList,x,y,n, fnType){\n    var i, j, lastIndex=[0];\n    var groups = groupPeaks(peakList,n);\n    var result = [];\n    var factor = 1;\n    if(fnType==\"gaussian\")\n        factor = 1.17741;//From https://en.wikipedia.org/wiki/Gaussian_function#Properties\n    for(i=0;i<groups.length;i++){\n        var peaks = groups[i].group;\n        if(peaks.length>1){\n            //Multiple peaks\n            //console.log(\"Pending group of overlaped peaks \"+peaks.length);\n            //console.log(\"here1\");\n            //console.log(groups[i].limits);\n            var sampling = sampleFunction(groups[i].limits[0]-groups[i].limits[1],groups[i].limits[0]+groups[i].limits[1],x,y,lastIndex);\n            //console.log(sampling);\n            if(sampling[0].length>5){\n                var error = peaks[0].width/1000;\n                var opts = [  3,    100, error, error, error, error*10, error*10,    11,    9,        1 ];\n                //var gauss = Opt.optimizeSingleGaussian(sampling[0], sampling[1], opts, peaks);\n                var optPeaks = [];\n                if(fnType==\"gaussian\")\n                    optPeaks = Opt.optimizeGaussianSum(sampling, peaks, opts);\n                else{\n                    if(fnType==\"lorentzian\"){\n                        optPeaks = Opt.optimizeLorentzianSum(sampling, peaks, opts);\n                    }\n                }\n                //console.log(optPeak);\n                for(j=0;j<optPeaks.length;j++){\n                    result.push({x:optPeaks[j][0][0],y:optPeaks[j][1][0],width:optPeaks[j][2][0]*factor});\n                }\n            }\n        }\n        else{\n            //Single peak\n            peaks = peaks[0];\n            var sampling = sampleFunction(peaks.x-n*peaks.width,\n                peaks.x+n*peaks.width,x,y,lastIndex);\n            //console.log(\"here2\");\n            //console.log(groups[i].limits);\n            if(sampling[0].length>5){\n                var error = peaks.width/1000;\n                var opts = [  3,    100, error, error, error, error*10, error*10,    11,    9,        1 ];\n                //var gauss = Opt.optimizeSingleGaussian(sampling[0], sampling[1], opts, peaks);\n                //var gauss = Opt.optimizeSingleGaussian([sampling[0],sampling[1]], peaks, opts);\n                var optPeak = [];\n                if(fnType==\"gaussian\")\n                    var optPeak = Opt.optimizeSingleGaussian([sampling[0],sampling[1]], peaks,  opts);\n                else{\n                    if(fnType==\"lorentzian\"){\n                        var optPeak = Opt.optimizeSingleLorentzian([sampling[0],sampling[1]], peaks,  opts);\n                    }\n                }\n                //console.log(optPeak);\n                result.push({x:optPeak[0][0],y:optPeak[1][0],width:optPeak[2][0]*factor}); // From https://en.wikipedia.org/wiki/Gaussian_function#Properties}\n            }\n        }\n\n    }\n    return result;\n}\n\nfunction groupPeaks(peakList,nL){\n    var group = [];\n    var groups = [];\n    var i, j;\n    var limits = [peakList[0].x,nL*peakList[0].width];\n    var upperLimit, lowerLimit;\n    //Merge forward\n    for(i=0;i<peakList.length;i++){\n        //If the 2 things overlaps\n        if(Math.abs(peakList[i].x-limits[0])<(nL*peakList[i].width+limits[1])){\n            //Add the peak to the group\n            group.push(peakList[i]);\n            //Update the group limits\n            upperLimit = limits[0]+limits[1];\n            if(peakList[i].x+nL*peakList[i].width>upperLimit){\n                upperLimit = peakList[i].x+nL*peakList[i].width;\n            }\n            lowerLimit = limits[0]-limits[1];\n            if(peakList[i].x-nL*peakList[i].width<lowerLimit){\n                lowerLimit = peakList[i].x-nL*peakList[i].width;\n            }\n            limits = [(upperLimit+lowerLimit)/2,Math.abs(upperLimit-lowerLimit)/2];\n\n        }\n        else{\n            groups.push({limits:limits,group:group});\n            //var optmimalPeak = fitSpectrum(group,limits,spectrum);\n            group=[peakList[i]];\n            limits = [peakList[i].x,nL*peakList[i].width];\n        }\n    }\n    groups.push({limits:limits,group:group});\n    //Merge backward\n    for(i =groups.length-2;i>=0;i--){\n        //The groups overlaps\n        if(Math.abs(groups[i].limits[0]-groups[i+1].limits[0])<\n            (groups[i].limits[1]+groups[i+1].limits[1])/2){\n            for(j=0;j<groups[i+1].group.length;j++){\n                groups[i].group.push(groups[i+1].group[j]);\n            }\n            upperLimit = groups[i].limits[0]+groups[i].limits[1];\n            if(groups[i+1].limits[0]+groups[i+1].limits[1]>upperLimit){\n                upperLimit = groups[i+1].limits[0]+groups[i+1].limits[1];\n            }\n            lowerLimit = groups[i].limits[0]-groups[i].limits[1];\n            if(groups[i+1].limits[0]-groups[i+1].limits[1]<lowerLimit){\n                lowerLimit = groups[i+1].limits[0]-groups[i+1].limits[1];\n            }\n            //console.log(limits);\n            groups[i].limits = [(upperLimit+lowerLimit)/2,Math.abs(upperLimit-lowerLimit)/2];\n\n            groups.splice(i+1,1);\n        }\n    }\n    return groups;\n}\n/**\n * This function try to join the peaks that seems to belong to a broad signal in a single broad peak.\n * @param peakList\n * @param options\n */\nfunction joinBroadPeaks(peakList, options){\n    var width = options.width;\n    var broadLines=[];\n    //Optimize the possible broad lines\n    var max=0, maxI=0,count=1;\n    var isPartOf = false;\n    for(var i=peakList.length-1;i>=0;i--){\n        if(peakList[i].soft){\n            broadLines.push(peakList.splice(i,1)[0]);\n        }\n    }\n    //Push a feak peak\n    broadLines.push({x:Number.MAX_VALUE});\n\n    var candidates = [[broadLines[0].x,\n                        broadLines[0].y]];\n    var indexes = [0];\n\n    for(var i=1;i<broadLines.length;i++){\n        //console.log(broadLines[i-1].x+\" \"+broadLines[i].x);\n        if(Math.abs(broadLines[i-1].x-broadLines[i].x)<width){\n            candidates.push([broadLines[i].x,broadLines[i].y]);\n            if(broadLines[i].y>max){\n                max = broadLines[i].y;\n                maxI = i;\n            }\n            indexes.push(i);\n            count++;\n        }\n        else{\n            if(count>2){\n                var fitted =  Opt.optimizeSingleLorentzian(candidates,\n                    {x: broadLines[maxI].x, y:max, width: Math.abs(candidates[0][0]-candidates[candidates.length-1][0])});\n                peakList.push({x:fitted[0][0],y:fitted[1][0],width:fitted[2][0],soft:false});\n\n            }\n            else{\n                //Put back the candidates to the signals list\n                indexes.map(function(index){peakList.push(broadLines[index])});\n            }\n            candidates = [[broadLines[i].x,broadLines[i].y]];\n            indexes = [i];\n            max = broadLines[i].y;\n            maxI = i;\n            count = 1;\n        }\n    }\n\n    peakList.sort(function (a, b) {\n        return a.x - b.x;\n    });\n\n    return peakList;\n\n}\n\n/*if(options.broadRatio>0){\n var broadLines=[[Number.MAX_VALUE,0,0]];\n //Optimize the possible broad lines\n var max=0, maxI=0,count=0;\n var candidates = [],broadLinesS=[];\n var isPartOf = false;\n\n for(var i=broadLines.length-1;i>0;i--){\n //console.log(broadLines[i][0]+\" \"+rangeX+\" \"+Math.abs(broadLines[i-1][0]-broadLines[i][0]));\n if(Math.abs(broadLines[i-1][0]-broadLines[i][0])<rangeX){\n\n candidates.push(broadLines[i]);\n if(broadLines[i][1]>max){\n max = broadLines[i][1];\n maxI = i;\n }\n count++;\n }\n else{\n isPartOf = true;\n if(count>30){ // TODO, an options ?\n isPartOf = false;\n //for(var j=0;j<signals.length;j++){\n //    if(Math.abs(broadLines[maxI][0]-signals[j][0])<rangeX)\n //       isPartOf = true;\n //    }\n //console.log(\"Was part of \"+isPartOf);\n }\n if(isPartOf){\n for(var j=0;j<candidates.length;j++){\n signals.push([candidates[j][0], candidates[j][1], dx]);\n }\n }\n else{\n var fitted =  Opt.optimizeSingleLorentzian(candidates,{x:candidates[maxI][0],\n width:Math.abs(candidates[0][0]-candidates[candidates.length-1][0])},\n []);\n //console.log(fitted);\n signals.push([fitted[0][0],fitted[0][1],fitted[0][2]]);\n }\n candidates = [];\n max = 0;\n maxI = 0;\n count = 0;\n }\n }\n }*/\n\nmodule.exports={optimizePeaks:optimizePeaks,joinBroadPeaks:joinBroadPeaks};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/optimize.js\n ** module id = 1\n ** module chunks = 0\n **/","'use strict';\n\nvar LM = require('ml-curve-fitting');\nvar math = LM.Matrix.algebra;\nvar Matrix = require('ml-matrix');\n\n/**\n * This function calculates the spectrum as a sum of lorentzian functions. The Lorentzian\n * parameters are divided in 3 batches. 1st: centers; 2nd: heights; 3th: widths;\n * @param t Ordinate values\n * @param p Lorentzian parameters\n * @param c Constant parameters(Not used)\n * @returns {*}\n */\nfunction sumOfLorentzians(t,p,c){\n    var nL = p.length/3,factor,i, j,p2, cols = t.rows;\n    var result = Matrix.zeros(t.length,1);\n\n    for(i=0;i<nL;i++){\n        p2 = Math.pow(p[i+nL*2][0]/2,2);\n        factor = p[i+nL][0]*p2;\n        for(j=0;j<cols;j++){\n            result[j][0]+=factor/(Math.pow(t[j][0]-p[i][0],2)+p2);\n        }\n    }\n    return result;\n}\n\n/**\n * This function calculates the spectrum as a sum of gaussian functions. The Gaussian\n * parameters are divided in 3 batches. 1st: centers; 2nd: height; 3th: std's;\n * @param t Ordinate values\n * @param p Gaussian parameters\n * @param c Constant parameters(Not used)\n * @returns {*}\n */\nfunction sumOfGaussians(t,p,c){\n    var nL = p.length/3,factor,i, j, cols = t.rows;\n    var result = Matrix.zeros(t.length,1);\n\n    for(i=0;i<nL;i++){\n        factor = p[i+nL*2][0]*p[i+nL*2][0]/2;\n        for(j=0;j<cols;j++){\n            result[j][0]+=p[i+nL][0]*Math.exp(-(t[i][0]-p[i][0])*(t[i][0]-p[i][0])/factor);\n        }\n    }\n    return result;\n}\n/**\n * Single 4 parameter lorentzian function\n * @param t Ordinate values\n * @param p Lorentzian parameters\n * @param c Constant parameters(Not used)\n * @returns {*}\n */\nfunction singleLorentzian(t,p,c){\n    var factor = p[1][0]*Math.pow(p[2][0]/2,2);\n    var rows = t.rows;\n    var result = new Matrix(t.rows, t.columns);\n    for(var i=0;i<rows;i++){\n        result[i][0]=factor/(Math.pow(t[i][0]-p[0][0],2)+Math.pow(p[2][0]/2,2));\n    }\n    return result;\n}\n\n/**\n * Single 3 parameter gaussian function\n * @param t Ordinate values\n * @param p Gaussian parameters [mean, height, std]\n * @param c Constant parameters(Not used)\n * @returns {*}\n */\nfunction singleGaussian(t,p,c){\n    var factor2 = p[2][0]*p[2][0]/2;\n    var rows = t.rows;\n    var result = new Matrix(t.rows, t.columns);\n    for(var i=0;i<rows;i++){\n        result[i][0]=p[1][0]*Math.exp(-(t[i][0]-p[0][0])*(t[i][0]-p[0][0])/factor2);\n    }\n    return result;\n}\n\n/**\n * * Fits a set of points to a Lorentzian function. Returns the center of the peak, the width at half height, and the height of the signal.\n * @param data,[y]\n * @returns {*[]}\n */\nfunction optimizeSingleLorentzian(xy, peak, opts) {\n    opts = opts || {};\n    var xy2 = parseData(xy, opts.percentage||0);\n\n    if(xy2===null||xy2[0].rows<3){\n        return null; //Cannot run an optimization with less than 3 points\n    }\n\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n    var nbPoints = t.rows, i;\n\n    var weight = [nbPoints / Math.sqrt(y_data.dot(y_data))];\n\n    var opts=Object.create(opts.LMOptions || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ]);\n    //var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];\n    var consts = [ ];\n    var dt = Math.abs(t[0][0]-t[1][0]);// optional vector of constants\n    var dx = new Matrix([[-dt/10000],[-1e-3],[-dt/10000]]);//-Math.abs(t[0][0]-t[1][0])/100;\n    var p_init = new Matrix([[peak.x],[1],[peak.width]]);\n    var p_min = new Matrix([[peak.x-dt],[0.75],[peak.width/4]]);\n    var p_max = new Matrix([[peak.x+dt],[1.25],[peak.width*4]]);\n\n    var p_fit = LM.optimize(singleLorentzian,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n\n\n    p_fit = p_fit.p;\n    return [p_fit[0],[p_fit[1][0]*maxY],p_fit[2]];\n\n}\n\n/**\n * Fits a set of points to a gaussian bell. Returns the mean of the peak, the std and the height of the signal.\n * @param data,[y]\n * @returns {*[]}\n */\nfunction optimizeSingleGaussian(xy, peak, opts) {\n    opts = opts || {};\n    var xy2 = parseData(xy, opts.percentage||0);\n\n    if(xy2===null||xy2[0].rows<3){\n        return null; //Cannot run an optimization with less than 3 points\n    }\n\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n\n    var nbPoints = t.rows, i;\n\n\n\n    var weight = [nbPoints / Math.sqrt(y_data.dot(y_data))];\n\n    var opts=Object.create(opts.LMOptions || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ]);\n    //var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];\n    var consts = [ ];                         // optional vector of constants\n    var dt = Math.abs(t[0][0]-t[1][0]);\n    var dx = new Matrix([[-dt/10000],[-1e-3],[-dt/10000]]);//-Math.abs(t[0][0]-t[1][0])/100;\n\n    var dx = new Matrix([[-Math.abs(t[0][0]-t[1][0])/1000],[-1e-3],[-peak.width/1000]]);\n    var p_init = new Matrix([[peak.x],[1],[peak.width]]);\n    var p_min = new Matrix([[peak.x-dt],[0.75],[peak.width/4]]);\n    var p_max = new Matrix([[peak.x+dt],[1.25],[peak.width*4]]);\n    //var p_min = new Matrix([[peak.x-peak.width/4],[0.75],[peak.width/3]]);\n    //var p_max = new Matrix([[peak.x+peak.width/4],[1.25],[peak.width*3]]);\n\n    var p_fit = LM.optimize(singleGaussian,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n    p_fit = p_fit.p;\n    return [p_fit[0],[p_fit[1][0]*maxY],p_fit[2]];\n}\n\n/*\n peaks on group should sorted\n */\nfunction optimizeLorentzianTrain(xy, group, opts){\n    var xy2 = parseData(xy);\n    //console.log(xy2[0].rows);\n    if(xy2===null||xy2[0].rows<3){\n        return null; //Cannot run an optimization with less than 3 points\n    }\n\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n    var currentIndex = 0;\n    var nbPoints = t.length;\n    var nextX;\n    var tI, yI, maxY;\n    var result=[], current;\n    for(var i=0; i<group.length;i++){\n        nextX = group[i].x-group[i].width*4;\n        //console.log(group[i]);\n        while(t[currentIndex++]<nextX&&currentIndex<nbPoints);\n        nextX = group[i].x+group[i].width*4;\n        tI = [];\n        yI = [];\n        while(t[currentIndex]<=nextX&&currentIndex<nbPoints){\n            tI.push(t[currentIndex][0]);\n            yI.push(y_data[currentIndex][0]*maxY);\n            currentIndex++;\n        }\n\n        current=optimizeSingleLorentzian([tI, yI], group[i], opts);\n        if(current){\n            result.push({\"x\":current[0][0],\"y\":current[1][0],\"width\":current[2][0],\"opt\":true});\n        }\n        else{\n            result.push({\"x\":group[i].x,\"y\":group[i].y,\"width\":group[i].width,\"opt\":false});\n        }\n    }\n\n    return result;\n\n}\n\nfunction optimizeGaussianTrain(xy, group, opts){\n    var xy2 = parseData(xy);\n    //console.log(xy2[0].rows);\n    if(xy2===null||xy2[0].rows<3){\n        return null; //Cannot run an optimization with less than 3 points\n    }\n\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n    var currentIndex = 0;\n    var nbPoints = t.length;\n    var nextX;\n    var tI, yI, maxY;\n    var result=[], current;\n    for(var i=0; i<group.length;i++){\n        nextX = group[i].x-group[i].width*4;\n        //console.log(group[i]);\n        while(t[currentIndex++]<nextX&&currentIndex<nbPoints);\n        nextX = group[i].x+group[i].width*4;\n        tI = [];\n        yI = [];\n        while(t[currentIndex]<=nextX&&currentIndex<nbPoints){\n            tI.push(t[currentIndex][0]);\n            yI.push(y_data[currentIndex][0]*maxY);\n            currentIndex++;\n        }\n\n        current=optimizeSingleGaussian([tI, yI], group[i], opts);\n        if(current){\n            result.push({\"x\":current[0][0],\"y\":current[1][0],\"width\":current[2][0],\"opt\":true});\n        }\n        else{\n            result.push({\"x\":group[i].x,\"y\":group[i].y,\"width\":group[i].width,\"opt\":false});\n        }\n    }\n\n    return result;\n}\n\n\n\n/**\n *\n * @param xy A two column matrix containing the x and y data to be fitted\n * @param group A set of initial lorentzian parameters to be optimized [center, heigth, half_width_at_half_height]\n * @returns {Array} A set of final lorentzian parameters [center, heigth, hwhh*2]\n */\nfunction optimizeLorentzianSum(xy, group, opts){\n    var xy2 = parseData(xy);\n\n    if(xy2===null||xy2[0].rows<3){\n        return null; //Cannot run an optimization with less than 3 points\n    }\n\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n    var nbPoints = t.rows, i;\n\n    var weight = [nbPoints / math.sqrt(y_data.dot(y_data))];\n    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2, 11, 9, 1 ]);\n    var consts = [ ];// optional vector of constants\n\n    var nL = group.length;\n    var p_init = new Matrix(nL*3,1);\n    var p_min =  new Matrix(nL*3,1);\n    var p_max =  new Matrix(nL*3,1);\n    var dx = new Matrix(nL*3,1);\n    var dt = Math.abs(t[0][0]-t[1][0]);\n    for( i=0;i<nL;i++){\n        p_init[i][0] = group[i].x;\n        p_init[i+nL][0] = 1;\n        p_init[i+2*nL][0] = group[i].width;\n\n        p_min[i][0] = group[i].x-dt;//-group[i].width/4;\n        p_min[i+nL][0] = 0;\n        p_min[i+2*nL][0] = group[i].width/4;\n\n        p_max[i][0] = group[i].x+dt;//+group[i].width/4;\n        p_max[i+nL][0] = 1.5;\n        p_max[i+2*nL][0] = group[i].width*4;\n\n        dx[i][0] = -dt/1000;\n        dx[i+nL][0] = -1e-3;\n        dx[i+2*nL][0] = -dt/1000;\n    }\n\n    var dx = -Math.abs(t[0][0]-t[1][0])/10000;\n    var p_fit = LM.optimize(sumOfLorentzians, p_init, t, y_data, weight, dx, p_min, p_max, consts, opts);\n    p_fit=p_fit.p;\n    //Put back the result in the correct format\n    var result = new Array(nL);\n    for( i=0;i<nL;i++){\n        result[i]=[p_fit[i],[p_fit[i+nL][0]*maxY],p_fit[i+2*nL]];\n    }\n\n    return result;\n\n}\n\n/**\n *\n * @param xy A two column matrix containing the x and y data to be fitted\n * @param group A set of initial lorentzian parameters to be optimized [center, heigth, half_width_at_half_height]\n * @returns {Array} A set of final lorentzian parameters [center, heigth, hwhh*2]\n */\nfunction optimizeGaussianSum(xy, group, opts){\n    var xy2 = parseData(xy);\n\n    if(xy2===null||xy2[0].rows<3){\n        return null; //Cannot run an optimization with less than 3 points\n    }\n\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n    var nbPoints = t.rows,i;\n\n    var weight = new Matrix(nbPoints,1);//[nbPoints / math.sqrt(y_data.dot(y_data))];\n    var k = nbPoints / math.sqrt(y_data.dot(y_data));\n    for(i=0;i<nbPoints;i++){\n        weight[i][0]=k;///(y_data[i][0]);\n        //weight[i][0]=k*(2-y_data[i][0]);\n    }\n\n    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        2 ]);\n    //var opts=[  3,    100, 1e-5, 1e-6, 1e-6, 1e-6, 1e-6,    11,    9,        1 ];\n    var consts = [ ];// optional vector of constants\n\n    var nL = group.length;\n    var p_init = new Matrix(nL*3,1);\n    var p_min =  new Matrix(nL*3,1);\n    var p_max =  new Matrix(nL*3,1);\n    var dx = new Matrix(nL*3,1);\n    var dt = Math.abs(t[0][0]-t[1][0]);\n    for( i=0;i<nL;i++){\n        p_init[i][0] = group[i].x;\n        p_init[i+nL][0] = group[i].y/maxY;\n        p_init[i+2*nL][0] = group[i].width;\n\n        p_min[i][0] = group[i].x-dt;\n        p_min[i+nL][0] = group[i].y*0.8/maxY;\n        p_min[i+2*nL][0] = group[i].width/2;\n\n        p_max[i][0] = group[i].x+dt;\n        p_max[i+nL][0] = group[i].y*1.2/maxY;\n        p_max[i+2*nL][0] = group[i].width*2;\n\n        dx[i][0] = -dt/1000;\n        dx[i+nL][0] = -1e-3;\n        dx[i+2*nL][0] = -dt/1000;\n    }\n    //console.log(t);\n    var p_fit = LM.optimize(sumOfLorentzians,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n    p_fit = p_fit.p;\n    //Put back the result in the correct format\n    var result = new Array(nL);\n    for( i=0;i<nL;i++){\n        result[i]=[p_fit[i],[p_fit[i+nL][0]*maxY],p_fit[i+2*nL]];\n    }\n\n    return result;\n\n}\n/**\n *\n * Converts the given input to the required x, y column matrices. y data is normalized to max(y)=1\n * @param xy\n * @returns {*[]}\n */\nfunction parseData(xy, threshold){\n    var nbSeries = xy.length;\n    var t = null;\n    var y_data = null, x,y;\n    var maxY = 0, i,j;\n\n    if(nbSeries==2){\n        //Looks like row wise matrix [x,y]\n        var nbPoints = xy[0].length;\n        //if(nbPoints<3)\n        //    throw new Exception(nbPoints);\n        //else{\n        t = new Array(nbPoints);//new Matrix(nbPoints,1);\n        y_data = new Array(nbPoints);//new Matrix(nbPoints,1);\n        x = xy[0];\n        y = xy[1];\n        if(typeof x[0] === \"number\"){\n            for(i=0;i<nbPoints;i++){\n                t[i]=x[i];\n                y_data[i]=y[i];\n                if(y[i]>maxY)\n                    maxY = y[i];\n            }\n        }\n        else{\n            //It is a colum matrix\n            if(typeof x[0] === \"object\"){\n                for(i=0;i<nbPoints;i++){\n                    t[i]=x[i][0];\n                    y_data[i]=y[i][0];\n                    if(y[i][0]>maxY)\n                        maxY = y[i][0];\n                }\n            }\n\n        }\n\n        //}\n    }\n    else{\n        //Looks like a column wise matrix [[x],[y]]\n        var nbPoints = nbSeries;\n        //if(nbPoints<3)\n        //    throw new SizeException(nbPoints);\n        //else {\n        t = new Array(nbPoints);//new Matrix(nbPoints, 1);\n        y_data = new Array(nbPoints);//new Matrix(nbPoints, 1);\n        for (i = 0; i < nbPoints; i++) {\n            t[i] = xy[i][0];\n            y_data[i] = xy[i][1];\n            if(y_data[i]>maxY)\n                maxY = y_data[i];\n        }\n        //}\n    }\n    for (i = 0; i < nbPoints; i++) {\n        y_data[i]/=maxY;\n    }\n    if(threshold){\n        for (i = nbPoints-1; i >=0; i--) {\n            if(y_data[i]<threshold) {\n                y_data.splice(i,1);\n                t.splice(i,1);\n            }\n        }\n    }\n    if(t.length>0)\n        return [(new Matrix([t])).transpose(),(new Matrix([y_data])).transpose(),maxY];\n    return null;\n}\n\nfunction sizeException(nbPoints) {\n    return new RangeError(\"Not enough points to perform the optimization: \"+nbPoints +\"< 3\");\n}\n\nmodule.exports.optimizeSingleLorentzian = optimizeSingleLorentzian;\nmodule.exports.optimizeLorentzianSum = optimizeLorentzianSum;\nmodule.exports.optimizeSingleGaussian = optimizeSingleGaussian;\nmodule.exports.optimizeGaussianSum = optimizeGaussianSum;\nmodule.exports.singleGaussian = singleGaussian;\nmodule.exports.singleLorentzian = singleLorentzian;\nmodule.exports.optimizeGaussianTrain = optimizeGaussianTrain;\nmodule.exports.optimizeLorentzianTrain = optimizeLorentzianTrain;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-optimize-lorentzian/src/index.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = require('./LM');\nmodule.exports.Matrix = require('ml-matrix');\nmodule.exports.Matrix.algebra = require('./algebra');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-curve-fitting/src/index.js\n ** module id = 3\n ** module chunks = 0\n **/","/**\n * Created by acastillo on 8/5/15.\n */\nvar Matrix = require(\"ml-matrix\");\nvar math = require(\"./algebra\");\n\nvar DEBUG = false;\n/** Levenberg Marquardt curve-fitting: minimize sum of weighted squared residuals\n ----------  INPUT  VARIABLES  -----------\n func   = function of n independent variables, 't', and m parameters, 'p',\n returning the simulated model: y_hat = func(t,p,c)\n p      = n-vector of initial guess of parameter values\n t      = m-vectors or matrix of independent variables (used as arg to func)\n y_dat  = m-vectors or matrix of data to be fit by func(t,p)\n weight = weighting vector for least squares fit ( weight >= 0 ) ...\n inverse of the standard measurement errors\n Default:  sqrt(d.o.f. / ( y_dat' * y_dat ))\n dp     = fractional increment of 'p' for numerical derivatives\n dp(j)>0 central differences calculated\n dp(j)<0 one sided 'backwards' differences calculated\n dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n Default:  0.001;\n p_min  = n-vector of lower bounds for parameter values\n p_max  = n-vector of upper bounds for parameter values\n c      = an optional matrix of values passed to func(t,p,c)\n opts   = vector of algorithmic parameters\n parameter    defaults    meaning\n opts(1)  =  prnt            3        >1 intermediate results; >2 plots\n opts(2)  =  MaxIter      10*Npar     maximum number of iterations\n opts(3)  =  epsilon_1       1e-3     convergence tolerance for gradient\n opts(4)  =  epsilon_2       1e-3     convergence tolerance for parameters\n opts(5)  =  epsilon_3       1e-3     convergence tolerance for Chi-square\n opts(6)  =  epsilon_4       1e-2     determines acceptance of a L-M step\n opts(7)  =  lambda_0        1e-2     initial value of L-M paramter\n opts(8)  =  lambda_UP_fac   11       factor for increasing lambda\n opts(9)  =  lambda_DN_fac    9       factor for decreasing lambda\n opts(10) =  Update_Type      1       1: Levenberg-Marquardt lambda update\n 2: Quadratic update\n 3: Nielsen's lambda update equations\n\n ----------  OUTPUT  VARIABLES  -----------\n p       = least-squares optimal estimate of the parameter values\n X2      = Chi squared criteria\n sigma_p = asymptotic standard error of the parameters\n sigma_y = asymptotic standard error of the curve-fit\n corr    = correlation matrix of the parameters\n R_sq    = R-squared cofficient of multiple determination\n cvg_hst = convergence history\n\n Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. 22 Sep 2013\n modified from: http://octave.sourceforge.net/optim/function/leasqr.html\n using references by\n Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n Sam Roweis       http://www.cs.toronto.edu/~roweis/notes/lm.pdf\n Manolis Lourakis http://www.ics.forth.gr/~lourakis/levmar/levmar.pdf\n Hans Nielson     http://www2.imm.dtu.dk/~hbn/publ/TR9905.ps\n Mathworks        optimization toolbox reference manual\n K. Madsen, H.B., Nielsen, and O. Tingleff\n http://www2.imm.dtu.dk/pubdb/views/edoc_download.php/3215/pdf/imm3215.pdf\n */\nvar LM = {\n\n    optimize: function(func,p,t,y_dat,weight,dp,p_min,p_max,c,opts){\n\n        var tensor_parameter = 0;\t\t\t// set to 1 of parameter is a tensor\n\n        var iteration  = 0;\t\t\t// iteration counter\n        //func_calls = 0;\t\t\t// running count of function evaluations\n\n        if((typeof p[0])!=\"object\"){\n            for(var i=0;i< p.length;i++){\n                p[i]=[p[i]];\n            }\n\n        }\n        //p = p(:); y_dat = y_dat(:);\t\t// make column vectors\n        var i,k;\n        var eps = 2^-52;\n        var Npar   = p.length;//length(p); \t\t\t// number of parameters\n        var Npnt   = y_dat.length;//length(y_dat);\t\t// number of data points\n        var p_old  = Matrix.zeros(Npar,1);\t\t// previous set of parameters\n        var y_old  = Matrix.zeros(Npnt,1);\t\t// previous model, y_old = y_hat(t;p_old)\n        var X2     = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n        var X2_old = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n        var J =  Matrix.zeros(Npnt,Npar);\n\n\n        if (t.length != y_dat.length) {\n            console.log('lm.m error: the length of t must equal the length of y_dat');\n\n            length_t = t.length;\n            length_y_dat = y_dat.length;\n            var X2 = 0, corr = 0, sigma_p = 0, sigma_y = 0, R_sq = 0, cvg_hist = 0;\n            if (!tensor_parameter) {\n                return;\n            }\n        }\n\n        weight = weight||Math.sqrt((Npnt-Npar+1)/(math.multiply(math.transpose(y_dat),y_dat)));\n        dp = dp || 0.001;\n        p_min   = p_min || math.multiply(Math.abs(p),-100);\n        p_max   = p_max || math.multiply(Math.abs(p),100);\n        c = c || 1;\n        // Algorithmic Paramters\n        //prnt MaxIter  eps1  eps2  epx3  eps4  lam0  lamUP lamDN UpdateType\n        opts = opts ||[  3,10*Npar, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2, 11, 9, 1 ];\n\n        var prnt          = opts[0];\t// >1 intermediate results; >2 plots\n        var MaxIter       = opts[1];\t// maximum number of iterations\n        var epsilon_1     = opts[2];\t// convergence tolerance for gradient\n        var epsilon_2     = opts[3];\t// convergence tolerance for parameter\n        var epsilon_3     = opts[4];\t// convergence tolerance for Chi-square\n        var epsilon_4     = opts[5];\t// determines acceptance of a L-M step\n        var lambda_0      = opts[6];\t// initial value of damping paramter, lambda\n        var lambda_UP_fac = opts[7];\t// factor for increasing lambda\n        var lambda_DN_fac = opts[8];\t// factor for decreasing lambda\n        var Update_Type   = opts[9];\t// 1: Levenberg-Marquardt lambda update\n        // 2: Quadratic update\n        // 3: Nielsen's lambda update equations\n\n        if ( tensor_parameter && prnt == 3 ) prnt = 2;\n\n\n        if(!dp.length || dp.length == 1){\n            var dp_array = new Array(Npar);\n            for(var i=0;i<Npar;i++)\n                dp_array[i]=[dp];\n            dp=dp_array;\n        }\n\n        // indices of the parameters to be fit\n        var idx   = [];\n        for(i=0;i<dp.length;i++){\n            if(dp[i][0]!=0){\n                idx.push(i);\n            }\n        }\n\n        var Nfit = idx.length;\t\t\t// number of parameters to fit\n        var stop = false;\t\t\t\t// termination flag\n\n        var weight_sq = null;\n        //console.log(weight);\n        if ( !weight.length || weight.length < Npnt )\t{\n            // squared weighting vector\n            //weight_sq = ( weight(1)*ones(Npnt,1) ).^2;\n            //console.log(\"weight[0] \"+typeof weight[0]);\n            var tmp = math.multiply(Matrix.ones(Npnt,1),weight[0]);\n            weight_sq = math.dotMultiply(tmp,tmp);\n        }\n        else{\n            //weight_sq = (weight(:)).^2;\n            weight_sq = math.dotMultiply(weight,weight);\n        }\n\n\n        // initialize Jacobian with finite difference calculation\n        //console.log(\"J \"+weight_sq);\n        var result = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n        var JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n        //[JtWJ,JtWdy,X2,y_hat,J] = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n        //console.log(JtWJ);\n\n        if ( Math.max(Math.abs(JtWdy)) < epsilon_1 ){\n            console.log(' *** Your Initial Guess is Extremely Close to Optimal ***')\n            console.log(' *** epsilon_1 = ', epsilon_1);\n            stop = true;\n        }\n\n\n        switch(Update_Type){\n            case 1: // Marquardt: init'l lambda\n                lambda  = lambda_0;\n                break;\n            default:    // Quadratic and Nielsen\n                lambda  = lambda_0 * Math.max(math.diag(JtWJ));\n                nu=2;\n        }\n        //console.log(X2);\n        X2_old = X2; // previous value of X2\n        //console.log(MaxIter+\" \"+Npar);\n        //var cvg_hst = Matrix.ones(MaxIter,Npar+3);\t\t// initialize convergence history\n        var h = null;\n        while ( !stop && iteration <= MaxIter ) {\t\t// --- Main Loop\n            iteration = iteration + 1;\n            // incremental change in parameters\n            switch(Update_Type){\n                case 1:\t\t\t\t\t// Marquardt\n                    //h = ( JtWJ + lambda * math.diag(math.diag(JtWJ)) ) \\ JtWdy;\n                    //h = math.multiply(math.inv(JtWdy),math.add(JtWJ,math.multiply(lambda,math.diag(math.diag(Npar)))));\n                    h = math.solve(math.add(JtWJ,math.multiply(math.diag(math.diag(JtWJ)),lambda)),JtWdy);\n                    break;\n                default:\t\t\t\t\t// Quadratic and Nielsen\n                    //h = ( JtWJ + lambda * math.eye(Npar) ) \\ JtWdy;\n\n                    h = math.solve(math.add(JtWJ,math.multiply( Matrix.eye(Npar),lambda)),JtWdy);\n            }\n\n            /*for(var k=0;k< h.length;k++){\n             h[k]=[h[k]];\n             }*/\n            //console.log(\"h \"+h);\n            //h=math.matrix(h);\n            //  big = max(abs(h./p)) > 2;\n            //this is a big step\n            // --- Are parameters [p+h] much better than [p] ?\n            var hidx = new Array(idx.length);\n            for(k=0;k<idx.length;k++){\n                hidx[k]=h[idx[k]];\n            }\n            var p_try = math.add(p, hidx);// update the [idx] elements\n\n            for(k=0;k<p_try.length;k++){\n                p_try[k][0]=Math.min(Math.max(p_min[k][0],p_try[k][0]),p_max[k][0]);\n            }\n            // p_try = Math.min(Math.max(p_min,p_try),p_max);           // apply constraints\n\n            var delta_y = math.subtract(y_dat, func(t,p_try,c));       // residual error using p_try\n            //func_calls = func_calls + 1;\n            //X2_try = delta_y' * ( delta_y .* weight_sq );  // Chi-squared error criteria\n\n            var X2_try = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n\n            if ( Update_Type == 2 ){  \t\t\t  // Quadratic\n                //    One step of quadratic line update in the h direction for minimum X2\n                //var alpha =  JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n                var JtWdy_th = math.multiply(math.transpose(JtWdy),h);\n                var alpha =  math.multiply(JtWdy_th,math.inv(math.add(math.multiply(math.subtract(X2_try - X2),1/2)),math.multiply(JtWdy_th,2)));//JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n\n                h = math.multiply(alpha, h);\n                for(var k=0;k<idx.length;k++){\n                    hidx[k]=h[idx[k]];\n                }\n\n                p_try = math.add(p ,hidx);                     // update only [idx] elements\n                p_try = math.min(math.max(p_min,p_try),p_max);          // apply constraints\n\n                delta_y = math.subtract(y_dat, func(t,p_try,c));      // residual error using p_try\n                // func_calls = func_calls + 1;\n                //X2_try = delta_y' * ( delta_y .* weight_sq ); // Chi-squared error criteria\n                X2_try = math.multiply(math.transpose(delta_y), mat.dotMultiply(delta_y, weight_sq));\n            }\n\n            //rho = (X2 - X2_try) / ( 2*h' * (lambda * h + JtWdy) ); // Nielsen\n            var rho = (X2-X2_try)/math.multiply(math.multiply(math.transpose(h),2),math.add(math.multiply(lambda, h),JtWdy));\n            //console.log(\"rho \"+rho);\n            if ( rho > epsilon_4 ) {\t\t// it IS significantly better\n                //console.log(\"Here\");\n                dX2 = X2 - X2_old;\n                X2_old = X2;\n                p_old = p;\n                y_old = y_hat;\n                p = p_try;\t\t\t// accept p_try\n\n                result = this.lm_matx(func, t, p_old, y_old, dX2, J, p, y_dat, weight_sq, dp, c);\n                JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n                // decrease lambda ==> Gauss-Newton method\n\n                switch (Update_Type) {\n                    case 1:\t\t\t\t\t\t\t// Levenberg\n                        lambda = Math.max(lambda / lambda_DN_fac, 1.e-7);\n                        break;\n                    case 2:\t\t\t\t\t\t\t// Quadratic\n                        lambda = Math.max(lambda / (1 + alpha), 1.e-7);\n                        break;\n                    case 3:\t\t\t\t\t\t\t// Nielsen\n                        lambda = math.multiply(Math.max(1 / 3, 1 - (2 * rho - 1) ^ 3),lambda);\n                        nu = 2;\n                        break;\n                }\n            }\n            else {\t\t\t\t\t// it IS NOT better\n                X2 = X2_old;\t\t\t// do not accept p_try\n                if (iteration%(2 * Npar)==0) {\t// rank-1 update of Jacobian\n                    result = this.lm_matx(func, t, p_old, y_old, -1, J, p, y_dat, weight_sq, dp, c);\n                    JtWJ = result.JtWJ,JtWdy=result.JtWdy,dX2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n                }\n\n                // increase lambda  ==> gradient descent method\n                switch (Update_Type) {\n                    case 1:\t\t\t\t\t\t\t// Levenberg\n                        lambda = Math.min(lambda * lambda_UP_fac, 1.e7);\n                        break;\n                    case 2:\t\t\t\t\t\t\t// Quadratic\n                        lambda = lambda + Math.abs((X2_try - X2) / 2 / alpha);\n                        break;\n                    case 3:\t\t\t\t\t\t// Nielsen\n                        lambda = lambda * nu;\n                        nu = 2 * nu;\n                        break;\n                }\n            }\n        }// --- End of Main Loop\n\n        // --- convergence achieved, find covariance and confidence intervals\n\n        // equal weights for paramter error analysis\n        weight_sq = math.multiply(math.multiply(math.transpose(delta_y),delta_y), Matrix.ones(Npnt,1));\n\n        weight_sq.apply(function(i,j){\n            weight_sq[i][j] = (Npnt-Nfit+1)/weight_sq[i][j];\n        });\n        //console.log(weight_sq);\n        result = this.lm_matx(func,t,p_old,y_old,-1,J,p,y_dat,weight_sq,dp,c);\n        JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\n        /*if nargout > 2\t\t\t\t// standard error of parameters\n         covar = inv(JtWJ);\n         sigma_p = sqrt(diag(covar));\n         end\n\n         if nargout > 3\t\t\t\t// standard error of the fit\n         //  sigma_y = sqrt(diag(J * covar * J'));\t// slower version of below\n         sigma_y = zeros(Npnt,1);\n         for i=1:Npnt\n         sigma_y(i) = J(i,:) * covar * J(i,:)';\n         end\n         sigma_y = sqrt(sigma_y);\n         end\n\n         if nargout > 4\t\t\t\t// parameter correlation matrix\n         corr = covar ./ [sigma_p*sigma_p'];\n         end\n\n         if nargout > 5\t\t\t\t// coefficient of multiple determination\n         R_sq = corrcoef([y_dat y_hat]);\n         R_sq = R_sq(1,2).^2;\n         end\n\n         if nargout > 6\t\t\t\t// convergence history\n         cvg_hst = cvg_hst(1:iteration,:);\n         end*/\n\n        // endfunction  # ---------------------------------------------------------- LM\n\n        return { p:p, X2:X2};\n    },\n\n    lm_FD_J:function(func,t,p,y,dp,c) {\n        // J = lm_FD_J(func,t,p,y,{dp},{c})\n        //\n        // partial derivatives (Jacobian) dy/dp for use with lm.m\n        // computed via Finite Differences\n        // Requires n or 2n function evaluations, n = number of nonzero values of dp\n        // -------- INPUT VARIABLES ---------\n        // func = function of independent variables, 't', and parameters, 'p',\n        //        returning the simulated model: y_hat = func(t,p,c)\n        // t  = m-vector of independent variables (used as arg to func)\n        // p  = n-vector of current parameter values\n        // y  = func(t,p,c) n-vector initialised by user before each call to lm_FD_J\n        // dp = fractional increment of p for numerical derivatives\n        //      dp(j)>0 central differences calculated\n        //      dp(j)<0 one sided differences calculated\n        //      dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n        //      Default:  0.001;\n        // c  = optional vector of constants passed to y_hat = func(t,p,c)\n        //---------- OUTPUT VARIABLES -------\n        // J  = Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n\n        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\n        var m = y.length;\t\t\t// number of data points\n        var n = p.length;\t\t\t// number of parameters\n\n        dp = dp || math.multiply( Matrix.ones(n, 1), 0.001);\n\n        var ps = p.clone();//JSON.parse(JSON.stringify(p));\n        //var ps = $.extend(true, [], p);\n        var J = new Matrix(m,n), del =new Array(n);         // initialize Jacobian to Zero\n\n        for (var j = 0;j < n; j++) {\n            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n            del[j] = dp[j]*(1+Math.abs(p[j][0]));  // parameter perturbation\n            p[j] = [ps[j][0]+del[j]];\t      // perturb parameter p(j)\n            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n\n            if (del[j] != 0){\n                y1 = func(t, p, c);\n                //func_calls = func_calls + 1;\n                if (dp[j][0] < 0) {\t\t// backwards difference\n                    //J(:,j) = math.dotDivide(math.subtract(y1, y),del[j]);//. / del[j];\n                    //console.log(del[j]);\n                    //console.log(y);\n                    var column = math.dotDivide(math.subtract(y1, y),del[j]);\n                    for(var k=0;k< m;k++){\n                        J[k][j]=column[k][0];\n                    }\n                    //console.log(column);\n                }\n                else{\n                    p[j][0] = ps[j][0] - del[j];\n                    //J(:,j) = (y1 - feval(func, t, p, c)). / (2. * del[j]);\n                    var column = math.dotDivide(math.subtract(y1,func(t,p,c)),2*del[j]);\n                    for(var k=0;k< m;k++){\n                        J[k][j]=column[k][0];\n                    }\n\n                }\t\t\t// central difference, additional func call\n            }\n\n            p[j] = ps[j];\t\t// restore p(j)\n\n        }\n        //console.log(\"lm_FD_J: \"+ JSON.stringify(J));\n        return J;\n\n    },\n\n    // endfunction # -------------------------------------------------- LM_FD_J\n    lm_Broyden_J: function(p_old,y_old,J,p,y){\n        // J = lm_Broyden_J(p_old,y_old,J,p,y)\n        // carry out a rank-1 update to the Jacobian matrix using Broyden's equation\n        //---------- INPUT VARIABLES -------\n        // p_old = previous set of parameters\n        // y_old = model evaluation at previous set of parameters, y_hat(t;p_old)\n        // J  = current version of the Jacobian matrix\n        // p     = current  set of parameters\n        // y     = model evaluation at current  set of parameters, y_hat(t;p)\n        //---------- OUTPUT VARIABLES -------\n        // J = rank-1 update to Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n        //console.log(p+\" X \"+ p_old)\n        var h  = math.subtract(p, p_old);\n\n        //console.log(\"hhh \"+h);\n        var h_t = math.transpose(h);\n        h_t.div(math.multiply(h_t,h));\n\n        //console.log(h_t);\n        //J = J + ( y - y_old - J*h )*h' / (h'*h);\t// Broyden rank-1 update eq'n\n        J = math.add(J, math.multiply(math.subtract(y, math.add(y_old,math.multiply(J,h))),h_t));\n        return J;\n        // endfunction # ---------------------------------------------- LM_Broyden_J\n    },\n\n    lm_matx : function (func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,dp,c,iteration){\n        // [JtWJ,JtWdy,Chi_sq,y_hat,J] = this.lm_matx(func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,{da},{c})\n        //\n        // Evaluate the linearized fitting matrix, JtWJ, and vector JtWdy,\n        // and calculate the Chi-squared error function, Chi_sq\n        // Used by Levenberg-Marquard algorithm, lm.m\n        // -------- INPUT VARIABLES ---------\n        // func   = function ofpn independent variables, p, and m parameters, p,\n        //         returning the simulated model: y_hat = func(t,p,c)\n        // t      = m-vectors or matrix of independent variables (used as arg to func)\n        // p_old  = n-vector of previous parameter values\n        // y_old  = m-vector of previous model ... y_old = y_hat(t;p_old);\n        // dX2    = previous change in Chi-squared criteria\n        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n        // p      = n-vector of current  parameter values\n        // y_dat  = n-vector of data to be fit by func(t,p,c)\n        // weight_sq = square of the weighting vector for least squares fit ...\n        //\t    inverse of the standard measurement errors\n        // dp     = fractional increment of 'p' for numerical derivatives\n        //          dp(j)>0 central differences calculated\n        //          dp(j)<0 one sided differences calculated\n        //          dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n        //          Default:  0.001;\n        // c      = optional vector of constants passed to y_hat = func(t,p,c)\n        //---------- OUTPUT VARIABLES -------\n        // JtWJ\t = linearized Hessian matrix (inverse of covariance matrix)\n        // JtWdy   = linearized fitting vector\n        // Chi_sq = Chi-squared criteria: weighted sum of the squared residuals WSSR\n        // y_hat  = model evaluated with parameters 'p'\n        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n\n        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\n\n        var Npnt = y_dat.length;\t\t// number of data points\n        var Npar = p.length;\t\t// number of parameters\n\n        dp = dp || 0.001;\n\n\n        //var JtWJ = new Matrix.zeros(Npar);\n        //var JtWdy  = new Matrix.zeros(Npar,1);\n\n        var y_hat = func(t,p,c);\t// evaluate model using parameters 'p'\n        //func_calls = func_calls + 1;\n        //console.log(J);\n        if ( (iteration%(2*Npar))==0 || dX2 > 0 ) {\n            //console.log(\"Par\");\n            J = this.lm_FD_J(func, t, p, y_hat, dp, c);\t\t// finite difference\n        }\n        else{\n            //console.log(\"ImPar\");\n            J = this.lm_Broyden_J(p_old, y_old, J, p, y_hat); // rank-1 update\n        }\n        var delta_y = math.subtract(y_dat, y_hat);\t// residual error between model and data\n        //console.log(delta_y[0][0]);\n        //console.log(delta_y.rows+\" \"+delta_y.columns+\" \"+JSON.stringify(weight_sq));\n        //var Chi_sq = delta_y' * ( delta_y .* weight_sq ); \t// Chi-squared error criteria\n        var Chi_sq = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n        //JtWJ  = J' * ( J .* ( weight_sq * ones(1,Npar) ) );\n        var Jt = math.transpose(J);\n\n        //console.log(weight_sq);\n\n        var JtWJ = math.multiply(Jt, math.dotMultiply(J,math.multiply(weight_sq, Matrix.ones(1,Npar))));\n\n        //JtWdy = J' * ( weight_sq .* delta_y );\n        var JtWdy = math.multiply(Jt, math.dotMultiply(weight_sq,delta_y));\n\n\n        return {JtWJ:JtWJ,JtWdy:JtWdy,Chi_sq:Chi_sq,y_hat:y_hat,J:J};\n        // endfunction  # ------------------------------------------------------ LM_MATX\n    }\n\n\n\n};\n\nmodule.exports = LM;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-curve-fitting/src/LM.js\n ** module id = 4\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = require('./matrix');\nmodule.exports.Decompositions = module.exports.DC = require('./decompositions');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-matrix/src/index.js\n ** module id = 5\n ** module chunks = 0\n **/","'use strict';\n\nvar Asplice = Array.prototype.splice,\n    Aconcat = Array.prototype.concat;\n\n// For performance : http://jsperf.com/clone-array-slice-vs-while-vs-for\nfunction slice(arr) {\n    var i = 0,\n        ii = arr.length,\n        result = new Array(ii);\n    for (; i < ii; i++) {\n        result[i] = arr[i];\n    }\n    return result;\n}\n\n/**\n * Real matrix.\n * @constructor\n * @param {number|Array} nRows - Number of rows of the new matrix or a 2D array containing the data.\n * @param {number|boolean} [nColumns] - Number of columns of the new matrix or a boolean specifying if the input array should be cloned\n */\nfunction Matrix(nRows, nColumns) {\n    var i = 0, rows, columns, matrix, newInstance;\n    if (Array.isArray(nRows)) {\n        newInstance = nColumns;\n        matrix = newInstance ? slice(nRows) : nRows;\n        nRows = matrix.length;\n        nColumns = matrix[0].length;\n        if (typeof nColumns === 'undefined') {\n            throw new TypeError('Data must be a 2D array');\n        }\n        if (nRows > 0 && nColumns > 0) {\n            for (; i < nRows; i++) {\n                if (matrix[i].length !== nColumns) {\n                    throw new RangeError('Inconsistent array dimensions');\n                } else if (newInstance) {\n                    matrix[i] = slice(matrix[i]);\n                }\n            }\n        } else {\n            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n        }\n    } else if (typeof nRows === 'number') { // Create empty matrix\n        if (nRows > 0 && nColumns > 0) {\n            matrix = new Array(nRows);\n            for (; i < nRows; i++) {\n                matrix[i] = new Array(nColumns);\n            }\n        } else {\n            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n        }\n    } else {\n        throw new TypeError('Invalid arguments');\n    }\n\n    Object.defineProperty(matrix, 'rows', {writable: true, value: nRows});\n    Object.defineProperty(matrix, 'columns', {writable: true, value: nColumns});\n\n    matrix.__proto__ = Matrix.prototype;\n\n    return matrix;\n}\n\n/**\n * Constructs a Matrix with the chosen dimensions from a 1D array.\n * @param {number} newRows - Number of rows\n * @param {number} newColumns - Number of columns\n * @param {Array} newData - A 1D array containing data for the matrix\n * @returns {Matrix} - The new matrix\n */\nMatrix.from1DArray = function from1DArray(newRows, newColumns, newData) {\n    var length, data, i = 0;\n\n    length = newRows * newColumns;\n    if (length !== newData.length)\n        throw new RangeError('Data length does not match given dimensions');\n\n    data = new Array(newRows);\n    for (; i < newRows; i++) {\n        data[i] = newData.slice(i * newColumns, (i + 1) * newColumns);\n    }\n    return new Matrix(data);\n};\n\n/**\n * Creates a row vector, a matrix with only one row.\n * @param {Array} newData - A 1D array containing data for the vector\n * @returns {Matrix} - The new matrix\n */\nMatrix.rowVector = function rowVector(newData) {\n    return new Matrix([newData]);\n};\n\n/**\n * Creates a column vector, a matrix with only one column.\n * @param {Array} newData - A 1D array containing data for the vector\n * @returns {Matrix} - The new matrix\n */\nMatrix.columnVector = function columnVector(newData) {\n    var l = newData.length, vector = new Array(l);\n    for (var i = 0; i < l; i++)\n        vector[i] = [newData[i]];\n    return new Matrix(vector);\n};\n\n/**\n * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.empty = function empty(rows, columns) {\n    return new Matrix(rows, columns);\n};\n\n/**\n * Creates a matrix with the given dimensions. Values will be set to zero.\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.zeros = function zeros(rows, columns) {\n    return Matrix.empty(rows, columns).fill(0);\n};\n\n/**\n * Creates a matrix with the given dimensions. Values will be set to one.\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.ones = function ones(rows, columns) {\n    return Matrix.empty(rows, columns).fill(1);\n};\n\n/**\n * Creates a matrix with the given dimensions. Values will be randomly set using Math.random().\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} The new matrix\n */\nMatrix.rand = function rand(rows, columns) {\n    var matrix = Matrix.empty(rows, columns);\n    for (var i = 0, ii = matrix.rows; i < ii; i++) {\n        for (var j = 0, jj = matrix.columns; j < jj; j++) {\n            matrix[i][j] = Math.random();\n        }\n    }\n    return matrix;\n};\n\n/**\n * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and other will be 0.\n * @param {number} n - Number of rows and columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.eye = function eye(n) {\n    var matrix = Matrix.zeros(n, n), l = matrix.rows;\n    for (var i = 0; i < l; i++) {\n        matrix[i][i] = 1;\n    }\n    return matrix;\n};\n\n/**\n * Creates a diagonal matrix based on the given array.\n * @param {Array} data - Array containing the data for the diagonal\n * @returns {Matrix} - The new matrix\n */\nMatrix.diag = function diag(data) {\n    var l = data.length, matrix = Matrix.zeros(l, l);\n    for (var i = 0; i < l; i++) {\n        matrix[i][i] = data[i];\n    }\n    return matrix;\n};\n\n/**\n * Creates an array of indices between two values\n * @param {number} from\n * @param {number} to\n * @returns {Array}\n */\nMatrix.indices = function indices(from, to) {\n    var vector = new Array(to - from);\n    for (var i = 0; i < vector.length; i++)\n        vector[i] = from++;\n    return vector;\n};\n\n// TODO DOC\nMatrix.stack = function stack(arg1) {\n    var i, j, k;\n    if (Matrix.isMatrix(arg1)) {\n        var rows = 0,\n            cols = 0;\n        for (i = 0; i < arguments.length; i++) {\n            rows += arguments[i].rows;\n            if (arguments[i].columns > cols)\n                cols = arguments[i].columns;\n        }\n\n        var r = Matrix.zeros(rows, cols);\n        var c = 0;\n        for (i = 0; i < arguments.length; i++) {\n            var current = arguments[i];\n            for (j = 0; j < current.rows; j++) {\n                for (k = 0; k < current.columns; k++)\n                    r[c][k] = current[j][k];\n                c++;\n            }\n        }\n        return r;\n    }\n    else if (Array.isArray(arg1)) {\n        var matrix = Matrix.empty(arguments.length, arg1.length);\n        for (i = 0; i < arguments.length; i++)\n            matrix.setRow(i, arguments[i]);\n        return matrix;\n    }\n};\n\n// TODO DOC\nMatrix.expand = function expand(base, count) {\n    var expansion = [];\n    for (var i = 0; i < count.length; i++)\n        for (var j = 0; j < count[i]; j++)\n            expansion.push(base[i]);\n    return new Matrix(expansion);\n};\n\n/**\n * Check that the provided value is a Matrix and tries to instantiate one if not\n * @param value - The value to check\n * @returns {Matrix}\n * @throws {TypeError}\n */\nMatrix.checkMatrix = function checkMatrix(value) {\n    if (!value) {\n        throw new TypeError('Argument has to be a matrix');\n    }\n    if (value.klass !== 'Matrix') {\n        value = new Matrix(value);\n    }\n    return value;\n};\n\n/**\n * Returns true if the argument is a Matrix, false otherwise\n * @param value - The value to check\n * @returns {boolean}\n */\nMatrix.isMatrix = function isMatrix(value) {\n    return value ? value.klass === 'Matrix' : false;\n};\n\n/**\n * @property {string} - The name of this class.\n */\nObject.defineProperty(Matrix.prototype, 'klass', {\n    get: function klass() {\n        return 'Matrix';\n    }\n});\n\n/**\n * @property {number} - The number of elements in the matrix.\n */\nObject.defineProperty(Matrix.prototype, 'size', {\n    get: function size() {\n        return this.rows * this.columns;\n    }\n});\n\n/**\n * @private\n * Internal check that a row index is not out of bounds\n * @param {number} index\n */\nMatrix.prototype.checkRowIndex = function checkRowIndex(index) {\n    if (index < 0 || index > this.rows - 1)\n        throw new RangeError('Row index out of range.');\n};\n\n/**\n * @private\n * Internal check that a column index is not out of bounds\n * @param {number} index\n */\nMatrix.prototype.checkColumnIndex = function checkColumnIndex(index) {\n    if (index < 0 || index > this.columns - 1)\n        throw new RangeError('Column index out of range.');\n};\n\n/**\n * @private\n * Internal check that two matrices have the same dimensions\n * @param {Matrix} otherMatrix\n */\nMatrix.prototype.checkDimensions = function checkDimensions(otherMatrix) {\n    if ((this.rows !== otherMatrix.rows) || (this.columns !== otherMatrix.columns))\n        throw new RangeError('Matrices dimensions must be equal.');\n};\n\n/**\n * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.\n * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)\n * @returns {Matrix} this\n */\nMatrix.prototype.apply = function apply(callback) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            callback.call(this, i, j);\n        }\n    }\n    return this;\n};\n\n/**\n * Creates an exact and independent copy of the matrix\n * @returns {Matrix}\n */\nMatrix.prototype.clone = function clone() {\n    return new Matrix(this.to2DArray());\n};\n\n/**\n * Returns a new 1D array filled row by row with the matrix values\n * @returns {Array}\n */\nMatrix.prototype.to1DArray = function to1DArray() {\n    return Aconcat.apply([], this);\n};\n\n/**\n * Returns a 2D array containing a copy of the data\n * @returns {Array}\n */\nMatrix.prototype.to2DArray = function to2DArray() {\n    var l = this.rows, copy = new Array(l);\n    for (var i = 0; i < l; i++) {\n        copy[i] = slice(this[i]);\n    }\n    return copy;\n};\n\n/**\n * @returns {boolean} true if the matrix has one row\n */\nMatrix.prototype.isRowVector = function isRowVector() {\n    return this.rows === 1;\n};\n\n/**\n * @returns {boolean} true if the matrix has one column\n */\nMatrix.prototype.isColumnVector = function isColumnVector() {\n    return this.columns === 1;\n};\n\n/**\n * @returns {boolean} true if the matrix has one row or one column\n */\nMatrix.prototype.isVector = function isVector() {\n    return (this.rows === 1) || (this.columns === 1);\n};\n\n/**\n * @returns {boolean} true if the matrix has the same number of rows and columns\n */\nMatrix.prototype.isSquare = function isSquare() {\n    return this.rows === this.columns;\n};\n\n/**\n * @returns {boolean} true if the matrix is square and has the same values on both sides of the diagonal\n */\nMatrix.prototype.isSymmetric = function isSymmetric() {\n    if (this.isSquare()) {\n        var l = this.rows;\n        for (var i = 0; i < l; i++) {\n            for (var j = 0; j <= i; j++) {\n                if (this[i][j] !== this[j][i]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n/**\n * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1\n * @param {number} rowIndex - Index of the row\n * @param {number} columnIndex - Index of the column\n * @param {number} value - The new value for the element\n * @returns {Matrix} this\n */\nMatrix.prototype.set = function set(rowIndex, columnIndex, value) {\n    this[rowIndex][columnIndex] = value;\n    return this;\n};\n\n/**\n * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]\n * @param {number} rowIndex - Index of the row\n * @param {number} columnIndex - Index of the column\n * @returns {number}\n */\nMatrix.prototype.get = function get(rowIndex, columnIndex) {\n    return this[rowIndex][columnIndex];\n};\n\n/**\n * Fills the matrix with a given value. All elements will be set to this value.\n * @param {number} value - New value\n * @returns {Matrix} this\n */\nMatrix.prototype.fill = function fill(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] = value;\n        }\n    }\n    return this;\n};\n\n/**\n * Negates the matrix. All elements will be multiplied by (-1)\n * @returns {Matrix} this\n */\nMatrix.prototype.neg = function neg() {\n    return this.mulS(-1);\n};\n\n/**\n * Adds a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.add = function add(value) {\n    if (typeof value === 'number')\n        return this.addS(value);\n    value = Matrix.checkMatrix(value);\n        return this.addM(value);\n};\n\n/**\n * Adds a scalar to each element of the matrix\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.addS = function addS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += value;\n        }\n    }\n    return this;\n};\n\n/**\n * Adds the value of each element of matrix to the corresponding element of this\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.addM = function addM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.sub = function sub(value) {\n    if (typeof value === 'number')\n        return this.subS(value);\n    value = Matrix.checkMatrix(value);\n        return this.subM(value);\n};\n\n/**\n * Subtracts a scalar from each element of the matrix\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.subS = function subS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= value;\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts the value of each element of matrix from the corresponding element of this\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.subM = function subM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mul = function mul(value) {\n    if (typeof value === 'number')\n        return this.mulS(value);\n    value = Matrix.checkMatrix(value);\n        return this.mulM(value);\n};\n\n/**\n * Multiplies a scalar with each element of the matrix\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mulS = function mulS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= value;\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the value of each element of matrix with the corresponding element of this\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.mulM = function mulM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Divides by a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.div = function div(value) {\n    if (typeof value === 'number')\n        return this.divS(value);\n    value = Matrix.checkMatrix(value);\n        return this.divM(value);\n};\n\n/**\n * Divides each element of the matrix by a scalar\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.divS = function divS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= value;\n        }\n    }\n    return this;\n};\n\n/**\n * Divides each element of this by the corresponding element of matrix\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.divM = function divM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Returns a new array from the given row index\n * @param {number} index - Row index\n * @returns {Array}\n */\nMatrix.prototype.getRow = function getRow(index) {\n    this.checkRowIndex(index);\n    return slice(this[index]);\n};\n\n/**\n * Returns a new row vector from the given row index\n * @param {number} index - Row index\n * @returns {Matrix}\n */\nMatrix.prototype.getRowVector = function getRowVector(index) {\n    return Matrix.rowVector(this.getRow(index));\n};\n\n/**\n * Sets a row at the given index\n * @param {number} index - Row index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.setRow = function setRow(index, array) {\n    this.checkRowIndex(index);\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    if (array.length !== this.columns)\n        throw new RangeError('Invalid row size');\n    this[index] = slice(array);\n    return this;\n};\n\n/**\n * Removes a row from the given index\n * @param {number} index - Row index\n * @returns {Matrix} this\n */\nMatrix.prototype.removeRow = function removeRow(index) {\n    this.checkRowIndex(index);\n    if (this.rows === 1)\n        throw new RangeError('A matrix cannot have less than one row');\n    Asplice.call(this, index, 1);\n    this.rows -= 1;\n    return this;\n};\n\n/**\n * Adds a row at the given index\n * @param {number} [index = this.rows] - Row index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addRow = function addRow(index, array) {\n    if (typeof array === 'undefined') {\n        array = index;\n        index = this.rows;\n    }\n    if (index < 0 || index > this.rows)\n        throw new RangeError('Row index out of range.');\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    if (array.length !== this.columns)\n        throw new RangeError('Invalid row size');\n    Asplice.call(this, index, 0, slice(array));\n    this.rows += 1;\n    return this;\n};\n\n/**\n * Swaps two rows\n * @param {number} row1 - First row index\n * @param {number} row2 - Second row index\n * @returns {Matrix} this\n */\nMatrix.prototype.swapRows = function swapRows(row1, row2) {\n    this.checkRowIndex(row1);\n    this.checkRowIndex(row2);\n    var temp = this[row1];\n    this[row1] = this[row2];\n    this[row2] = temp;\n    return this;\n};\n\n/**\n * Returns a new array from the given column index\n * @param {number} index - Column index\n * @returns {Array}\n */\nMatrix.prototype.getColumn = function getColumn(index) {\n    this.checkColumnIndex(index);\n    var l = this.rows, column = new Array(l);\n    for (var i = 0; i < l; i++) {\n        column[i] = this[i][index];\n    }\n    return column;\n};\n\n/**\n * Returns a new column vector from the given column index\n * @param {number} index - Column index\n * @returns {Matrix}\n */\nMatrix.prototype.getColumnVector = function getColumnVector(index) {\n    return Matrix.columnVector(this.getColumn(index));\n};\n\n/**\n * Sets a column at the given index\n * @param {number} index - Column index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.setColumn = function setColumn(index, array) {\n    this.checkColumnIndex(index);\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    var l = this.rows;\n    if (array.length !== l)\n        throw new RangeError('Invalid column size');\n    for (var i = 0; i < l; i++) {\n        this[i][index] = array[i];\n    }\n    return this;\n};\n\n/**\n * Removes a column from the given index\n * @param {number} index - Column index\n * @returns {Matrix} this\n */\nMatrix.prototype.removeColumn = function removeColumn(index) {\n    this.checkColumnIndex(index);\n    if (this.columns === 1)\n        throw new RangeError('A matrix cannot have less than one column');\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        this[i].splice(index, 1);\n    }\n    this.columns -= 1;\n    return this;\n};\n\n/**\n * Adds a column at the given index\n * @param {number} [index = this.columns] - Column index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addColumn = function addColumn(index, array) {\n    if (typeof array === 'undefined') {\n        array = index;\n        index = this.columns;\n    }\n    if (index < 0 || index > this.columns)\n        throw new RangeError('Column index out of range.');\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    var l = this.rows;\n    if (array.length !== l)\n        throw new RangeError('Invalid column size');\n    for (var i = 0; i < l; i++) {\n        this[i].splice(index, 0, array[i]);\n    }\n    this.columns += 1;\n    return this;\n};\n\n/**\n * Swaps two columns\n * @param {number} column1 - First column index\n * @param {number} column2 - Second column index\n * @returns {Matrix} this\n */\nMatrix.prototype.swapColumns = function swapColumns(column1, column2) {\n    this.checkRowIndex(column1);\n    this.checkRowIndex(column2);\n    var l = this.rows, temp, row;\n    for (var i = 0; i < l; i++) {\n        row = this[i];\n        temp = row[column1];\n        row[column1] = row[column2];\n        row[column2] = temp;\n    }\n    return this;\n};\n\n/**\n * @private\n * Internal check that the provided vector is an array with the right length\n * @param {Array|Matrix} vector\n * @returns {Array}\n * @throws {RangeError}\n */\nMatrix.prototype.checkRowVector = function checkRowVector(vector) {\n    if (Matrix.isMatrix(vector))\n        vector = vector.to1DArray();\n    if (vector.length !== this.columns)\n        throw new RangeError('vector size must be the same as the number of columns');\n    return vector;\n};\n\n/**\n * @private\n * Internal check that the provided vector is an array with the right length\n * @param {Array|Matrix} vector\n * @returns {Array}\n * @throws {RangeError}\n */\nMatrix.prototype.checkColumnVector = function checkColumnVector(vector) {\n    if (Matrix.isMatrix(vector))\n        vector = vector.to1DArray();\n    if (vector.length !== this.rows)\n        throw new RangeError('vector size must be the same as the number of rows');\n    return vector;\n};\n\n/**\n * Adds the values of a vector to each row\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addRowVector = function addRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts the values of a vector from each row\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.subRowVector = function subRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a vector with each row\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.mulRowVector = function mulRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Divides the values of each row by those of a vector\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.divRowVector = function divRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Adds the values of a vector to each column\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addColumnVector = function addColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts the values of a vector from each column\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.subColumnVector = function subColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a vector with each column\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.mulColumnVector = function mulColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Divides the values of each column by those of a vector\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.divColumnVector = function divColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a row with a scalar\n * @param {number} index - Row index\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mulRow = function mulRow(index, value) {\n    this.checkRowIndex(index);\n    var i = 0, l = this.columns;\n    for (; i < l; i++) {\n        this[index][i] *= value;\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a column with a scalar\n * @param {number} index - Column index\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mulColumn = function mulColumn(index, value) {\n    this.checkColumnIndex(index);\n    var i = 0, l = this.rows;\n    for (; i < l; i++) {\n        this[i][index] *= value;\n    }\n};\n\n/**\n * A matrix index\n * @typedef {Object} MatrixIndex\n * @property {number} row\n * @property {number} column\n */\n\n/**\n * Returns the maximum value of the matrix\n * @returns {number}\n */\nMatrix.prototype.max = function max() {\n    var v = -Infinity;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] > v) {\n                v = this[i][j];\n            }\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value\n * @returns {MatrixIndex}\n */\nMatrix.prototype.maxIndex = function maxIndex() {\n    var v = -Infinity;\n    var idx = {};\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] > v) {\n                v = this[i][j];\n                idx.row = i;\n                idx.column = j;\n            }\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the minimum value of the matrix\n * @returns {number}\n */\nMatrix.prototype.min = function min() {\n    var v = Infinity;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] < v) {\n                v = this[i][j];\n            }\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the minimum value\n * @returns {MatrixIndex}\n */\nMatrix.prototype.minIndex = function minIndex() {\n    var v = Infinity;\n    var idx = {};\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] < v) {\n                v = this[i][j];\n                idx.row = i;\n                idx.column = j;\n            }\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the maximum value of one row\n * @param {number} index - Row index\n * @returns {number}\n */\nMatrix.prototype.maxRow = function maxRow(index) {\n    this.checkRowIndex(index);\n    var v = -Infinity;\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] > v) {\n            v = this[index][i];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value of one row\n * @param {number} index - Row index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.maxRowIndex = function maxRowIndex(index) {\n    this.checkRowIndex(index);\n    var v = -Infinity;\n    var idx = {\n            row: index\n        };\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] > v) {\n            v = this[index][i];\n            idx.column = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the minimum value of one row\n * @param {number} index - Row index\n * @returns {number}\n */\nMatrix.prototype.minRow = function minRow(index) {\n    this.checkRowIndex(index);\n    var v = Infinity;\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] < v) {\n            v = this[index][i];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value of one row\n * @param {number} index - Row index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.minRowIndex = function minRowIndex(index) {\n    this.checkRowIndex(index);\n    var v = Infinity;\n    var idx = {\n        row: index,\n        column: 0\n    };\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] < v) {\n            v = this[index][i];\n            idx.column = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the maximum value of one column\n * @param {number} index - Column index\n * @returns {number}\n */\nMatrix.prototype.maxColumn = function maxColumn(index) {\n    this.checkColumnIndex(index);\n    var v = -Infinity;\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] > v) {\n            v = this[i][index];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value of one column\n * @param {number} index - Column index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.maxColumnIndex = function maxColumnIndex(index) {\n    this.checkColumnIndex(index);\n    var v = -Infinity;\n    var idx = {\n        row: 0,\n        column: index\n    };\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] > v) {\n            v = this[i][index];\n            idx.row = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the minimum value of one column\n * @param {number} index - Column index\n * @returns {number}\n */\nMatrix.prototype.minColumn = function minColumn(index) {\n    this.checkColumnIndex(index);\n    var v = Infinity;\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] < v) {\n            v = this[i][index];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the minimum value of one column\n * @param {number} index - Column index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.minColumnIndex = function minColumnIndex(index) {\n    this.checkColumnIndex(index);\n    var v = Infinity;\n    var idx = {\n        row: 0,\n        column: index\n    };\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] < v) {\n            v = this[i][index];\n            idx.row = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns an array containing the diagonal values of the matrix\n * @returns {Array}\n */\nMatrix.prototype.diag = function diag() {\n    if (!this.isSquare())\n        throw new TypeError('Only square matrices have a diagonal.');\n    var diag = new Array(this.rows);\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        diag[i] = this[i][i];\n    }\n    return diag;\n};\n\n/**\n * Returns the sum of all elements of the matrix\n * @returns {number}\n */\nMatrix.prototype.sum = function sum() {\n    var v = 0;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            v += this[i][j];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the mean of all elements of the matrix\n * @returns {number}\n */\nMatrix.prototype.mean = function mean() {\n    return this.sum() / this.size;\n};\n\n/**\n * Returns the product of all elements of the matrix\n * @returns {number}\n */\nMatrix.prototype.prod = function prod() {\n    var prod = 1;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            prod *= this[i][j];\n        }\n    }\n    return prod;\n};\n\n/**\n * Computes the cumulative sum of the matrix elements (in place, row by row)\n * @returns {Matrix} this\n */\nMatrix.prototype.cumulativeSum = function cumulativeSum() {\n    var sum = 0;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            sum += this[i][j];\n            this[i][j] = sum;\n        }\n    }\n    return this;\n};\n\n/**\n * Computes the dot (scalar) product between the matrix and another\n * @param {Matrix} other vector\n * @returns {number}\n */\nMatrix.prototype.dot = function dot(other) {\n    if (this.size !== other.size)\n        throw new RangeError('vectors do not have the same size');\n    var vector1 = this.to1DArray();\n    var vector2 = other.to1DArray();\n    var dot = 0, l = vector1.length;\n    for (var i = 0; i < l; i++) {\n        dot += vector1[i] * vector2[i];\n    }\n    return dot;\n};\n\n/**\n * Returns the matrix product between this and other\n * @returns {Matrix}\n */\nMatrix.prototype.mmul = function mmul(other) {\n    if (!Matrix.isMatrix(other))\n        throw new TypeError('parameter \"other\" must be a matrix');\n    if (this.columns !== other.rows)\n        console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');\n\n    var m = this.rows, n = this.columns, p = other.columns;\n    var result = new Matrix(m, p);\n\n    var Bcolj = new Array(n);\n    var i, j, k;\n    for (j = 0; j < p; j++) {\n        for (k = 0; k < n; k++)\n            Bcolj[k] = other[k][j];\n\n        for (i = 0; i < m; i++) {\n            var Arowi = this[i];\n\n            var s = 0;\n            for (k = 0; k < n; k++)\n                s += Arowi[k] * Bcolj[k];\n\n            result[i][j] = s;\n        }\n    }\n    return result;\n};\n\n/**\n * Sorts the rows (in place)\n * @param {function} compareFunction - usual Array.prototype.sort comparison function\n * @returns {Matrix} this\n */\nMatrix.prototype.sortRows = function sortRows(compareFunction) {\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        this[i].sort(compareFunction);\n    }\n    return this;\n};\n\n/**\n * Sorts the columns (in place)\n * @param {function} compareFunction - usual Array.prototype.sort comparison function\n * @returns {Matrix} this\n */\nMatrix.prototype.sortColumns = function sortColumns(compareFunction) {\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        this.setColumn(i, this.getColumn(i).sort(compareFunction));\n    }\n    return this;\n};\n\n/**\n * Transposes the matrix and returns a new one containing the result\n * @returns {Matrix}\n */\nMatrix.prototype.transpose = function transpose() {\n    var result = new Matrix(this.columns, this.rows);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[j][i] = this[i][j];\n        }\n    }\n    return result;\n};\n\n/**\n * Returns a subset of the matrix\n * @param {number} startRow - First row index\n * @param {number} endRow - Last row index\n * @param {number} startColumn - First column index\n * @param {number} endColumn - Last column index\n * @returns {Matrix}\n */\nMatrix.prototype.subMatrix = function subMatrix(startRow, endRow, startColumn, endColumn) {\n    if ((startRow > endRow) || (startColumn > endColumn) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n        throw new RangeError('Argument out of range');\n    var newMatrix = new Matrix(endRow - startRow + 1, endColumn - startColumn + 1);\n    for (var i = startRow; i <= endRow; i++) {\n        for (var j = startColumn; j <= endColumn; j++) {\n            newMatrix[i - startRow][j - startColumn] = this[i][j];\n        }\n    }\n    return newMatrix;\n};\n\n/**\n * Returns a subset of the matrix based on an array of row indices\n * @param {Array} indices - Array containing the row indices\n * @param {number} [startColumn = 0] - First column index\n * @param {number} [endColumn = this.columns-1] - Last column index\n * @returns {Matrix}\n */\nMatrix.prototype.subMatrixRow = function subMatrixRow(indices, startColumn, endColumn) {\n    if (typeof startColumn === 'undefined') {\n        startColumn = 0;\n        endColumn = this.columns - 1;\n    } else if (typeof endColumn === 'undefined') {\n        endColumn = this.columns - 1;\n    }\n    if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n        throw new RangeError('Argument out of range.');\n    var l = indices.length, rows = this.rows,\n        X = new Matrix(l, endColumn - startColumn + 1);\n    for (var i = 0; i < l; i++) {\n        for (var j = startColumn; j <= endColumn; j++) {\n            if ((indices[i] < 0) || (indices[i] >= rows))\n                throw new RangeError('Argument out of range.');\n            X[i][j - startColumn] = this[indices[i]][j];\n        }\n    }\n    return X;\n};\n\n/**\n * Returns a subset of the matrix based on an array of column indices\n * @param {Array} indices - Array containing the column indices\n * @param {number} [startRow = 0] - First row index\n * @param {number} [endRow = this.rows-1] - Last row index\n * @returns {Matrix}\n */\nMatrix.prototype.subMatrixColumn = function subMatrixColumn(indices, startRow, endRow) {\n    if (typeof startRow === 'undefined') {\n        startRow = 0;\n        endRow = this.rows - 1;\n    } else if (typeof endRow === 'undefined') {\n        endRow = this.rows - 1;\n    }\n    if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows))\n        throw new RangeError('Argument out of range.');\n    var l = indices.length, columns = this.columns,\n        X = new Matrix(endRow - startRow + 1, l);\n    for (var i = 0; i < l; i++) {\n        for (var j = startRow; j <= endRow; j++) {\n            if ((indices[i] < 0) || (indices[i] >= columns))\n                throw new RangeError('Argument out of range.');\n            X[j - startRow][i] = this[j][indices[i]];\n        }\n    }\n    return X;\n};\n\n/**\n * Returns the trace of the matrix (sum of the diagonal elements)\n * @returns {number}\n */\nMatrix.prototype.trace = function trace() {\n    if (!this.isSquare())\n        throw new TypeError('The matrix is not square');\n    var trace = 0, i = 0, l = this.rows;\n    for (; i < l; i++) {\n        trace += this[i][i];\n    }\n    return trace;\n};\n\n/**\n * Sets each element of the matrix to its absolute value\n * @returns {Matrix} this\n */\nMatrix.prototype.abs = function abs() {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] = Math.abs(this[i][j]);\n        }\n    }\n};\n\nmodule.exports = Matrix;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-matrix/src/matrix.js\n ** module id = 6\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('./matrix');\n\nvar SingularValueDecomposition = require('./dc/svd');\nvar EigenvalueDecomposition = require('./dc/evd');\nvar LuDecomposition = require('./dc/lu');\nvar QrDecomposition = require('./dc/qr');\nvar CholeskyDecomposition = require('./dc/cholesky');\n\nfunction inverse(matrix) {\n    return solve(matrix, Matrix.eye(matrix.rows));\n}\n\nMatrix.prototype.inverse = function () {\n    return inverse(this);\n};\n\nfunction solve(leftHandSide, rightHandSide) {\n    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);\n}\n\nMatrix.prototype.solve = function (other) {\n    return solve(this, other);\n};\n\nmodule.exports = {\n    SingularValueDecomposition: SingularValueDecomposition,\n    SVD: SingularValueDecomposition,\n    EigenvalueDecomposition: EigenvalueDecomposition,\n    EVD: EigenvalueDecomposition,\n    LuDecomposition: LuDecomposition,\n    LU: LuDecomposition,\n    QrDecomposition: QrDecomposition,\n    QR: QrDecomposition,\n    CholeskyDecomposition: CholeskyDecomposition,\n    CHO: CholeskyDecomposition,\n    inverse: inverse,\n    solve: solve\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-matrix/src/decompositions.js\n ** module id = 7\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\nvar hypotenuse = require('./util').hypotenuse;\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/SingularValueDecomposition.cs\nfunction SingularValueDecomposition(value, options) {\n    if (!(this instanceof SingularValueDecomposition)) {\n        return new SingularValueDecomposition(value, options);\n    }\n    value = Matrix.checkMatrix(value);\n\n    options = options || {};\n\n    var a = value.clone(),\n        m = value.rows,\n        n = value.columns,\n        nu = Math.min(m, n);\n\n    var wantu = true, wantv = true;\n    if (options.computeLeftSingularVectors === false)\n        wantu = false;\n    if (options.computeRightSingularVectors === false)\n        wantv = false;\n    var autoTranspose = options.autoTranspose === true;\n\n    var swapped = false;\n    if (m < n) {\n        if (!autoTranspose) {\n            console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose');\n        } else {\n            a = a.transpose();\n            m = a.rows;\n            n = a.columns;\n            swapped = true;\n            var aux = wantu;\n            wantu = wantv;\n            wantv = aux;\n        }\n    }\n\n    var s = new Array(Math.min(m + 1, n)),\n        U = Matrix.zeros(m, nu),\n        V = Matrix.zeros(n, n),\n        e = new Array(n),\n        work = new Array(m);\n\n    var nct = Math.min(m - 1, n);\n    var nrt = Math.max(0, Math.min(n - 2, m));\n\n    var i, j, k, p, t, ks, f, cs, sn, max, kase,\n        scale, sp, spm1, epm1, sk, ek, b, c, shift, g;\n\n    for (k = 0, max = Math.max(nct, nrt); k < max; k++) {\n        if (k < nct) {\n            s[k] = 0;\n            for (i = k; i < m; i++) {\n                s[k] = hypotenuse(s[k], a[i][k]);\n            }\n            if (s[k] !== 0) {\n                if (a[k][k] < 0) {\n                    s[k] = -s[k];\n                }\n                for (i = k; i < m; i++) {\n                    a[i][k] /= s[k];\n                }\n                a[k][k] += 1;\n            }\n            s[k] = -s[k];\n        }\n\n        for (j = k + 1; j < n; j++) {\n            if ((k < nct) && (s[k] !== 0)) {\n                t = 0;\n                for (i = k; i < m; i++) {\n                    t += a[i][k] * a[i][j];\n                }\n                t = -t / a[k][k];\n                for (i = k; i < m; i++) {\n                    a[i][j] += t * a[i][k];\n                }\n            }\n            e[j] = a[k][j];\n        }\n\n        if (wantu && (k < nct)) {\n            for (i = k; i < m; i++) {\n                U[i][k] = a[i][k];\n            }\n        }\n\n        if (k < nrt) {\n            e[k] = 0;\n            for (i = k + 1; i < n; i++) {\n                e[k] = hypotenuse(e[k], e[i]);\n            }\n            if (e[k] !== 0) {\n                if (e[k + 1] < 0)\n                    e[k] = -e[k];\n                for (i = k + 1; i < n; i++) {\n                    e[i] /= e[k];\n                }\n                e[k + 1] += 1;\n            }\n            e[k] = -e[k];\n            if ((k + 1 < m) && (e[k] !== 0)) {\n                for (i = k + 1; i < m; i++) {\n                    work[i] = 0;\n                }\n                for (j = k + 1; j < n; j++) {\n                    for (i = k + 1; i < m; i++) {\n                        work[i] += e[j] * a[i][j];\n                    }\n                }\n                for (j = k + 1; j < n; j++) {\n                    t = -e[j] / e[k + 1];\n                    for (i = k + 1; i < m; i++) {\n                        a[i][j] += t * work[i];\n                    }\n                }\n            }\n            if (wantv) {\n                for (i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n    }\n\n    p = Math.min(n, m + 1);\n    if (nct < n) {\n        s[nct] = a[nct][nct];\n    }\n    if (m < p) {\n        s[p - 1] = 0;\n    }\n    if (nrt + 1 < p) {\n        e[nrt] = a[nrt][p - 1];\n    }\n    e[p - 1] = 0;\n\n    if (wantu) {\n        for (j = nct; j < nu; j++) {\n            for (i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (k = nct - 1; k >= 0; k--) {\n            if (s[k] !== 0) {\n                for (j = k + 1; j < nu; j++) {\n                    t = 0;\n                    for (i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n    }\n\n    if (wantv) {\n        for (k = n - 1; k >= 0; k--) {\n            if ((k < nrt) && (e[k] !== 0)) {\n                for (j = k + 1; j < n; j++) {\n                    t = 0;\n                    for (i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n    }\n\n    var pp = p - 1,\n        iter = 0,\n        eps = Math.pow(2, -52);\n    while (p > 0) {\n        for (k = p - 2; k >= -1; k--) {\n            if (k === -1) {\n                break;\n            }\n            if (Math.abs(e[k]) <= eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {\n                e[k] = 0;\n                break;\n            }\n        }\n        if (k === p - 2) {\n            kase = 4;\n        } else {\n            for (ks = p - 1; ks >= k; ks--) {\n                if (ks === k) {\n                    break;\n                }\n                t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\n                if (Math.abs(s[ks]) <= eps * t) {\n                    s[ks] = 0;\n                    break;\n                }\n            }\n            if (ks === k) {\n                kase = 3;\n            } else if (ks === p - 1) {\n                kase = 1;\n            } else {\n                kase = 2;\n                k = ks;\n            }\n        }\n\n        k++;\n\n        switch (kase) {\n            case 1: {\n                f = e[p - 2];\n                e[p - 2] = 0;\n                for (j = p - 2; j >= k; j--) {\n                    t = hypotenuse(s[j], f);\n                    cs = s[j] / t;\n                    sn = f / t;\n                    s[j] = t;\n                    if (j !== k) {\n                        f = -sn * e[j - 1];\n                        e[j - 1] = cs * e[j - 1];\n                    }\n                    if (wantv) {\n                        for (i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n            }\n            case 2 : {\n                f = e[k - 1];\n                e[k - 1] = 0;\n                for (j = k; j < p; j++) {\n                    t = hypotenuse(s[j], f);\n                    cs = s[j] / t;\n                    sn = f / t;\n                    s[j] = t;\n                    f = -sn * e[j];\n                    e[j] = cs * e[j];\n                    if (wantu) {\n                        for (i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n            }\n            case 3 : {\n                scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));\n                sp = s[p - 1] / scale;\n                spm1 = s[p - 2] / scale;\n                epm1 = e[p - 2] / scale;\n                sk = s[k] / scale;\n                ek = e[k] / scale;\n                b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n                c = (sp * epm1) * (sp * epm1);\n                shift = 0;\n                if ((b !== 0) || (c !== 0)) {\n                    shift = Math.sqrt(b * b + c);\n                    if (b < 0) {\n                        shift = -shift;\n                    }\n                    shift = c / (b + shift);\n                }\n                f = (sk + sp) * (sk - sp) + shift;\n                g = sk * ek;\n                for (j = k; j < p - 1; j++) {\n                    t = hypotenuse(f, g);\n                    cs = f / t;\n                    sn = g / t;\n                    if (j !== k) {\n                        e[j - 1] = t;\n                    }\n                    f = cs * s[j] + sn * e[j];\n                    e[j] = cs * e[j] - sn * s[j];\n                    g = sn * s[j + 1];\n                    s[j + 1] = cs * s[j + 1];\n                    if (wantv) {\n                        for (i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                    }\n                    t = hypotenuse(f, g);\n                    cs = f / t;\n                    sn = g / t;\n                    s[j] = t;\n                    f = cs * e[j] + sn * s[j + 1];\n                    s[j + 1] = -sn * e[j] + cs * s[j + 1];\n                    g = sn * e[j + 1];\n                    e[j + 1] = cs * e[j + 1];\n                    if (wantu && (j < m - 1)) {\n                        for (i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][j + 1];\n                            U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                e[p - 2] = f;\n                iter = iter + 1;\n                break;\n            }\n            case 4: {\n                if (s[k] <= 0) {\n                    s[k] = (s[k] < 0 ? -s[k] : 0);\n                    if (wantv) {\n                        for (i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                }\n                while (k < pp) {\n                    if (s[k] >= s[k + 1]) {\n                        break;\n                    }\n                    t = s[k];\n                    s[k] = s[k + 1];\n                    s[k + 1] = t;\n                    if (wantv && (k < n - 1)) {\n                        for (i = 0; i < n; i++) {\n                            t = V[i][k + 1];\n                            V[i][k + 1] = V[i][k];\n                            V[i][k] = t;\n                        }\n                    }\n                    if (wantu && (k < m - 1)) {\n                        for (i = 0; i < m; i++) {\n                            t = U[i][k + 1];\n                            U[i][k + 1] = U[i][k];\n                            U[i][k] = t;\n                        }\n                    }\n                    k++;\n                }\n                iter = 0;\n                p--;\n                break;\n            }\n        }\n    }\n\n    if (swapped) {\n        var tmp = V;\n        V = U;\n        U = tmp;\n    }\n\n    this.m = m;\n    this.n = n;\n    this.s = s;\n    this.U = U;\n    this.V = V;\n}\n\nSingularValueDecomposition.prototype = {\n    get condition() {\n        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n    },\n    get norm2() {\n        return this.s[0];\n    },\n    get rank() {\n        var eps = Math.pow(2, -52),\n            tol = Math.max(this.m, this.n) * this.s[0] * eps,\n            r = 0,\n            s = this.s;\n        for (var i = 0, ii = s.length; i < ii; i++) {\n            if (s[i] > tol) {\n                r++;\n            }\n        }\n        return r;\n    },\n    get diagonal() {\n        return this.s;\n    },\n    // https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs\n    get threshold() {\n        return (Math.pow(2, -52) / 2) * Math.max(this.m, this.n) * this.s[0];\n    },\n    get leftSingularVectors() {\n        return this.U;\n    },\n    get rightSingularVectors() {\n        return this.V;\n    },\n    get diagonalMatrix() {\n        return Matrix.diag(this.s);\n    },\n    solve: function (value) {\n\n        var Y = value,\n            e = this.threshold,\n            scols = this.s.length,\n            Ls = Matrix.zeros(scols, scols),\n            i;\n\n        for (i = 0; i < scols; i++) {\n            if (Math.abs(this.s[i]) <= e) {\n                Ls[i][i] = 0;\n            } else {\n                Ls[i][i] = 1 / this.s[i];\n            }\n        }\n\n\n        var VL = this.V.mmul(Ls),\n            vrows = this.V.rows,\n            urows = this.U.rows,\n            VLU = Matrix.zeros(vrows, urows),\n            j, k, sum;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < urows; j++) {\n                sum = 0;\n                for (k = 0; k < scols; k++) {\n                    sum += VL[i][k] * this.U[j][k];\n                }\n                VLU[i][j] = sum;\n            }\n        }\n\n        return VLU.mmul(Y);\n    },\n    solveForDiagonal: function (value) {\n        return this.solve(Matrix.diag(value));\n    },\n    inverse: function () {\n        var e = this.threshold,\n            vrows = this.V.rows,\n            vcols = this.V.columns,\n            X = new Matrix(vrows, this.s.length),\n            i, j;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < vcols; j++) {\n                if (Math.abs(this.s[j]) > e) {\n                    X[i][j] = this.V[i][j] / this.s[j];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n\n        var urows = this.U.rows,\n            ucols = this.U.columns,\n            Y = new Matrix(vrows, urows),\n            k, sum;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < urows; j++) {\n                sum = 0;\n                for (k = 0; k < ucols; k++) {\n                    sum += X[i][k] * this.U[j][k];\n                }\n                Y[i][j] = sum;\n            }\n        }\n\n        return Y;\n    }\n};\n\nmodule.exports = SingularValueDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-matrix/src/dc/svd.js\n ** module id = 8\n ** module chunks = 0\n **/","'use strict';\n\nexports.hypotenuse = function hypotenuse(a, b) {\n    var r;\n    if (Math.abs(a) > Math.abs(b)) {\n        r = b / a;\n        return Math.abs(a) * Math.sqrt(1 + r * r);\n    }\n    if (b !== 0) {\n        r = a / b;\n        return Math.abs(b) * Math.sqrt(1 + r * r);\n    }\n    return 0;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-matrix/src/dc/util.js\n ** module id = 9\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\nvar hypotenuse = require('./util').hypotenuse;\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs\nfunction EigenvalueDecomposition(matrix) {\n    if (!(this instanceof EigenvalueDecomposition)) {\n        return new EigenvalueDecomposition(matrix);\n    }\n    matrix = Matrix.checkMatrix(matrix);\n    if (!matrix.isSquare()) {\n        throw new Error('Matrix is not a square matrix');\n    }\n\n    var n = matrix.columns,\n        V = Matrix.zeros(n, n),\n        d = new Array(n),\n        e = new Array(n),\n        value = matrix,\n        i, j;\n\n    if (matrix.isSymmetric()) {\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                V[i][j] = value[i][j];\n            }\n        }\n        tred2(n, e, d, V);\n        tql2(n, e, d, V);\n    }\n    else {\n        var H = Matrix.zeros(n, n),\n            ort = new Array(n);\n        for (j = 0; j < n; j++) {\n            for (i = 0; i < n; i++) {\n                H[i][j] = value[i][j];\n            }\n        }\n        orthes(n, H, ort, V);\n        hqr2(n, e, d, V, H);\n    }\n\n    this.n = n;\n    this.e = e;\n    this.d = d;\n    this.V = V;\n}\n\nEigenvalueDecomposition.prototype = {\n    get realEigenvalues() {\n        return this.d;\n    },\n    get imaginaryEigenvalues() {\n        return this.e;\n    },\n    get eigenvectorMatrix() {\n        return this.V;\n    },\n    get diagonalMatrix() {\n        var n = this.n,\n            e = this.e,\n            d = this.d,\n            X = new Matrix(n, n),\n            i, j;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                X[i][j] = 0;\n            }\n            X[i][i] = d[i];\n            if (e[i] > 0) {\n                X[i][i + 1] = e[i];\n            }\n            else if (e[i] < 0) {\n                X[i][i - 1] = e[i];\n            }\n        }\n        return X;\n    }\n};\n\nfunction tred2(n, e, d, V) {\n\n    var f, g, h, i, j, k,\n        hh, scale;\n\n    for (j = 0; j < n; j++) {\n        d[j] = V[n - 1][j];\n    }\n\n    for (i = n - 1; i > 0; i--) {\n        scale = 0;\n        h = 0;\n        for (k = 0; k < i; k++) {\n            scale = scale + Math.abs(d[k]);\n        }\n\n        if (scale === 0) {\n            e[i] = d[i - 1];\n            for (j = 0; j < i; j++) {\n                d[j] = V[i - 1][j];\n                V[i][j] = 0;\n                V[j][i] = 0;\n            }\n        } else {\n            for (k = 0; k < i; k++) {\n                d[k] /= scale;\n                h += d[k] * d[k];\n            }\n\n            f = d[i - 1];\n            g = Math.sqrt(h);\n            if (f > 0) {\n                g = -g;\n            }\n\n            e[i] = scale * g;\n            h = h - f * g;\n            d[i - 1] = f - g;\n            for (j = 0; j < i; j++) {\n                e[j] = 0;\n            }\n\n            for (j = 0; j < i; j++) {\n                f = d[j];\n                V[j][i] = f;\n                g = e[j] + V[j][j] * f;\n                for (k = j + 1; k <= i - 1; k++) {\n                    g += V[k][j] * d[k];\n                    e[k] += V[k][j] * f;\n                }\n                e[j] = g;\n            }\n\n            f = 0;\n            for (j = 0; j < i; j++) {\n                e[j] /= h;\n                f += e[j] * d[j];\n            }\n\n            hh = f / (h + h);\n            for (j = 0; j < i; j++) {\n                e[j] -= hh * d[j];\n            }\n\n            for (j = 0; j < i; j++) {\n                f = d[j];\n                g = e[j];\n                for (k = j; k <= i - 1; k++) {\n                    V[k][j] -= (f * e[k] + g * d[k]);\n                }\n                d[j] = V[i - 1][j];\n                V[i][j] = 0;\n            }\n        }\n        d[i] = h;\n    }\n\n    for (i = 0; i < n - 1; i++) {\n        V[n - 1][i] = V[i][i];\n        V[i][i] = 1;\n        h = d[i + 1];\n        if (h !== 0) {\n            for (k = 0; k <= i; k++) {\n                d[k] = V[k][i + 1] / h;\n            }\n\n            for (j = 0; j <= i; j++) {\n                g = 0;\n                for (k = 0; k <= i; k++) {\n                    g += V[k][i + 1] * V[k][j];\n                }\n                for (k = 0; k <= i; k++) {\n                    V[k][j] -= g * d[k];\n                }\n            }\n        }\n\n        for (k = 0; k <= i; k++) {\n            V[k][i + 1] = 0;\n        }\n    }\n\n    for (j = 0; j < n; j++) {\n        d[j] = V[n - 1][j];\n        V[n - 1][j] = 0;\n    }\n\n    V[n - 1][n - 1] = 1;\n    e[0] = 0;\n}\n\nfunction tql2(n, e, d, V) {\n\n    var g, h, i, j, k, l, m, p, r,\n        dl1, c, c2, c3, el1, s, s2,\n        iter;\n\n    for (i = 1; i < n; i++) {\n        e[i - 1] = e[i];\n    }\n\n    e[n - 1] = 0;\n\n    var f = 0,\n        tst1 = 0,\n        eps = Math.pow(2, -52);\n\n    for (l = 0; l < n; l++) {\n        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\n        m = l;\n        while (m < n) {\n            if (Math.abs(e[m]) <= eps * tst1) {\n                break;\n            }\n            m++;\n        }\n\n        if (m > l) {\n            iter = 0;\n            do {\n                iter = iter + 1;\n\n                g = d[l];\n                p = (d[l + 1] - g) / (2 * e[l]);\n                r = hypotenuse(p, 1);\n                if (p < 0) {\n                    r = -r;\n                }\n\n                d[l] = e[l] / (p + r);\n                d[l + 1] = e[l] * (p + r);\n                dl1 = d[l + 1];\n                h = g - d[l];\n                for (i = l + 2; i < n; i++) {\n                    d[i] -= h;\n                }\n\n                f = f + h;\n\n                p = d[m];\n                c = 1;\n                c2 = c;\n                c3 = c;\n                el1 = e[l + 1];\n                s = 0;\n                s2 = 0;\n                for (i = m - 1; i >= l; i--) {\n                    c3 = c2;\n                    c2 = c;\n                    s2 = s;\n                    g = c * e[i];\n                    h = c * p;\n                    r = hypotenuse(p, e[i]);\n                    e[i + 1] = s * r;\n                    s = e[i] / r;\n                    c = p / r;\n                    p = c * d[i] - s * g;\n                    d[i + 1] = h + s * (c * g + s * d[i]);\n\n                    for (k = 0; k < n; k++) {\n                        h = V[k][i + 1];\n                        V[k][i + 1] = s * V[k][i] + c * h;\n                        V[k][i] = c * V[k][i] - s * h;\n                    }\n                }\n\n                p = -s * s2 * c3 * el1 * e[l] / dl1;\n                e[l] = s * p;\n                d[l] = c * p;\n\n            }\n            while (Math.abs(e[l]) > eps * tst1);\n        }\n        d[l] = d[l] + f;\n        e[l] = 0;\n    }\n\n    for (i = 0; i < n - 1; i++) {\n        k = i;\n        p = d[i];\n        for (j = i + 1; j < n; j++) {\n            if (d[j] < p) {\n                k = j;\n                p = d[j];\n            }\n        }\n\n        if (k !== i) {\n            d[k] = d[i];\n            d[i] = p;\n            for (j = 0; j < n; j++) {\n                p = V[j][i];\n                V[j][i] = V[j][k];\n                V[j][k] = p;\n            }\n        }\n    }\n}\n\nfunction orthes(n, H, ort, V) {\n\n    var low = 0,\n        high = n - 1,\n        f, g, h, i, j, m,\n        scale;\n\n    for (m = low + 1; m <= high - 1; m++) {\n        scale = 0;\n        for (i = m; i <= high; i++) {\n            scale = scale + Math.abs(H[i][m - 1]);\n        }\n\n        if (scale !== 0) {\n            h = 0;\n            for (i = high; i >= m; i--) {\n                ort[i] = H[i][m - 1] / scale;\n                h += ort[i] * ort[i];\n            }\n\n            g = Math.sqrt(h);\n            if (ort[m] > 0) {\n                g = -g;\n            }\n\n            h = h - ort[m] * g;\n            ort[m] = ort[m] - g;\n\n            for (j = m; j < n; j++) {\n                f = 0;\n                for (i = high; i >= m; i--) {\n                    f += ort[i] * H[i][j];\n                }\n\n                f = f / h;\n                for (i = m; i <= high; i++) {\n                    H[i][j] -= f * ort[i];\n                }\n            }\n\n            for (i = 0; i <= high; i++) {\n                f = 0;\n                for (j = high; j >= m; j--) {\n                    f += ort[j] * H[i][j];\n                }\n\n                f = f / h;\n                for (j = m; j <= high; j++) {\n                    H[i][j] -= f * ort[j];\n                }\n            }\n\n            ort[m] = scale * ort[m];\n            H[m][m - 1] = scale * g;\n        }\n    }\n\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            V[i][j] = (i === j ? 1 : 0);\n        }\n    }\n\n    for (m = high - 1; m >= low + 1; m--) {\n        if (H[m][m - 1] !== 0) {\n            for (i = m + 1; i <= high; i++) {\n                ort[i] = H[i][m - 1];\n            }\n\n            for (j = m; j <= high; j++) {\n                g = 0;\n                for (i = m; i <= high; i++) {\n                    g += ort[i] * V[i][j];\n                }\n\n                g = (g / ort[m]) / H[m][m - 1];\n                for (i = m; i <= high; i++) {\n                    V[i][j] += g * ort[i];\n                }\n            }\n        }\n    }\n}\n\nfunction hqr2(nn, e, d, V, H) {\n    var n = nn - 1,\n        low = 0,\n        high = nn - 1,\n        eps = Math.pow(2, -52),\n        exshift = 0,\n        norm = 0,\n        p = 0,\n        q = 0,\n        r = 0,\n        s = 0,\n        z = 0,\n        iter = 0,\n        i, j, k, l, m, t, w, x, y,\n        ra, sa, vr, vi,\n        notlast, cdivres;\n\n    for (i = 0; i < nn; i++) {\n        if (i < low || i > high) {\n            d[i] = H[i][i];\n            e[i] = 0;\n        }\n\n        for (j = Math.max(i - 1, 0); j < nn; j++) {\n            norm = norm + Math.abs(H[i][j]);\n        }\n    }\n\n    while (n >= low) {\n        l = n;\n        while (l > low) {\n            s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);\n            if (s === 0) {\n                s = norm;\n            }\n            if (Math.abs(H[l][l - 1]) < eps * s) {\n                break;\n            }\n            l--;\n        }\n\n        if (l === n) {\n            H[n][n] = H[n][n] + exshift;\n            d[n] = H[n][n];\n            e[n] = 0;\n            n--;\n            iter = 0;\n        } else if (l === n - 1) {\n            w = H[n][n - 1] * H[n - 1][n];\n            p = (H[n - 1][n - 1] - H[n][n]) / 2;\n            q = p * p + w;\n            z = Math.sqrt(Math.abs(q));\n            H[n][n] = H[n][n] + exshift;\n            H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;\n            x = H[n][n];\n\n            if (q >= 0) {\n                z = (p >= 0) ? (p + z) : (p - z);\n                d[n - 1] = x + z;\n                d[n] = d[n - 1];\n                if (z !== 0) {\n                    d[n] = x - w / z;\n                }\n                e[n - 1] = 0;\n                e[n] = 0;\n                x = H[n][n - 1];\n                s = Math.abs(x) + Math.abs(z);\n                p = x / s;\n                q = z / s;\n                r = Math.sqrt(p * p + q * q);\n                p = p / r;\n                q = q / r;\n\n                for (j = n - 1; j < nn; j++) {\n                    z = H[n - 1][j];\n                    H[n - 1][j] = q * z + p * H[n][j];\n                    H[n][j] = q * H[n][j] - p * z;\n                }\n\n                for (i = 0; i <= n; i++) {\n                    z = H[i][n - 1];\n                    H[i][n - 1] = q * z + p * H[i][n];\n                    H[i][n] = q * H[i][n] - p * z;\n                }\n\n                for (i = low; i <= high; i++) {\n                    z = V[i][n - 1];\n                    V[i][n - 1] = q * z + p * V[i][n];\n                    V[i][n] = q * V[i][n] - p * z;\n                }\n            } else {\n                d[n - 1] = x + p;\n                d[n] = x + p;\n                e[n - 1] = z;\n                e[n] = -z;\n            }\n\n            n = n - 2;\n            iter = 0;\n        } else {\n            x = H[n][n];\n            y = 0;\n            w = 0;\n            if (l < n) {\n                y = H[n - 1][n - 1];\n                w = H[n][n - 1] * H[n - 1][n];\n            }\n\n            if (iter === 10) {\n                exshift += x;\n                for (i = low; i <= n; i++) {\n                    H[i][i] -= x;\n                }\n                s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);\n                x = y = 0.75 * s;\n                w = -0.4375 * s * s;\n            }\n\n            if (iter === 30) {\n                s = (y - x) / 2;\n                s = s * s + w;\n                if (s > 0) {\n                    s = Math.sqrt(s);\n                    if (y < x) {\n                        s = -s;\n                    }\n                    s = x - w / ((y - x) / 2 + s);\n                    for (i = low; i <= n; i++) {\n                        H[i][i] -= s;\n                    }\n                    exshift += s;\n                    x = y = w = 0.964;\n                }\n            }\n\n            iter = iter + 1;\n\n            m = n - 2;\n            while (m >= l) {\n                z = H[m][m];\n                r = x - z;\n                s = y - z;\n                p = (r * s - w) / H[m + 1][m] + H[m][m + 1];\n                q = H[m + 1][m + 1] - z - r - s;\n                r = H[m + 2][m + 1];\n                s = Math.abs(p) + Math.abs(q) + Math.abs(r);\n                p = p / s;\n                q = q / s;\n                r = r / s;\n                if (m === l) {\n                    break;\n                }\n                if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) + Math.abs(H[m + 1][m + 1])))) {\n                    break;\n                }\n                m--;\n            }\n\n            for (i = m + 2; i <= n; i++) {\n                H[i][i - 2] = 0;\n                if (i > m + 2) {\n                    H[i][i - 3] = 0;\n                }\n            }\n\n            for (k = m; k <= n - 1; k++) {\n                notlast = (k !== n - 1);\n                if (k !== m) {\n                    p = H[k][k - 1];\n                    q = H[k + 1][k - 1];\n                    r = (notlast ? H[k + 2][k - 1] : 0);\n                    x = Math.abs(p) + Math.abs(q) + Math.abs(r);\n                    if (x !== 0) {\n                        p = p / x;\n                        q = q / x;\n                        r = r / x;\n                    }\n                }\n\n                if (x === 0) {\n                    break;\n                }\n\n                s = Math.sqrt(p * p + q * q + r * r);\n                if (p < 0) {\n                    s = -s;\n                }\n\n                if (s !== 0) {\n                    if (k !== m) {\n                        H[k][k - 1] = -s * x;\n                    } else if (l !== m) {\n                        H[k][k - 1] = -H[k][k - 1];\n                    }\n\n                    p = p + s;\n                    x = p / s;\n                    y = q / s;\n                    z = r / s;\n                    q = q / p;\n                    r = r / p;\n\n                    for (j = k; j < nn; j++) {\n                        p = H[k][j] + q * H[k + 1][j];\n                        if (notlast) {\n                            p = p + r * H[k + 2][j];\n                            H[k + 2][j] = H[k + 2][j] - p * z;\n                        }\n\n                        H[k][j] = H[k][j] - p * x;\n                        H[k + 1][j] = H[k + 1][j] - p * y;\n                    }\n\n                    for (i = 0; i <= Math.min(n, k + 3); i++) {\n                        p = x * H[i][k] + y * H[i][k + 1];\n                        if (notlast) {\n                            p = p + z * H[i][k + 2];\n                            H[i][k + 2] = H[i][k + 2] - p * r;\n                        }\n\n                        H[i][k] = H[i][k] - p;\n                        H[i][k + 1] = H[i][k + 1] - p * q;\n                    }\n\n                    for (i = low; i <= high; i++) {\n                        p = x * V[i][k] + y * V[i][k + 1];\n                        if (notlast) {\n                            p = p + z * V[i][k + 2];\n                            V[i][k + 2] = V[i][k + 2] - p * r;\n                        }\n\n                        V[i][k] = V[i][k] - p;\n                        V[i][k + 1] = V[i][k + 1] - p * q;\n                    }\n                }\n            }\n        }\n    }\n\n    if (norm === 0) {\n        return;\n    }\n\n    for (n = nn - 1; n >= 0; n--) {\n        p = d[n];\n        q = e[n];\n\n        if (q === 0) {\n            l = n;\n            H[n][n] = 1;\n            for (i = n - 1; i >= 0; i--) {\n                w = H[i][i] - p;\n                r = 0;\n                for (j = l; j <= n; j++) {\n                    r = r + H[i][j] * H[j][n];\n                }\n\n                if (e[i] < 0) {\n                    z = w;\n                    s = r;\n                } else {\n                    l = i;\n                    if (e[i] === 0) {\n                        H[i][n] = (w !== 0) ? (-r / w) : (-r / (eps * norm));\n                    } else {\n                        x = H[i][i + 1];\n                        y = H[i + 1][i];\n                        q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\n                        t = (x * s - z * r) / q;\n                        H[i][n] = t;\n                        H[i + 1][n] = (Math.abs(x) > Math.abs(z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);\n                    }\n\n                    t = Math.abs(H[i][n]);\n                    if ((eps * t) * t > 1) {\n                        for (j = i; j <= n; j++) {\n                            H[j][n] = H[j][n] / t;\n                        }\n                    }\n                }\n            }\n        } else if (q < 0) {\n            l = n - 1;\n\n            if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {\n                H[n - 1][n - 1] = q / H[n][n - 1];\n                H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];\n            } else {\n                cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);\n                H[n - 1][n - 1] = cdivres[0];\n                H[n - 1][n] = cdivres[1];\n            }\n\n            H[n][n - 1] = 0;\n            H[n][n] = 1;\n            for (i = n - 2; i >= 0; i--) {\n                ra = 0;\n                sa = 0;\n                for (j = l; j <= n; j++) {\n                    ra = ra + H[i][j] * H[j][n - 1];\n                    sa = sa + H[i][j] * H[j][n];\n                }\n\n                w = H[i][i] - p;\n\n                if (e[i] < 0) {\n                    z = w;\n                    r = ra;\n                    s = sa;\n                } else {\n                    l = i;\n                    if (e[i] === 0) {\n                        cdivres = cdiv(-ra, -sa, w, q);\n                        H[i][n - 1] = cdivres[0];\n                        H[i][n] = cdivres[1];\n                    } else {\n                        x = H[i][i + 1];\n                        y = H[i + 1][i];\n                        vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\n                        vi = (d[i] - p) * 2 * q;\n                        if (vr === 0 && vi === 0) {\n                            vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));\n                        }\n                        cdivres = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);\n                        H[i][n - 1] = cdivres[0];\n                        H[i][n] = cdivres[1];\n                        if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {\n                            H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;\n                            H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;\n                        } else {\n                            cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);\n                            H[i + 1][n - 1] = cdivres[0];\n                            H[i + 1][n] = cdivres[1];\n                        }\n                    }\n\n                    t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));\n                    if ((eps * t) * t > 1) {\n                        for (j = i; j <= n; j++) {\n                            H[j][n - 1] = H[j][n - 1] / t;\n                            H[j][n] = H[j][n] / t;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < nn; i++) {\n        if (i < low || i > high) {\n            for (j = i; j < nn; j++) {\n                V[i][j] = H[i][j];\n            }\n        }\n    }\n\n    for (j = nn - 1; j >= low; j--) {\n        for (i = low; i <= high; i++) {\n            z = 0;\n            for (k = low; k <= Math.min(j, high); k++) {\n                z = z + V[i][k] * H[k][j];\n            }\n            V[i][j] = z;\n        }\n    }\n}\n\nfunction cdiv(xr, xi, yr, yi) {\n    var r, d;\n    if (Math.abs(yr) > Math.abs(yi)) {\n        r = yi / yr;\n        d = yr + r * yi;\n        return [(xr + r * xi) / d, (xi - r * xr) / d];\n    }\n    else {\n        r = yr / yi;\n        d = yi + r * yr;\n        return [(r * xr + xi) / d, (r * xi - xr) / d];\n    }\n}\n\nmodule.exports = EigenvalueDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-matrix/src/dc/evd.js\n ** module id = 10\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs\nfunction LuDecomposition(matrix) {\n    if (!(this instanceof LuDecomposition)) {\n        return new LuDecomposition(matrix);\n    }\n    matrix = Matrix.checkMatrix(matrix);\n\n    var lu = matrix.clone(),\n        rows = lu.rows,\n        columns = lu.columns,\n        pivotVector = new Array(rows),\n        pivotSign = 1,\n        i, j, k, p, s, t, v,\n        LUrowi, LUcolj, kmax;\n\n    for (i = 0; i < rows; i++) {\n        pivotVector[i] = i;\n    }\n\n    LUcolj = new Array(rows);\n\n    for (j = 0; j < columns; j++) {\n\n        for (i = 0; i < rows; i++) {\n            LUcolj[i] = lu[i][j];\n        }\n\n        for (i = 0; i < rows; i++) {\n            LUrowi = lu[i];\n            kmax = Math.min(i, j);\n            s = 0;\n            for (k = 0; k < kmax; k++) {\n                s += LUrowi[k] * LUcolj[k];\n            }\n            LUrowi[j] = LUcolj[i] -= s;\n        }\n\n        p = j;\n        for (i = j + 1; i < rows; i++) {\n            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n                p = i;\n            }\n        }\n\n        if (p !== j) {\n            for (k = 0; k < columns; k++) {\n                t = lu[p][k];\n                lu[p][k] = lu[j][k];\n                lu[j][k] = t;\n            }\n\n            v = pivotVector[p];\n            pivotVector[p] = pivotVector[j];\n            pivotVector[j] = v;\n\n            pivotSign = -pivotSign;\n        }\n\n        if (j < rows && lu[j][j] !== 0) {\n            for (i = j + 1; i < rows; i++) {\n                lu[i][j] /= lu[j][j];\n            }\n        }\n    }\n\n    this.LU = lu;\n    this.pivotVector = pivotVector;\n    this.pivotSign = pivotSign;\n}\n\nLuDecomposition.prototype = {\n    isSingular: function () {\n        var data = this.LU,\n            col = data.columns;\n        for (var j = 0; j < col; j++) {\n            if (data[j][j] === 0) {\n                return true;\n            }\n        }\n        return false;\n    },\n    get determinant() {\n        var data = this.LU;\n        if (!data.isSquare())\n            throw new Error('Matrix must be square');\n        var determinant = this.pivotSign, col = data.columns;\n        for (var j = 0; j < col; j++)\n            determinant *= data[j][j];\n        return determinant;\n    },\n    get lowerTriangularFactor() {\n        var data = this.LU,\n            rows = data.rows,\n            columns = data.columns,\n            X = new Matrix(rows, columns);\n        for (var i = 0; i < rows; i++) {\n            for (var j = 0; j < columns; j++) {\n                if (i > j) {\n                    X[i][j] = data[i][j];\n                } else if (i === j) {\n                    X[i][j] = 1;\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get upperTriangularFactor() {\n        var data = this.LU,\n            rows = data.rows,\n            columns = data.columns,\n            X = new Matrix(rows, columns);\n        for (var i = 0; i < rows; i++) {\n            for (var j = 0; j < columns; j++) {\n                if (i <= j) {\n                    X[i][j] = data[i][j];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get pivotPermutationVector() {\n        return this.pivotVector.slice();\n    },\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var lu = this.LU,\n            rows = lu.rows;\n\n        if (rows !== value.rows)\n            throw new Error('Invalid matrix dimensions');\n        if (this.isSingular())\n            throw new Error('LU matrix is singular');\n\n        var count = value.columns,\n            X = value.subMatrixRow(this.pivotVector, 0, count - 1),\n            columns = lu.columns,\n            i, j, k;\n\n        for (k = 0; k < columns; k++) {\n            for (i = k + 1; i < columns; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * lu[i][k];\n                }\n            }\n        }\n        for (k = columns - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                X[k][j] /= lu[k][k];\n            }\n            for (i = 0; i < k; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * lu[i][k];\n                }\n            }\n        }\n        return X;\n    }\n};\n\nmodule.exports = LuDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-matrix/src/dc/lu.js\n ** module id = 11\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\nvar hypotenuse = require('./util').hypotenuse;\n\n//https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs\nfunction QrDecomposition(value) {\n    if (!(this instanceof QrDecomposition)) {\n        return new QrDecomposition(value);\n    }\n    value = Matrix.checkMatrix(value);\n\n    var qr = value.clone(),\n        m = value.rows,\n        n = value.columns,\n        rdiag = new Array(n),\n        i, j, k, s;\n\n    for (k = 0; k < n; k++) {\n        var nrm = 0;\n        for (i = k; i < m; i++) {\n            nrm = hypotenuse(nrm, qr[i][k]);\n        }\n        if (nrm !== 0) {\n            if (qr[k][k] < 0) {\n                nrm = -nrm;\n            }\n            for (i = k; i < m; i++) {\n                qr[i][k] /= nrm;\n            }\n            qr[k][k] += 1;\n            for (j = k + 1; j < n; j++) {\n                s = 0;\n                for (i = k; i < m; i++) {\n                    s += qr[i][k] * qr[i][j];\n                }\n                s = -s / qr[k][k];\n                for (i = k; i < m; i++) {\n                    qr[i][j] += s * qr[i][k];\n                }\n            }\n        }\n        rdiag[k] = -nrm;\n    }\n\n    this.QR = qr;\n    this.Rdiag = rdiag;\n}\n\nQrDecomposition.prototype = {\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var qr = this.QR,\n            m = qr.rows;\n\n        if (value.rows !== m)\n            throw new Error('Matrix row dimensions must agree');\n        if (!this.isFullRank())\n            throw new Error('Matrix is rank deficient');\n\n        var count = value.columns,\n            X = value.clone(),\n            n = qr.columns,\n            i, j, k, s;\n\n        for (k = 0; k < n; k++) {\n            for (j = 0; j < count; j++) {\n                s = 0;\n                for (i = k; i < m; i++) {\n                    s += qr[i][k] * X[i][j];\n                }\n                s = -s / qr[k][k];\n                for (i = k; i < m; i++) {\n                    X[i][j] += s * qr[i][k];\n                }\n            }\n        }\n        for (k = n - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                X[k][j] /= this.Rdiag[k];\n            }\n            for (i = 0; i < k; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * qr[i][k];\n                }\n            }\n        }\n\n        return X.subMatrix(0, n - 1, 0, count - 1);\n    },\n    isFullRank: function () {\n        var columns = this.QR.columns;\n        for (var i = 0; i < columns; i++) {\n            if (this.Rdiag[i] === 0) {\n                return false;\n            }\n        }\n        return true;\n    },\n    get upperTriangularFactor() {\n        var qr = this.QR,\n            n = qr.columns,\n            X = new Matrix(n, n),\n            i, j;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                if (i < j) {\n                    X[i][j] = qr[i][j];\n                } else if (i === j) {\n                    X[i][j] = this.Rdiag[i];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get orthogonalFactor() {\n        var qr = this.QR,\n            rows = qr.rows,\n            columns = qr.columns,\n            X = new Matrix(rows, columns),\n            i, j, k, s;\n\n        for (k = columns - 1; k >= 0; k--) {\n            for (i = 0; i < rows; i++) {\n                X[i][k] = 0;\n            }\n            X[k][k] = 1;\n            for (j = k; j < columns; j++) {\n                if (qr[k][k] !== 0) {\n                    s = 0;\n                    for (i = k; i < rows; i++) {\n                        s += qr[i][k] * X[i][j];\n                    }\n\n                    s = -s / qr[k][k];\n\n                    for (i = k; i < rows; i++) {\n                        X[i][j] += s * qr[i][k];\n                    }\n                }\n            }\n        }\n        return X;\n    }\n};\n\nmodule.exports = QrDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-matrix/src/dc/qr.js\n ** module id = 12\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs\nfunction CholeskyDecomposition(value) {\n    if (!(this instanceof CholeskyDecomposition)) {\n        return new CholeskyDecomposition(value);\n    }\n    value = Matrix.checkMatrix(value);\n    if (!value.isSymmetric())\n        throw new Error('Matrix is not symmetric');\n\n    var a = value,\n        dimension = a.rows,\n        l = new Matrix(dimension, dimension),\n        positiveDefinite = true,\n        i, j, k;\n\n    for (j = 0; j < dimension; j++) {\n        var Lrowj = l[j];\n        var d = 0;\n        for (k = 0; k < j; k++) {\n            var Lrowk = l[k];\n            var s = 0;\n            for (i = 0; i < k; i++) {\n                s += Lrowk[i] * Lrowj[i];\n            }\n            Lrowj[k] = s = (a[j][k] - s) / l[k][k];\n            d = d + s * s;\n        }\n\n        d = a[j][j] - d;\n\n        positiveDefinite &= (d > 0);\n        l[j][j] = Math.sqrt(Math.max(d, 0));\n        for (k = j + 1; k < dimension; k++) {\n            l[j][k] = 0;\n        }\n    }\n\n    if (!positiveDefinite) {\n        throw new Error('Matrix is not positive definite');\n    }\n\n    this.L = l;\n}\n\nCholeskyDecomposition.prototype = {\n    get leftTriangularFactor() {\n        return this.L;\n    },\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var l = this.L,\n            dimension = l.rows;\n\n        if (value.rows !== dimension) {\n            throw new Error('Matrix dimensions do not match');\n        }\n\n        var count = value.columns,\n            B = value.clone(),\n            i, j, k;\n\n        for (k = 0; k < dimension; k++) {\n            for (j = 0; j < count; j++) {\n                for (i = 0; i < k; i++) {\n                    B[k][j] -= B[i][j] * l[k][i];\n                }\n                B[k][j] /= l[k][k];\n            }\n        }\n\n        for (k = dimension - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                for (i = k + 1; i < dimension; i++) {\n                    B[k][j] -= B[i][j] * l[i][k];\n                }\n                B[k][j] /= l[k][k];\n            }\n        }\n\n        return B;\n    }\n};\n\nmodule.exports = CholeskyDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-matrix/src/dc/cholesky.js\n ** module id = 13\n ** module chunks = 0\n **/","/**\n * Created by acastillo on 8/24/15.\n */\n/**\n * Non in-place function definitions, compatible with mathjs code *\n */\n\n'use strict';\n\nvar Matrix = require('ml-matrix');\n\nfunction matrix(A,B){\n    return new Matrix(A,B);\n}\n\nfunction ones(rows, cols){\n    return Matrix.ones(rows,cols);\n}\n\nfunction eye(rows, cols){\n    return Matrix.eye(rows, cols);\n}\n\nfunction zeros(rows, cols){\n    return Matrix.zeros(rows, cols);\n}\n\nfunction random(rows, cols){\n    return Matrix.rand(rows,cols);\n}\n\nfunction transpose(A){\n    if(typeof A == 'number')\n        return A;\n    var result = A.clone();\n    return result.transpose();\n}\n\nfunction add(A, B){\n    if(typeof A == 'number'&&typeof B === 'number')\n        return A+B;\n    if(typeof A == 'number')\n        return this.add(B,A);\n\n    var result = A.clone();\n    return result.add(B);\n\n}\n\nfunction subtract(A, B){\n    if(typeof A == 'number'&&typeof B === 'number')\n        return A-B;\n    if(typeof A == 'number')\n        return this.subtract(B,A);\n    var result = A.clone();\n    return result.sub(B);\n}\n\nfunction multiply(A, B){\n    if(typeof A == 'number'&&typeof B === 'number')\n        return A*B;\n    if(typeof A == 'number')\n        return this.multiply(B,A);\n\n    var result = A.clone();\n\n    if(typeof B === 'number')\n        result.mul(B);\n    else\n        result = result.mmul(B);\n\n    if(result.rows==1&&result.columns==1)\n        return result[0][0];\n    else\n        return result;\n\n}\n\nfunction dotMultiply(A, B){\n    var result = A.clone();\n    return result.mul(B);\n}\n\nfunction dotDivide(A, B){\n    var result = A.clone();\n    return result.div(B);\n}\n\nfunction diag(A){\n    var diag = null;\n    var rows = A.rows, cols = A.columns, j, r;\n    //It is an array\n    if(typeof cols === \"undefined\" && (typeof A)=='object'){\n        if(A[0]&&A[0].length){\n            rows = A.length;\n            cols = A[0].length;\n            r = Math.min(rows,cols);\n            diag = Matrix.zeros(cols, cols);\n            for (j = 0; j < cols; j++) {\n                diag[j][j]=A[j][j];\n            }\n        }\n        else{\n            cols = A.length;\n            diag = Matrix.zeros(cols, cols);\n            for (j = 0; j < cols; j++) {\n                diag[j][j]=A[j];\n            }\n        }\n\n    }\n    if(rows == 1){\n        diag = Matrix.zeros(cols, cols);\n        for (j = 0; j < cols; j++) {\n            diag[j][j]=A[0][j];\n        }\n    }\n    else{\n        if(rows>0 && cols > 0){\n            r = Math.min(rows,cols);\n            diag = new Array(r);\n            for (j = 0; j < r; j++) {\n                diag[j] = A[j][j];\n            }\n        }\n    }\n    return diag;\n}\n\nfunction min(A, B){\n    if(typeof A==='number' && typeof B ==='number')\n        return Math.min(A,B);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (A[i][j] < B[i][j]) {\n                result[i][j] = A[i][j];\n            }\n            else{\n                result[i][j] = B[i][j];\n            }\n        }\n    }\n    return result;\n}\n\nfunction max(A, B){\n    if(typeof A==='number' && typeof B ==='number')\n        return Math.max(A,B);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (A[i][j] > B[i][j]) {\n                result[i][j] = A[i][j];\n            }\n            else{\n                result[i][j] = B[i][j];\n            }\n        }\n    }\n    return result;\n}\n\nfunction sqrt(A){\n    if(typeof A==='number' )\n        return Math.sqrt(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.sqrt(A[i][j]);\n\n        }\n    }\n    return result;\n}\n\nfunction abs(A){\n    if(typeof A==='number' )\n        return Math.abs(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.abs(A[i][j]);\n\n        }\n    }\n    return result;\n}\n\nfunction exp(A){\n    if(typeof A==='number' )\n        return Math.sqrt(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.exp(A[i][j]);\n        }\n    }\n    return result;\n}\n\nfunction dotPow(A, b){\n    if(typeof A==='number' )\n        return Math.pow(A,b);\n    //console.log(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.pow(A[i][j],b);\n        }\n    }\n    return result;\n}\n\nfunction solve(A, B){\n    return A.solve(B);\n}\n\nfunction inv(A){\n    if(typeof A ===\"number\")\n        return 1/A;\n    return A.inverse();\n}\n\nmodule.exports = {\n    transpose:transpose,\n    add:add,\n    subtract:subtract,\n    multiply:multiply,\n    dotMultiply:dotMultiply,\n    dotDivide:dotDivide,\n    diag:diag,\n    min:min,\n    max:max,\n    solve:solve,\n    inv:inv,\n    sqrt:sqrt,\n    exp:exp,\n    dotPow:dotPow,\n    abs:abs,\n    matrix:matrix,\n    ones:ones,\n    zeros:zeros,\n    random:random,\n    eye:eye\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-curve-fitting/src/algebra.js\n ** module id = 14\n ** module chunks = 0\n **/","var Opt = require(\"ml-optimize-lorentzian\");\nvar stats = require(\"ml-stat\");\nvar extend = require('extend');\nvar SG = require('ml-savitzky-golay-generalized');\n\nvar sgDefOptions = {\n    windowSize: 9,\n    polynomial: 3\n};\n\n\nfunction gsd(x, y, options){\n    //options = extend({}, defaultOptions, options);\n    var options=Object.create(options || {});\n    if (options.minMaxRatio===undefined) options.minMaxRatio=0.00025;\n    if (options.broadRatio===undefined) options.broadRatio=0.00;\n    if (options.noiseLevel===undefined) options.noiseLevel=undefined;\n    if (options.noiseFactor===undefined) options.noiseFactor=3;\n    if (options.maxCriteria===undefined) options.maxCriteria=true;\n    if (options.smoothY===undefined) options.smoothY=true;\n    if (options.realTopDetection===undefined) options.realTopDetection=false;\n\n    var sgOptions = extend({}, sgDefOptions, options.sgOptions);\n\n    //console.log(JSON.stringify(stats.array.minMax(y)));\n    if(options.noiseLevel===undefined){\n        //We have to know if x is equally spaced\n        var maxDx=0, minDx=Number.MAX_VALUE,tmp;\n        for(var i=0;i< x.length-1;i++){\n            var tmp = Math.abs(x[i+1]-x[i]);\n            if(tmp<minDx){\n                minDx = tmp;\n            }\n            if(tmp>maxDx){\n                maxDx = tmp;\n            }\n        }\n\n        if((maxDx-minDx)/maxDx<0.05){\n\n            options.noiseLevel = getNoiseLevel(y);\n            //console.log(options.noiseLevel+\" \"+stats.array.median(y));\n        }\n        else{\n            options.noiseLevel = 0;\n        }\n    }\n    //console.log(\"options.noiseLevel \"+options.noiseLevel);\n    y=[].concat(y);\n    var yCorrection = {m:1, b:options.noiseLevel};\n    if(!options.maxCriteria){\n        yCorrection.m =-1;\n        yCorrection.b*=-1;\n    }\n\n    for (var i=0; i<y.length; i++){\n        y[i]=yCorrection.m*y[i]-yCorrection.b;\n    }\n\n    for (var i=0; i<y.length; i++) {\n        if (y[i] < 0) {\n            y[i] = 0;\n        }\n    }\n\n    //If the max difference between delta x is less than 5%, then, we can assume it to be equally spaced variable\n    var Y = y;\n    if((maxDx-minDx)/maxDx<0.05){\n        if(options.smoothY)\n            Y = SG(y, x[1]-x[0], {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:0});\n        var dY = SG(y, x[1]-x[0], {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:1});\n        var ddY = SG(y, x[1]-x[0], {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:2});\n    }\n    else{\n        if(options.smoothY)\n            Y = SG(y, x, {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:0});\n        var dY = SG(y, x, {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:1});\n        var ddY = SG(y, x, {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:2});\n    }\n\n    var X = x;\n    var dx = x[1]-x[0];\n    var maxDdy=0;\n    var maxY = 0;\n    //console.log(Y.length);\n    for (var i = 0; i < Y.length ; i++){\n        if(Math.abs(ddY[i])>maxDdy){\n            maxDdy = Math.abs(ddY[i]);\n        }\n        if(Math.abs(Y[i])>maxY){\n            maxY = Math.abs(Y[i]);\n        }\n    }\n    //console.log(maxY+\"x\"+maxDy+\"x\"+maxDdy);\n\n    var minddY = [];\n    var intervalL = [];\n    var intervalR = [];\n    var lastMax = null;\n    var lastMin = null;\n    var broadMask = new Array();\n    //console.log(dx);\n    //By the intermediate value theorem We cannot find 2 consecutive maxima or minima\n    for (var i = 1; i < Y.length -1 ; i++){\n        //console.log(dY[i]);\n        if ((dY[i] < dY[i-1]) && (dY[i] <= dY[i+1])||\n            (dY[i] <= dY[i-1]) && (dY[i] < dY[i+1])) {\n            lastMin = X[i];\n            //console.log(\"min \"+lastMin);\n            if(dx>0&&lastMax!=null){\n                intervalL.push(lastMax);\n                intervalR.push(lastMin);\n\n            }\n        }\n\n        if ((dY[i] >= dY[i-1]) && (dY[i] > dY[i+1])||\n            (dY[i] > dY[i-1]) && (dY[i] >= dY[i+1])) {\n            lastMax = X[i];\n            //console.log(\"max \"+lastMax);\n            if(dx<0&&lastMin!=null){\n                intervalL.push(lastMax);\n                intervalR.push(lastMin);\n            }\n        }\n        if ((ddY[i] < ddY[i-1]) && (ddY[i] < ddY[i+1])) {\n            minddY.push(i);//( [X[i], Y[i], i] );  // TODO should we change this to have 3 arrays ? Huge overhead creating arrays\n            if(Math.abs(ddY[i])>options.broadRatio*maxDdy){ // TODO should this be a parameter =\n                broadMask.push(false);\n            }\n            else{\n                broadMask.push(true);\n            }\n        }\n    }\n    //\n    //console.log(intervalL.length+\" \"+minddY.length+\" \"+broadMask.length);\n    var signals = [];\n    var lastK = 0,possible, k, f,frequency, distanceJ, minDistance, gettingCloser;\n    for (var j = 0; j < minddY.length; j++){\n        frequency = X[minddY[j]];//minddY[j][0];\n        possible = -1;\n        k=lastK+1;\n        minDistance = Number.MAX_VALUE;\n        distanceJ = 0;\n        gettingCloser=true;\n        while(possible==-1&&k<intervalL.length&&gettingCloser){\n            distanceJ = Math.abs(frequency-(intervalL[k]+intervalR[k])/2);\n            //Still getting closer?\n            if(distanceJ<minDistance){\n                minDistance = distanceJ;\n            }\n            else{\n                gettingCloser = false;\n            }\n            if( distanceJ <Math.abs(intervalL[k]-intervalR[k])/2){\n                possible=k;\n                lastK = k;\n            }\n            k++;\n        }\n        //console.log(lastK+\" \"+intervalL.length+\" possible \"+k);\n        if (possible!=-1){\n            //console.log(height);\n            if (Math.abs(Y[minddY[j]]) > options.minMaxRatio*maxY) {\n                signals.push({\n                    i:minddY[j],\n                    x: frequency,\n                    y: (Y[minddY[j]]-yCorrection.b)/yCorrection.m,\n                    width:Math.abs(intervalR[possible] - intervalL[possible]),//widthCorrection\n                    soft:broadMask[j]\n                })\n            }\n        }\n    }\n\n\n    if(options.realTopDetection){\n        realTopDetection(signals,X,Y);\n    }\n\n    //Correct the values to fit the original spectra data\n    for(var j=0;j<signals.length;j++){\n        signals[j].base=options.noiseLevel;\n    }\n\n    signals.sort(function (a, b) {\n        return a.x - b.x;\n    });\n\n    return signals;\n\n}\n\nfunction getNoiseLevel(y){\n    var mean = 0,stddev=0;\n    var length = y.length,i=0;\n    for(i = 0; i < length; i++){\n        mean+=y[i];\n    }\n    mean/=length;\n    var averageDeviations = new Array(length);\n    for (i = 0; i < length; i++)\n        averageDeviations[i] = Math.abs(y[i] - mean);\n    averageDeviations.sort();\n    if (length % 2 == 1) {\n        stddev = averageDeviations[(length-1)/2] / 0.6745;\n    } else {\n        stddev = 0.5*(averageDeviations[length/2]+averageDeviations[length/2-1]) / 0.6745;\n    }\n\n    return stddev;\n}\n\nfunction realTopDetection(peakList, x, y){\n    //console.log(peakList);\n    //console.log(x);\n    //console.log(y);\n    var listP = [];\n    var alpha, beta, gamma, p,currentPoint;\n    for(var j=0;j<peakList.length;j++){\n        currentPoint = peakList[j].i;//peakList[j][2];\n        var tmp = currentPoint;\n        //The detected peak could be moved 1 or 2 unit to left or right.\n        if(y[currentPoint-1]>=y[currentPoint-2]\n            &&y[currentPoint-1]>=y[currentPoint]) {\n            currentPoint--;\n        }\n        else{\n            if(y[currentPoint+1]>=y[currentPoint]\n                &&y[currentPoint+1]>=y[currentPoint+2]) {\n                currentPoint++;\n            }\n            else{\n                if(y[currentPoint-2]>=y[currentPoint-3]\n                    &&y[currentPoint-2]>=y[currentPoint-1]) {\n                    currentPoint-=2;\n                }\n                else{\n                    if(y[currentPoint+2]>=y[currentPoint+1]\n                        &&y[currentPoint+2]>=y[currentPoint+3]) {\n                        currentPoint+=2;\n                    }\n                }\n            }\n        }\n        if(y[currentPoint-1]>0&&y[currentPoint+1]>0\n            &&y[currentPoint]>=y[currentPoint-1]\n            &&y[currentPoint]>=y[currentPoint+1]) {\n            alpha = 20 * Math.log10(y[currentPoint - 1]);\n            beta = 20 * Math.log10(y[currentPoint]);\n            gamma = 20 * Math.log10(y[currentPoint + 1]);\n            p = 0.5 * (alpha - gamma) / (alpha - 2 * beta + gamma);\n            //console.log(\"p: \"+p);\n            //console.log(x[currentPoint]+\" \"+tmp+\" \"+currentPoint);\n            peakList[j].x = x[currentPoint] + (x[currentPoint]-x[currentPoint-1])*p;\n            peakList[j].y = y[currentPoint] - 0.25 * (y[currentPoint - 1]\n                - y[currentPoint + 1]) * p;//signal.peaks[j].intensity);\n            //console.log(y[tmp]+\" \"+peakList[j].y);\n        }\n    }\n}\n\nmodule.exports=gsd;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/gsd.js\n ** module id = 15\n ** module chunks = 0\n **/","'use strict';\n\nexports.array = require('./array');\nexports.matrix = require('./matrix');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-stat/index.js\n ** module id = 16\n ** module chunks = 0\n **/","'use strict';\n\nfunction compareNumbers(a, b) {\n    return a - b;\n}\n\n/**\n * Computes the sum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.sum = function sum(values) {\n    var sum = 0;\n    for (var i = 0; i < values.length; i++) {\n        sum += values[i];\n    }\n    return sum;\n};\n\n/**\n * Computes the maximum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.max = function max(values) {\n    var max = -Infinity;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] > max) max = values[i];\n    }\n    return max;\n};\n\n/**\n * Computes the minimum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.min = function min(values) {\n    var min = Infinity;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] < min) min = values[i];\n    }\n    return min;\n};\n\n/**\n * Computes the min and max of the given values\n * @param {Array} values\n * @returns {{min: number, max: number}}\n */\nexports.minMax = function minMax(values) {\n    var min = Infinity;\n    var max = -Infinity;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] < min) min = values[i];\n        if (values[i] > max) max = values[i];\n    }\n    return {\n        min: min,\n        max: max\n    };\n};\n\n/**\n * Computes the arithmetic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.arithmeticMean = function arithmeticMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        sum += values[i];\n    }\n    return sum / l;\n};\n\n/**\n * {@link arithmeticMean}\n */\nexports.mean = exports.arithmeticMean;\n\n/**\n * Computes the geometric mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.geometricMean = function geometricMean(values) {\n    var mul = 1;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        mul *= values[i];\n    }\n    return Math.pow(mul, 1 / l);\n};\n\n/**\n * Computes the mean of the log of the given values\n * If the return value is exponentiated, it gives the same result as the\n * geometric mean.\n * @param {Array} values\n * @returns {number}\n */\nexports.logMean = function logMean(values) {\n    var lnsum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        lnsum += Math.log(values[i]);\n    }\n    return lnsum / l;\n};\n\n/**\n * Computes the weighted grand mean for a list of means and sample sizes\n * @param {Array} means - Mean values for each set of samples\n * @param {Array} samples - Number of original values for each set of samples\n * @returns {number}\n */\nexports.grandMean = function grandMean(means, samples) {\n    var sum = 0;\n    var n = 0;\n    var l = means.length;\n    for (var i = 0; i < l; i++) {\n        sum += samples[i] * means[i];\n        n += samples[i];\n    }\n    return sum / n;\n};\n\n/**\n * Computes the truncated mean of the given values using a given percentage\n * @param {Array} values\n * @param {number} percent - The percentage of values to keep (range: [0,1])\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.truncatedMean = function truncatedMean(values, percent, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = values.slice().sort(compareNumbers);\n    }\n    var l = values.length;\n    var k = Math.floor(l * percent);\n    var sum = 0;\n    for (var i = k; i < (l - k); i++) {\n        sum += values[i];\n    }\n    return sum / (l - 2 * k);\n};\n\n/**\n * Computes the harmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.harmonicMean = function harmonicMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] === 0) {\n            throw new RangeError('value at index ' + i + 'is zero');\n        }\n        sum += 1 / values[i];\n    }\n    return l / sum;\n};\n\n/**\n * Computes the contraharmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.contraHarmonicMean = function contraHarmonicMean(values) {\n    var r1 = 0;\n    var r2 = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        r1 += values[i] * values[i];\n        r2 += values[i];\n    }\n    if (r2 < 0) {\n        throw new RangeError('sum of values is negative');\n    }\n    return r1 / r2;\n};\n\n/**\n * Computes the median of the given values\n * @param {Array} values\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.median = function median(values, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = values.slice().sort(compareNumbers);\n    }\n    var l = values.length;\n    var half = Math.floor(l / 2);\n    if (l % 2 === 0) {\n        return (values[half - 1] + values[half]) * 0.5;\n    } else {\n        return values[half];\n    }\n};\n\n/**\n * Computes the variance of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.variance = function variance(values, unbiased) {\n    if (unbiased === undefined) unbiased = true;\n    var theMean = exports.mean(values);\n    var theVariance = 0;\n    var l = values.length;\n\n    for (var i = 0; i < l; i++) {\n        var x = values[i] - theMean;\n        theVariance += x * x;\n    }\n\n    if (unbiased) {\n        return theVariance / (l - 1);\n    } else {\n        return theVariance / l;\n    }\n};\n\n/**\n * Computes the standard deviation of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.standardDeviation = function standardDeviation(values, unbiased) {\n    return Math.sqrt(exports.variance(values, unbiased));\n};\n\nexports.standardError = function standardError(values) {\n    return exports.standardDeviation(values) / Math.sqrt(values.length);\n};\n\nexports.quartiles = function quartiles(values, alreadySorted) {\n    if (typeof(alreadySorted) === 'undefined') alreadySorted = false;\n    if (!alreadySorted) {\n        values = values.slice();\n        values.sort(compareNumbers);\n    }\n\n    var quart = values.length / 4;\n    var q1 = values[Math.ceil(quart) - 1];\n    var q2 = exports.median(values, true);\n    var q3 = values[Math.ceil(quart * 3) - 1];\n\n    return {q1: q1, q2: q2, q3: q3};\n};\n\nexports.pooledStandardDeviation = function pooledStandardDeviation(samples, unbiased) {\n    return Math.sqrt(exports.pooledVariance(samples, unbiased));\n};\n\nexports.pooledVariance = function pooledVariance(samples, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var sum = 0;\n    var length = 0, l = samples.length;\n    for (var i = 0; i < l; i++) {\n        var values = samples[i];\n        var vari = exports.variance(values);\n\n        sum += (values.length - 1) * vari;\n\n        if (unbiased)\n            length += values.length - 1;\n        else\n            length += values.length;\n    }\n    return sum / length;\n};\n\nexports.mode = function mode(values) {\n    var l = values.length,\n        itemCount = new Array(l),\n        i;\n    for (i = 0; i < l; i++) {\n        itemCount[i] = 0;\n    }\n    var itemArray = new Array(l);\n    var count = 0;\n\n    for (i = 0; i < l; i++) {\n        var index = itemArray.indexOf(values[i]);\n        if (index >= 0)\n            itemCount[index]++;\n        else {\n            itemArray[count] = values[i];\n            itemCount[count] = 1;\n            count++;\n        }\n    }\n\n    var maxValue = 0, maxIndex = 0;\n    for (i = 0; i < count; i++) {\n        if (itemCount[i] > maxValue) {\n            maxValue = itemCount[i];\n            maxIndex = i;\n        }\n    }\n\n    return itemArray[maxIndex];\n};\n\nexports.covariance = function covariance(vector1, vector2, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var mean1 = exports.mean(vector1);\n    var mean2 = exports.mean(vector2);\n\n    if (vector1.length !== vector2.length)\n        throw \"Vectors do not have the same dimensions\";\n\n    var cov = 0, l = vector1.length;\n    for (var i = 0; i < l; i++) {\n        var x = vector1[i] - mean1;\n        var y = vector2[i] - mean2;\n        cov += x * y;\n    }\n\n    if (unbiased)\n        return cov / (l - 1);\n    else\n        return cov / l;\n};\n\nexports.skewness = function skewness(values, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n\n    var s2 = 0, s3 = 0, l = values.length;\n    for (var i = 0; i < l; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s3 += dev * dev * dev;\n    }\n    var m2 = s2 / l;\n    var m3 = s3 / l;\n\n    var g = m3 / (Math.pow(m2, 3 / 2.0));\n    if (unbiased) {\n        var a = Math.sqrt(l * (l - 1));\n        var b = l - 2;\n        return (a / b) * g;\n    }\n    else {\n        return g;\n    }\n};\n\nexports.kurtosis = function kurtosis(values, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n    var n = values.length, s2 = 0, s4 = 0;\n\n    for (var i = 0; i < n; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s4 += dev * dev * dev * dev;\n    }\n    var m2 = s2 / n;\n    var m4 = s4 / n;\n\n    if (unbiased) {\n        var v = s2 / (n - 1);\n        var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n        var b = s4 / (v * v);\n        var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n\n        return a * b - 3 * c;\n    }\n    else {\n        return m4 / (m2 * m2) - 3;\n    }\n};\n\nexports.entropy = function entropy(values, eps) {\n    if (typeof(eps) === 'undefined') eps = 0;\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * Math.log(values[i] + eps);\n    return -sum;\n};\n\nexports.weightedMean = function weightedMean(values, weights) {\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * weights[i];\n    return sum;\n};\n\nexports.weightedStandardDeviation = function weightedStandardDeviation(values, weights) {\n    return Math.sqrt(exports.weightedVariance(values, weights));\n};\n\nexports.weightedVariance = function weightedVariance(values, weights) {\n    var theMean = exports.weightedMean(values, weights);\n    var vari = 0, l = values.length;\n    var a = 0, b = 0;\n\n    for (var i = 0; i < l; i++) {\n        var z = values[i] - theMean;\n        var w = weights[i];\n\n        vari += w * (z * z);\n        b += w;\n        a += w * w;\n    }\n\n    return vari * (b / (b * b - a));\n};\n\nexports.center = function center(values, inPlace) {\n    if (typeof(inPlace) === 'undefined') inPlace = false;\n\n    var result = values;\n    if (!inPlace)\n        result = values.slice();\n\n    var theMean = exports.mean(result), l = result.length;\n    for (var i = 0; i < l; i++)\n        result[i] -= theMean;\n};\n\nexports.standardize = function standardize(values, standardDev, inPlace) {\n    if (typeof(standardDev) === 'undefined') standardDev = exports.standardDeviation(values);\n    if (typeof(inPlace) === 'undefined') inPlace = false;\n    var l = values.length;\n    var result = inPlace ? values : new Array(l);\n    for (var i = 0; i < l; i++)\n        result[i] = values[i] / standardDev;\n    return result;\n};\n\nexports.cumulativeSum = function cumulativeSum(array) {\n    var l = array.length;\n    var result = new Array(l);\n    result[0] = array[0];\n    for (var i = 1; i < l; i++)\n        result[i] = result[i - 1] + array[i];\n    return result;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-stat/array.js\n ** module id = 17\n ** module chunks = 0\n **/","'use strict';\nvar arrayStat = require('./array');\n\n// https://github.com/accord-net/framework/blob/development/Sources/Accord.Statistics/Tools.cs\n\nfunction entropy(matrix, eps) {\n    if (typeof(eps) === 'undefined') {\n        eps = 0;\n    }\n    var sum = 0,\n        l1 = matrix.length,\n        l2 = matrix[0].length;\n    for (var i = 0; i < l1; i++) {\n        for (var j = 0; j < l2; j++) {\n            sum += matrix[i][j] * Math.log(matrix[i][j] + eps);\n        }\n    }\n    return -sum;\n}\n\nfunction mean(matrix, dimension) {\n    if (typeof(dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        theMean, N, i, j;\n\n    if (dimension === -1) {\n        theMean = [0];\n        N = rows * cols;\n        for (i = 0; i < rows; i++) {\n            for (j = 0; j < cols; j++) {\n                theMean[0] += matrix[i][j];\n            }\n        }\n        theMean[0] /= N;\n    } else if (dimension === 0) {\n        theMean = new Array(cols);\n        N = rows;\n        for (j = 0; j < cols; j++) {\n            theMean[j] = 0;\n            for (i = 0; i < rows; i++) {\n                theMean[j] += matrix[i][j];\n            }\n            theMean[j] /= N;\n        }\n    } else if (dimension === 1) {\n        theMean = new Array(rows);\n        N = cols;\n        for (j = 0; j < rows; j++) {\n            theMean[j] = 0;\n            for (i = 0; i < cols; i++) {\n                theMean[j] += matrix[j][i];\n            }\n            theMean[j] /= N;\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n    return theMean;\n}\n\nfunction standardDeviation(matrix, means, unbiased) {\n    var vari = variance(matrix, means, unbiased), l = vari.length;\n    for (var i = 0; i < l; i++) {\n        vari[i] = Math.sqrt(vari[i]);\n    }\n    return vari;\n}\n\nfunction variance(matrix, means, unbiased) {\n    if (typeof(unbiased) === 'undefined') {\n        unbiased = true;\n    }\n    means = means || mean(matrix);\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length;\n    var vari = new Array(cols);\n\n    for (var j = 0; j < cols; j++) {\n        var sum1 = 0, sum2 = 0, x = 0;\n        for (var i = 0; i < rows; i++) {\n            x = matrix[i][j] - means[j];\n            sum1 += x;\n            sum2 += x * x;\n        }\n        if (unbiased) {\n            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / (rows - 1);\n        } else {\n            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / rows;\n        }\n    }\n    return vari;\n}\n\nfunction median(matrix) {\n    var rows = matrix.length, cols = matrix[0].length;\n    var medians = new Array(cols);\n\n    for (var i = 0; i < cols; i++) {\n        var data = new Array(rows);\n        for (var j = 0; j < rows; j++) {\n            data[j] = matrix[j][i];\n        }\n        data.sort();\n        var N = data.length;\n        if (N % 2 === 0) {\n            medians[i] = (data[N / 2] + data[(N / 2) - 1]) * 0.5;\n        } else {\n            medians[i] = data[Math.floor(N / 2)];\n        }\n    }\n    return medians;\n}\n\nfunction mode(matrix) {\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        modes = new Array(cols),\n        i, j;\n    for (i = 0; i < cols; i++) {\n        var itemCount = new Array(rows);\n        for (var k = 0; k < rows; k++) {\n            itemCount[k] = 0;\n        }\n        var itemArray = new Array(rows);\n        var count = 0;\n\n        for (j = 0; j < rows; j++) {\n            var index = itemArray.indexOf(matrix[j][i]);\n            if (index >= 0) {\n                itemCount[index]++;\n            } else {\n                itemArray[count] = matrix[j][i];\n                itemCount[count] = 1;\n                count++;\n            }\n        }\n\n        var maxValue = 0, maxIndex = 0;\n        for (j = 0; j < count; j++) {\n            if (itemCount[j] > maxValue) {\n                maxValue = itemCount[j];\n                maxIndex = j;\n            }\n        }\n\n        modes[i] = itemArray[maxIndex];\n    }\n    return modes;\n}\n\nfunction skewness(matrix, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var means = mean(matrix);\n    var n = matrix.length, l = means.length;\n    var skew = new Array(l);\n\n    for (var j = 0; j < l; j++) {\n        var s2 = 0, s3 = 0;\n        for (var i = 0; i < n; i++) {\n            var dev = matrix[i][j] - means[j];\n            s2 += dev * dev;\n            s3 += dev * dev * dev;\n        }\n\n        var m2 = s2 / n;\n        var m3 = s3 / n;\n        var g = m3 / Math.pow(m2, 3 / 2);\n\n        if (unbiased) {\n            var a = Math.sqrt(n * (n - 1));\n            var b = n - 2;\n            skew[j] = (a / b) * g;\n        } else {\n            skew[j] = g;\n        }\n    }\n    return skew;\n}\n\nfunction kurtosis(matrix, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var means = mean(matrix);\n    var n = matrix.length, m = matrix[0].length;\n    var kurt = new Array(m);\n\n    for (var j = 0; j < m; j++) {\n        var s2 = 0, s4 = 0;\n        for (var i = 0; i < n; i++) {\n            var dev = matrix[i][j] - means[j];\n            s2 += dev * dev;\n            s4 += dev * dev * dev * dev;\n        }\n        var m2 = s2 / n;\n        var m4 = s4 / n;\n\n        if (unbiased) {\n            var v = s2 / (n - 1);\n            var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n            var b = s4 / (v * v);\n            var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n            kurt[j] = a * b - 3 * c;\n        } else {\n            kurt[j] = m4 / (m2 * m2) - 3;\n        }\n    }\n    return kurt;\n}\n\nfunction standardError(matrix) {\n    var samples = matrix.length;\n    var standardDeviations = standardDeviation(matrix), l = standardDeviations.length;\n    var standardErrors = new Array(l);\n    var sqrtN = Math.sqrt(samples);\n\n    for (var i = 0; i < l; i++) {\n        standardErrors[i] = standardDeviations[i] / sqrtN;\n    }\n    return standardErrors;\n}\n\nfunction covariance(matrix, dimension) {\n    return scatter(matrix, undefined, dimension);\n}\n\nfunction scatter(matrix, divisor, dimension) {\n    if (typeof(dimension) === 'undefined') {\n        dimension = 0;\n    }\n    if (typeof(divisor) === 'undefined') {\n        if (dimension === 0) {\n            divisor = matrix.length - 1;\n        } else if (dimension === 1) {\n            divisor = matrix[0].length - 1;\n        }\n    }\n    var means = mean(matrix, dimension),\n        rows = matrix.length;\n    if (rows === 0) {\n        return [[]];\n    }\n    var cols = matrix[0].length,\n        cov, i, j, s, k;\n\n    if (dimension === 0) {\n        cov = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            cov[i] = new Array(cols);\n        }\n        for (i = 0; i < cols; i++) {\n            for (j = i; j < cols; j++) {\n                s = 0;\n                for (k = 0; k < rows; k++) {\n                    s += (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n                }\n                s /= divisor;\n                cov[i][j] = s;\n                cov[j][i] = s;\n            }\n        }\n    } else if (dimension === 1) {\n        cov = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            cov[i] = new Array(rows);\n        }\n        for (i = 0; i < rows; i++) {\n            for (j = i; j < rows; j++) {\n                s = 0;\n                for (k = 0; k < cols; k++) {\n                    s += (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n                }\n                s /= divisor;\n                cov[i][j] = s;\n                cov[j][i] = s;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    return cov;\n}\n\nfunction correlation(matrix) {\n    var means = mean(matrix),\n        standardDeviations = standardDeviation(matrix, true, means),\n        scores = zScores(matrix, means, standardDeviations),\n        rows = matrix.length,\n        cols = matrix[0].length,\n        i, j;\n\n    var cor = new Array(cols);\n    for (i = 0; i < cols; i++) {\n        cor[i] = new Array(cols);\n    }\n    for (i = 0; i < cols; i++) {\n        for (j = i; j < cols; j++) {\n            var c = 0;\n            for (var k = 0, l = scores.length; k < l; k++) {\n                c += scores[k][j] * scores[k][i];\n            }\n            c /= rows - 1;\n            cor[i][j] = c;\n            cor[j][i] = c;\n        }\n    }\n    return cor;\n}\n\nfunction zScores(matrix, means, standardDeviations) {\n    means = means || mean(matrix);\n    if (typeof(standardDeviations) === 'undefined') standardDeviations = standardDeviation(matrix, true, means);\n    return standardize(center(matrix, means, false), standardDeviations, true);\n}\n\nfunction center(matrix, means, inPlace) {\n    means = means || mean(matrix);\n    var result = matrix,\n        l = matrix.length,\n        i, j, jj;\n\n    if (!inPlace) {\n        result = new Array(l);\n        for (i = 0; i < l; i++) {\n            result[i] = new Array(matrix[i].length);\n        }\n    }\n\n    for (i = 0; i < l; i++) {\n        var row = result[i];\n        for (j = 0, jj = row.length; j < jj; j++) {\n            row[j] = matrix[i][j] - means[j];\n        }\n    }\n    return result;\n}\n\nfunction standardize(matrix, standardDeviations, inPlace) {\n    if (typeof(standardDeviations) === 'undefined') standardDeviations = standardDeviation(matrix);\n    var result = matrix,\n        l = matrix.length,\n        i, j, jj;\n\n    if (!inPlace) {\n        result = new Array(l);\n        for (i = 0; i < l; i++) {\n            result[i] = new Array(matrix[i].length);\n        }\n    }\n\n    for (i = 0; i < l; i++) {\n        var resultRow = result[i];\n        var sourceRow = matrix[i];\n        for (j = 0, jj = resultRow.length; j < jj; j++) {\n            if (standardDeviations[j] !== 0 && !isNaN(standardDeviations[j])) {\n                resultRow[j] = sourceRow[j] / standardDeviations[j];\n            }\n        }\n    }\n    return result;\n}\n\nfunction weightedVariance(matrix, weights) {\n    var means = mean(matrix);\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length;\n    var vari = new Array(cols);\n\n    for (var j = 0; j < cols; j++) {\n        var sum = 0;\n        var a = 0, b = 0;\n\n        for (var i = 0; i < rows; i++) {\n            var z = matrix[i][j] - means[j];\n            var w = weights[i];\n\n            sum += w * (z * z);\n            b += w;\n            a += w * w;\n        }\n\n        vari[j] = sum * (b / (b * b - a));\n    }\n\n    return vari;\n}\n\nfunction weightedMean(matrix, weights, dimension) {\n    if (typeof(dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length,\n        means, i, ii, j, w, row;\n\n    if (dimension === 0) {\n        means = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            means[i] = 0;\n        }\n        for (i = 0; i < rows; i++) {\n            row = matrix[i];\n            w = weights[i];\n            for (j = 0; j < cols; j++) {\n                means[j] += row[j] * w;\n            }\n        }\n    } else if (dimension === 1) {\n        means = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            means[i] = 0;\n        }\n        for (j = 0; j < rows; j++) {\n            row = matrix[j];\n            w = weights[j];\n            for (i = 0; i < cols; i++) {\n                means[j] += row[i] * w;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    var weightSum = arrayStat.sum(weights);\n    if (weightSum !== 0) {\n        for (i = 0, ii = means.length; i < ii; i++) {\n            means[i] /= weightSum;\n        }\n    }\n    return means;\n}\n\nfunction weightedCovariance(matrix, weights, means, dimension) {\n    dimension = dimension || 0;\n    means = means || weightedMean(matrix, weights, dimension);\n    var s1 = 0, s2 = 0;\n    for (var i = 0, ii = weights.length; i < ii; i++) {\n        s1 += weights[i];\n        s2 += weights[i] * weights[i];\n    }\n    var factor = s1 / (s1 * s1 - s2);\n    return weightedScatter(matrix, weights, means, factor, dimension);\n}\n\nfunction weightedScatter(matrix, weights, means, factor, dimension) {\n    dimension = dimension || 0;\n    means = means || weightedMean(matrix, weights, dimension);\n    if (typeof(factor) === 'undefined') {\n        factor = 1;\n    }\n    var rows = matrix.length;\n    if (rows === 0) {\n        return [[]];\n    }\n    var cols = matrix[0].length,\n        cov, i, j, k, s;\n\n    if (dimension === 0) {\n        cov = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            cov[i] = new Array(cols);\n        }\n        for (i = 0; i < cols; i++) {\n            for (j = i; j < cols; j++) {\n                s = 0;\n                for (k = 0; k < rows; k++) {\n                    s += weights[k] * (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n                }\n                cov[i][j] = s * factor;\n                cov[j][i] = s * factor;\n            }\n        }\n    } else if (dimension === 1) {\n        cov = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            cov[i] = new Array(rows);\n        }\n        for (i = 0; i < rows; i++) {\n            for (j = i; j < rows; j++) {\n                s = 0;\n                for (k = 0; k < cols; k++) {\n                    s += weights[k] * (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n                }\n                cov[i][j] = s * factor;\n                cov[j][i] = s * factor;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    return cov;\n}\n\nmodule.exports = {\n    entropy: entropy,\n    mean: mean,\n    standardDeviation: standardDeviation,\n    variance: variance,\n    median: median,\n    mode: mode,\n    skewness: skewness,\n    kurtosis: kurtosis,\n    standardError: standardError,\n    covariance: covariance,\n    scatter: scatter,\n    correlation: correlation,\n    zScores: zScores,\n    center: center,\n    standardize: standardize,\n    weightedVariance: weightedVariance,\n    weightedMean: weightedMean,\n    weightedCovariance: weightedCovariance,\n    weightedScatter: weightedScatter\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-stat/matrix.js\n ** module id = 18\n ** module chunks = 0\n **/","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) {/**/}\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0],\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = target[name];\n\t\t\t\tcopy = options[name];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/extend/index.js\n ** module id = 19\n ** module chunks = 0\n **/","//Code translate from Pascal source in http://pubs.acs.org/doi/pdf/10.1021/ac00205a007\nvar extend = require('extend');\nvar stat = require('ml-stat');\n\nvar defaultOptions = {\n    windowSize: 9,\n    derivative: 0,\n    polynomial: 3,\n};\n\n\nfunction SavitzkyGolay(data, h, options) {\n    options = extend({}, defaultOptions, options);\n\n    if ((options.windowSize % 2 === 0) || (options.windowSize < 5) || !(Number.isInteger(options.windowSize)))\n            throw new RangeError('Invalid window size (should be odd and at least 5 integer number)')\n\n\n    if (options.windowSize>data.length)\n        throw new RangeError('Window size is higher than the data length '+options.windowSize+\">\"+data.length);\n    if ((options.derivative < 0) || !(Number.isInteger(options.derivative)))\n        throw new RangeError('Derivative should be a positive integer');\n    if ((options.polynomial < 1) || !(Number.isInteger(options.polynomial)))\n        throw new RangeError('Polynomial should be a positive integer');\n    if (options.polynomial >= 6)\n        console.warn('You should not use polynomial grade higher than 5 if you are' +\n            ' not sure that your data arises from such a model. Possible polynomial oscillation problems');\n\n    var windowSize = options.windowSize;\n\n    var half = Math.floor(windowSize/2);\n    var np = data.length;\n    var ans = new Array(np);\n    var weights = fullWeights(windowSize,options.polynomial,options.derivative);\n    var hs = 0;\n    var constantH = true;\n    if( Object.prototype.toString.call( h ) === '[object Array]' ) {\n        constantH = false;\n    }\n    else{\n        hs = Math.pow(h, options.derivative);\n    }\n    //console.log(\"Constant h: \"+constantH);\n    //For the borders\n    for(var i=0;i<half;i++){\n        var wg1=weights[half-i-1];\n        var wg2=weights[half+i+1];\n        var d1 = 0,d2=0;\n        for (var l = 0; l < windowSize; l++){\n            d1 += wg1[l] * data[l];\n            d2 += wg2[l] * data[np-windowSize+l-1];\n        }\n        if(constantH){\n            ans[half-i-1] = d1/hs;\n            ans[np-half+i] = d2/hs;\n        }\n        else{\n            hs = getHs(h,half-i-1,half, options.derivative);\n            ans[half-i-1] = d1/hs;\n            hs = getHs(h,np-half+i,half, options.derivative);\n            ans[np-half+i] = d2/hs;\n        }\n    }\n    //For the internal points\n    var wg = weights[half];\n    for(var i=windowSize;i<np+1;i++){\n        var d = 0;\n        for (var l = 0; l < windowSize; l++)\n            d += wg[l] * data[l+i-windowSize];\n        if(!constantH)\n            hs = getHs(h,i-half-1,half, options.derivative);\n        ans[i-half-1] = d/hs;\n    }\n    return ans;\n}\n\nfunction getHs(h,center,half,derivative){\n    var hs = 0;\n    var count = 0;\n    for(var i=center-half;i<center+half;i++){\n        if(i>=0 && i < h.length-1){\n            hs+= (h[i+1]-h[i]);\n            count++;\n        }\n    }\n    return Math.pow(hs/count,derivative);\n}\n\nfunction GramPoly(i,m,k,s){\n    var Grampoly = 0;\n    if(k>0){\n        Grampoly = (4*k-2)/(k*(2*m-k+1))*(i*GramPoly(i,m,k-1,s) +\n            s*GramPoly(i,m,k-1,s-1)) - ((k-1)*(2*m+k))/(k*(2*m-k+1))*GramPoly(i,m,k-2,s);\n    }\n    else{\n        if(k==0&&s==0){\n            Grampoly=1;\n        }\n        else{\n            Grampoly=0;\n        }\n    }\n    //console.log(Grampoly);\n    return Grampoly;\n}\n\nfunction GenFact(a,b){\n    var gf=1;\n    if(a>=b){\n        for(var j=a-b+1;j<=a;j++){\n            gf*=j;\n        }\n    }\n    return gf;\n}\n\nfunction Weight(i,t,m,n,s){\n    var sum=0;\n    for(var k=0;k<=n;k++){\n        //console.log(k);\n        sum+=(2*k+1)*(GenFact(2*m,k)/GenFact(2*m+k+1,k+1))*GramPoly(i,m,k,0)*GramPoly(t,m,k,s)\n    }\n    return sum;\n}\n\n/**\n *\n * @param m  Number of points\n * @param n  Polynomial grade\n * @param s  Derivative\n */\nfunction fullWeights(m,n,s){\n    var weights = new Array(m);\n    var np = Math.floor(m/2);\n    for(var t=-np;t<=np;t++){\n        weights[t+np] = new Array(m);\n        for(var j=-np;j<=np;j++){\n            weights[t+np][j+np]=Weight(j,t,np,n,s);\n        }\n    }\n    return weights;\n}\n\n/*function entropy(data,h,options){\n    var trend = SavitzkyGolay(data,h,trendOptions);\n    var copy = new Array(data.length);\n    var sum = 0;\n    var max = 0;\n    for(var i=0;i<data.length;i++){\n        copy[i] = data[i]-trend[i];\n    }\n\n    sum/=data.length;\n    console.log(sum+\" \"+max);\n    console.log(stat.array.standardDeviation(copy));\n    console.log(Math.abs(stat.array.mean(copy))/stat.array.standardDeviation(copy));\n    return sum;\n\n}\n\n\n\nfunction guessWindowSize(data, h){\n    console.log(\"entropy \"+entropy(data,h,trendOptions));\n    return 5;\n}\n*/\nmodule.exports = SavitzkyGolay;\n \n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-savitzky-golay-generalized/src/index.js\n ** module id = 20\n ** module chunks = 0\n **/"],"sourceRoot":""}